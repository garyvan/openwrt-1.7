diff -purN OCTEON-SDK-org/executive/cvmx-hfa.c OCTEON-SDK/executive/cvmx-hfa.c
--- OCTEON-SDK-org/executive/cvmx-hfa.c	2014-04-04 15:15:59.000000000 +0530
+++ OCTEON-SDK/executive/cvmx-hfa.c	2014-04-04 15:23:01.000000000 +0530
@@ -40,22 +40,31 @@
 /**
  * @file
  *
- * Support library for the CN63XX, CN68XX hardware HFA engine.
+ * Support library for CN6XXX and CN70/71XX hardware HFA engine.
  *
  */
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <linux/export.h>
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-pko.h>
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-clock.h>
 #include <asm/octeon/cvmx-dfa-defs.h>
+#include <asm/octeon/cvmx-l2c.h>
 #include <asm/octeon/cvmx-hfa.h>
 #else
 #include "cvmx.h"
 #include "cvmx-fau.h"
 #include "cvmx-cmd-queue.h"
+#include "cvmx-helper.h"
+#include "cvmx-l2c.h"
 #include "cvmx-hfa.h"
-#include "cvmx-helper-fpa.h"
+#ifdef CVMX_BUILD_FOR_LINUX_USER
+#include <sys/sysmips.h>
+#include <asm/sysmips.h>
+
+extern int errno;
+#endif
 #endif
 
 /**
@@ -69,24 +78,35 @@ int cvmx_hfa_initialize(void)
 	cvmx_cmd_queue_result_t result;
 	void *initial_base_address;
 	int cmdsize;
-	int dfa_pool = (int)cvmx_fpa_get_dfa_pool();
-	uint64_t dfa_pool_size = cvmx_fpa_get_dfa_pool_block_size();
+	int dfa_pool;
+	unsigned long int dfa_pool_size;
 
-#ifndef CVMX_BUILD_FOR_LINUX_KERNEL
-	cvmx_fpa_global_initialize();
-	if(dfa_config.dfa_pool.buffer_count != 0)
-		__cvmx_helper_initialize_fpa_pool(dfa_pool, dfa_pool_size,
-			dfa_config.dfa_pool.buffer_count, "Dfa Cmd Buffers");
-#endif
-	cmdsize = ((dfa_pool_size - 8) / sizeof(cvmx_dfa_command_t)) * sizeof(cvmx_dfa_command_t);
-	result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_DFA, 0, dfa_pool, cmdsize + 8);
-	if (result != CVMX_CMD_QUEUE_SUCCESS)
-		return -1;
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+    dfa_pool = CVMX_FPA_DFA_POOL;
+    dfa_pool_size = CVMX_FPA_DFA_POOL_SIZE;
+#else 
+	dfa_pool = (int)cvmx_fpa_get_dfa_pool();
+	dfa_pool_size = cvmx_fpa_get_dfa_pool_block_size();
+#endif
+	cmdsize = ((dfa_pool_size - 8) / sizeof(cvmx_hfa_command_t)) * sizeof(cvmx_hfa_command_t);
+	result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_DFA, 0, 
+                                       dfa_pool, cmdsize + 8);
+    switch(result){
+        case CVMX_CMD_QUEUE_SUCCESS:
+            /*Do nothing*/
+        break;
+        case CVMX_CMD_QUEUE_ALREADY_SETUP:
+            return 0;
+        break;
+        default:
+            return (-1);
+        break;
+    }
 
 	control.u64 = 0;
 	control.cn31xx.dwbcnt = dfa_pool_size / 128;
 	control.s.pool = dfa_pool;
-	control.s.size = cmdsize / sizeof(cvmx_dfa_command_t);
+	control.s.size = cmdsize / sizeof(cvmx_hfa_command_t);
 	CVMX_SYNCWS;
 	cvmx_write_csr(CVMX_DFA_DIFCTL, control.u64);
 	initial_base_address = cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_DFA);
@@ -95,8 +115,9 @@ int cvmx_hfa_initialize(void)
 	cvmx_read_csr(CVMX_DFA_DIFRDPTR);	/* Read to make sure setup is complete */
 	return 0;
 }
-
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 EXPORT_SYMBOL(cvmx_hfa_initialize);
+#endif
 
 /**
  * Shutdown the DFA block. DFA must be idle when
@@ -113,8 +134,9 @@ int cvmx_hfa_shutdown(void)
 	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_DFA);
 	return 0;
 }
-
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 EXPORT_SYMBOL(cvmx_hfa_shutdown);
+#endif
 
 /**
  * Submit a command to the DFA block
@@ -123,35 +145,132 @@ EXPORT_SYMBOL(cvmx_hfa_shutdown);
  *
  * @return Zero on success, negative on failure
  */
-int cvmx_hfa_submit(cvmx_dfa_command_t * command)
+int cvmx_hfa_submit(cvmx_hfa_command_t * command)
 {
 	cvmx_cmd_queue_result_t result = cvmx_cmd_queue_write(CVMX_CMD_QUEUE_DFA, 1, 4, command->u64);
 	if (result == CVMX_CMD_QUEUE_SUCCESS)
 		cvmx_write_csr(CVMX_DFA_DBELL, 1);
 	return result;
 }
-
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 EXPORT_SYMBOL(cvmx_hfa_submit);
+#endif
 
-void *hfa_bootmem_alloc(uint64_t size, uint64_t alignment)
+void *hfa_bootmem_alloc(long unsigned int size, uint64_t alignment)
 {
-	int64_t address;
-
-	address = cvmx_bootmem_phy_alloc(size, 0, 0, alignment, 0);
-
-	if (address > 0)
-		return cvmx_phys_to_ptr(address);
-	else
-		return NULL;
+#ifndef CVMX_BOOTMEM_CORRUPT_CHECK
+    void *addr = NULL;
+    addr = cvmx_bootmem_alloc_range(size, alignment, 0, 0);
+#ifdef DEBUG
+    cvmx_dprintf("BOOTMEM ALLOC: ptr %p size %lu\n", addr, size); 
+#endif
+    return (addr);
+#else 
+    uint64_t alloc_size = size+(2*CHECK_SIZE);
+    void *addr = NULL;
+    addr = cvmx_bootmem_alloc_range(alloc_size, alignment, 0, 0);
+   
+    cvmx_dprintf("ALLOC: addr: %p size %lu\n", addr, size);
+    if(addr){ 
+        memset((uint8_t *)addr, 0xA, CHECK_SIZE);
+        memset((uint8_t *)addr+size+CHECK_SIZE, 0xB, CHECK_SIZE);
+        return ((uint8_t*)addr+CHECK_SIZE);
+    }
+    return addr;
+#endif
 }
-
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 EXPORT_SYMBOL(hfa_bootmem_alloc);
+#endif
 
-int hfa_bootmem_free(void *ptr, uint64_t size)
+int hfa_bootmem_free(void *ptr, long unsigned int size)
 {
 	uint64_t address;
+
+#ifdef CVMX_BOOTMEM_CORRUPT_CHECK
+    uint8_t buf1[CHECK_SIZE];
+    uint8_t buf2[CHECK_SIZE];
+   
+    memset(buf1, 0xA, CHECK_SIZE);
+    memset(buf2, 0xB, CHECK_SIZE);
+ 
+    if(memcmp((uint8_t *)(ptr-CHECK_SIZE), buf1, CHECK_SIZE)){
+        cvmx_dprintf("Buffer %p Accessed extra memory\n", 
+                                    ((uint8_t *)ptr-CHECK_SIZE));
+    }
+    if(memcmp((uint8_t *)ptr+size, buf2, CHECK_SIZE)){
+        cvmx_dprintf("Buffer(end) %p Accessed extra memory\n", 
+                                    ((uint8_t *)ptr-CHECK_SIZE));
+    }
+    memset((uint8_t *)(ptr-CHECK_SIZE), 0x0, CHECK_SIZE);
+    memset((uint8_t *)ptr+size, 0x0, CHECK_SIZE);
+    
+    size = (size+(2*CHECK_SIZE) + (CVMX_BOOTMEM_ALIGNMENT_SIZE -1)) & 
+                   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE -1);
+	address = cvmx_ptr_to_phys((uint8_t *)ptr-CHECK_SIZE);
+	return __cvmx_bootmem_phy_free(address, size, 0);
+#else
+#ifdef DEBUG
+    cvmx_dprintf("\t\t\t\tBOOTMEM FREE: ptr %p size %lu\n", ptr, size); 
+#endif    
+    /*Round size up of mult of minimum alignment bytes*/
+    size = (size + (CVMX_BOOTMEM_ALIGNMENT_SIZE -1)) & 
+                   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE -1);
 	address = cvmx_ptr_to_phys(ptr);
 	return __cvmx_bootmem_phy_free(address, size, 0);
+#endif
 }
-
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
 EXPORT_SYMBOL(hfa_bootmem_free);
+#endif
+
+const cvmx_bootmem_named_block_desc_t *
+hfa_bootmem_find_named_block(const char *name)
+{
+      return cvmx_bootmem_find_named_block(name);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_find_named_block);
+#endif
+
+void *hfa_bootmem_alloc_named(uint64_t size, uint64_t alignment, const char *name)
+{
+      return cvmx_bootmem_alloc_named(size, alignment, name);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_alloc_named);
+#endif
+
+int hfa_bootmem_free_named(const char *name)
+{
+      return cvmx_bootmem_free_named(name);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_free_named);
+#endif
+
+void hfa_l2c_flush(void)
+{
+#ifdef CVMX_BUILD_FOR_LINUX_USER
+    sysmips(HFA_MIPS_CAVIUM_L2C_FLUSH);
+#else    
+        cvmx_l2c_flush();
+#endif
+}
+     
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_l2c_flush);
+#endif
+
+const char *hfa_octeon_model_get_string(uint32_t chip_id)
+{
+      return octeon_model_get_string(chip_id);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_octeon_model_get_string);
+#endif
+
diff -purN OCTEON-SDK-org/executive/cvmx-hfa.h OCTEON-SDK/executive/cvmx-hfa.h
--- OCTEON-SDK-org/executive/cvmx-hfa.h	2014-04-04 15:15:59.000000000 +0530
+++ OCTEON-SDK/executive/cvmx-hfa.h	2014-04-04 15:25:59.000000000 +0530
@@ -40,7 +40,7 @@
 /**
  * @file
  *
- * Interface to the CN63XX, CN68XX hardware HFA engine.
+ * Interface to the CN6XXX and CN70/71XX hardware HFA engine.
  *
  * <hr>$Revision: 49448 $<hr>
  */
@@ -48,19 +48,29 @@
 #ifndef __CVMX_HFA_H__
 #define __CVMX_HFA_H__
 
-#ifndef CVMX_BUILD_FOR_LINUX_USER
-#include "cvmx-llm.h"
-#include "cvmx-wqe.h"
-#include "cvmx-fpa.h"
-#include "cvmx-bootmem.h"
-
 #ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <asm/octeon/cvmx-wqe.h>
+#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-bootmem.h>
 #include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-config.h>
+
+#ifdef CVMX_ENABLE_DFA_FUNCTIONS
+/* DFA queue cmd buffers */
+
+#define CVMX_FPA_DFA_POOL                   (4)             /**< DFA command buffers */
+#define CVMX_FPA_DFA_POOL_SIZE              (2 * CVMX_CACHE_LINE_SIZE)
 #endif
 
+#else 
+#include "cvmx-wqe.h"
+#include "cvmx-fpa.h"
+#include "cvmx-bootmem.h"
 #endif
+#define HFA_MIPS_CAVIUM_L2C_FLUSH 2002
 
 #define ENABLE_DEPRECATED	/* Set to enable the old 18/36 bit names */
+#define CHECK_SIZE     128
 
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
@@ -68,126 +78,134 @@ extern "C" {
 /* *INDENT-ON* */
 #endif
 
-#define	CVMX_DFA_ITYPE_MEMLOAD		0x0
-#define	CVMX_DFA_ITYPE_CACHELOAD	0x1
-#define	CVMX_DFA_ITYPE_GRAPHFREE	0x3
-#define	CVMX_DFA_ITYPE_GRAPHWALK	0x4
-
 typedef union {
 	uint64_t u64;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t size:24;
-		uint64_t addr:40;
-#else
-		uint64_t addr:40;
-		uint64_t size:24;
+        uint64_t varies0:34;
+        uint64_t store_full:1;
+        uint64_t varies1:2;
+        uint64_t itype:3;
+        uint64_t varies2:24;
+#else
+        uint64_t varies2:24;
+        uint64_t itype:3;
+        uint64_t varies1:2;
+        uint64_t store_full:1;
+        uint64_t varies0:34;
+#endif
+    };
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t f1:3;
+        uint64_t unused1:2;
+        uint64_t snode:27;
+        uint64_t gather_mode:1;
+        uint64_t little_endian:1;
+        uint64_t store_full:1;
+        uint64_t load_through:1;
+        uint64_t small:1;
+        uint64_t itype:3;
+        uint64_t unused0:2;
+        uint64_t mbase:22;
+#else
+        uint64_t mbase:22;
+        uint64_t unused0:2;
+        uint64_t itype:3;
+        uint64_t small:1;
+        uint64_t load_through:1;
+        uint64_t store_full:1;
+        uint64_t little_endian:1;
+        uint64_t gather_mode:1;
+        uint64_t snode:27;
+        uint64_t unused1:2;
+        uint64_t f1:3;
+#endif
+    } walk;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t unused4:7;
+        uint64_t dbase:9;
+        uint64_t unused3:2;
+        uint64_t cbase:14;
+        uint64_t gather_mode:1;
+        uint64_t little_endian:1;
+        uint64_t store_full:1;
+        uint64_t load_through:1;
+        uint64_t unused2:1;
+        uint64_t itype:3;
+        uint64_t unused1:6;
+        uint64_t dsize:10;
+        uint64_t unused0:2;
+        uint64_t pgid:6;
+#else
+        uint64_t pgid:6;
+        uint64_t unused0:2;
+        uint64_t dsize:10;
+        uint64_t unused1:6;
+        uint64_t itype:3;
+        uint64_t unused2:1;
+        uint64_t load_through:1;
+        uint64_t store_full:1;
+        uint64_t little_endian:1;
+        uint64_t gather_mode:1;
+        uint64_t cbase:14;
+        uint64_t unused3:2;
+        uint64_t dbase:9;
+        uint64_t unused4:7;
+#endif
+    } cload;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t unused2:32;
+        uint64_t gather_mode:1;
+        uint64_t little_endian:1;
+        uint64_t store_full:1;
+        uint64_t load_through:1;
+        uint64_t unused1:1;
+        uint64_t itype:3;
+        uint64_t unused0:2;
+        uint64_t mbase:22;
+#else
+        uint64_t mbase:22;
+        uint64_t unused0:2;
+        uint64_t itype:3;
+        uint64_t unused1:1;
+        uint64_t load_through:1;
+        uint64_t store_full:1;
+        uint64_t little_endian:1;
+        uint64_t gather_mode:1;
+        uint64_t unused2:32;
+#endif
+    } mload;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t unused2:34;
+        uint64_t store_full:1;
+        uint64_t unused1:2;
+        uint64_t itype:3;
+        uint64_t unused0:24;
+#else
+        uint64_t unused0:24;
+        uint64_t itype:3;
+        uint64_t unused1:2;
+        uint64_t store_full:1;
+        uint64_t unused2:34;
 #endif
-	} s;
-} cvmx_dfa_gather_entry_t;
+    } free;
+} cvmx_hfa_word0_t;
 
 typedef union {
+    uint64_t u64;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t f1:3;
-		uint64_t unused1:2;
-		uint64_t snode:27;
-		uint64_t gather_mode:1;
-		uint64_t little_endian:1;
-		uint64_t store_full:1;
-		uint64_t load_through:1;
-		uint64_t small:1;
-		uint64_t itype:3;
-		uint64_t unused0:2;
-		uint64_t mbase:22;
-#else
-		uint64_t mbase:22;
-		uint64_t unused0:2;
-		uint64_t itype:3;
-		uint64_t small:1;
-		uint64_t load_through:1;
-		uint64_t store_full:1;
-		uint64_t little_endian:1;
-		uint64_t gather_mode:1;
-		uint64_t snode:27;
-		uint64_t unused1:2;
-		uint64_t f1:3;
-#endif
-	} walk;
-	struct {
-#ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t unused4:7;
-		uint64_t dbase:9;
-		uint64_t unused3:2;
-		uint64_t cbase:14;
-		uint64_t gather_mode:1;
-		uint64_t little_endian:1;
-		uint64_t store_full:1;
-		uint64_t load_through:1;
-		uint64_t unused2:1;
-		uint64_t itype:3;
-		uint64_t unused1:6;
-		uint64_t dsize:10;
-		uint64_t unused0:2;
-		uint64_t pgid:6;
-#else
-		uint64_t pgid:6;
-		uint64_t unused0:2;
-		uint64_t dsize:10;
-		uint64_t unused1:6;
-		uint64_t itype:3;
-		uint64_t unused2:1;
-		uint64_t load_through:1;
-		uint64_t store_full:1;
-		uint64_t little_endian:1;
-		uint64_t gather_mode:1;
-		uint64_t cbase:14;
-		uint64_t unused3:2;
-		uint64_t dbase:9;
-		uint64_t unused4:7;
-#endif
-	} cload;
-	struct {
-#ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t unused2:32;
-		uint64_t gather_mode:1;
-		uint64_t little_endian:1;
-		uint64_t store_full:1;
-		uint64_t load_through:1;
-		uint64_t unused1:1;
-		uint64_t itype:3;
-		uint64_t unused0:2;
-		uint64_t mbase:22;
-#else
-		uint64_t mbase:22;
-		uint64_t unused0:2;
-		uint64_t itype:3;
-		uint64_t unused1:1;
-		uint64_t load_through:1;
-		uint64_t store_full:1;
-		uint64_t little_endian:1;
-		uint64_t gather_mode:1;
-		uint64_t unused2:32;
-#endif
-	} mload;
-	struct {
-#ifdef __BIG_ENDIAN_BITFIELD
-		uint64_t unused2:34;
-		uint64_t store_full:1;
-		uint64_t unused1:2;
-		uint64_t itype:3;
-		uint64_t unused0:24;
+        uint64_t varies0:24;
+        uint64_t rptr:40;
 #else
-		uint64_t unused0:24;
-		uint64_t itype:3;
-		uint64_t unused1:2;
-		uint64_t store_full:1;
-		uint64_t unused2:34;
+        uint64_t rptr:40;
+        uint64_t varies0:24;
 #endif
-	} free;
-} cvmx_dfa_word0_t;
-
-typedef union {
+    };
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t rmax:16;
@@ -234,13 +252,25 @@ typedef union {
 		uint64_t unused:24;
 #endif
 	} free;
-} cvmx_dfa_word1_t;
+} cvmx_hfa_word1_t;
 
 typedef union {
+    uint64_t u64;
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t varies0:20;
+        uint64_t clmsk:4;
+        uint64_t varies1:40;
+#else
+        uint64_t varies1:40;
+        uint64_t clmsk:4;
+        uint64_t varies0:20;
+#endif
+    };
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t dlen:16;
-		uint64_t srepl:2;
+	    uint64_t f5:2;
 		uint64_t unused:2;
 		uint64_t clmsk:4;
 		uint64_t dptr:40;
@@ -248,7 +278,7 @@ typedef union {
 		uint64_t dptr:40;
 		uint64_t clmsk:4;
 		uint64_t unused:2;
-		uint64_t srepl:2;
+	    uint64_t f5:2;
 		uint64_t dlen:16;
 #endif
 	} walk;
@@ -268,7 +298,7 @@ typedef union {
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t dlen:16;
-		uint64_t repl:2;
+        uint64_t f5:2;
 		uint64_t unused:2;
 		uint64_t clmsk:4;
 		uint64_t dptr:40;
@@ -276,7 +306,7 @@ typedef union {
 		uint64_t dptr:40;
 		uint64_t clmsk:4;
 		uint64_t unused:2;
-		uint64_t repl:2;
+        uint64_t f5:2;
 		uint64_t dlen:16;
 #endif
 	} mload;
@@ -291,9 +321,19 @@ typedef union {
 		uint64_t unused1:20;
 #endif
 	} free;
-} cvmx_dfa_word2_t;
+} cvmx_hfa_word2_t;
 
 typedef union {
+    uint64_t u64;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t varies0:24;
+        uint64_t wqptr:40;
+#else
+        uint64_t wqptr:40;
+        uint64_t varies0:24;
+#endif
+    };
 	struct {
 #ifdef __BIG_ENDIAN_BITFIELD
 		uint64_t unused1:2;
@@ -352,17 +392,17 @@ typedef union {
 		uint64_t unused1:2;
 #endif
 	} free;
-} cvmx_dfa_word3_t;
+} cvmx_hfa_word3_t;
 
 typedef union {
 	uint64_t u64[4];
 	struct {
-		cvmx_dfa_word0_t word0;
-		cvmx_dfa_word1_t word1;
-		cvmx_dfa_word2_t word2;
-		cvmx_dfa_word3_t word3;
+		cvmx_hfa_word0_t word0;
+		cvmx_hfa_word1_t word1;
+		cvmx_hfa_word2_t word2;
+		cvmx_hfa_word3_t word3;
 	};
-} cvmx_dfa_command_t;
+} cvmx_hfa_command_t;
 
 typedef struct
 {
@@ -382,15 +422,14 @@ static inline uint64_t cvmx_fpa_get_dfa_
 }
 
 
-#ifdef CVMX_ENABLE_DFA_FUNCTIONS
 /**
- * Initialize the DFA hardware before use
+ * Initialize the DFA/HFA hardware before use
  * Returns 0 on success, -1 on failure
  */
 int cvmx_hfa_initialize(void);
 
 /**
- * Shutdown and cleanup resources used by the DFA
+ * Shutdown and cleanup resources used by the DFA/HFA
  */
 int cvmx_hfa_shutdown(void);
 
@@ -401,7 +440,7 @@ int cvmx_hfa_shutdown(void);
  *
  * @return Zero on success, negative on failure
  */
-int cvmx_hfa_submit(cvmx_dfa_command_t * command);
+int cvmx_hfa_submit(cvmx_hfa_command_t * command);
 
 /**
  * Allocate a block of memory from the free list that was passed
@@ -413,7 +452,7 @@ int cvmx_hfa_submit(cvmx_dfa_command_t *
  *  @return pointer to block of memory, NULL on error 
  */
 
-void *hfa_bootmem_alloc(uint64_t size, uint64_t alignment);
+void *hfa_bootmem_alloc(unsigned long int size, uint64_t alignment);
 
 /**
  * Frees a block to the bootmem allocator list.  
@@ -426,9 +465,63 @@ void *hfa_bootmem_alloc(uint64_t size, u
  *
  */
 
-int hfa_bootmem_free(void *ptr, uint64_t size);
+int hfa_bootmem_free(void *ptr, unsigned long int size);
+/**
+ * Finds a named bootmem block by name.
+ *
+ * @param name   name of block to free
+ *
+ * @return pointer to named block descriptor on success
+ *         0 on failure
+ */
+
+const cvmx_bootmem_named_block_desc_t *hfa_bootmem_find_named_block(const char *name);
 
-#endif
+/**
+ * Create a named bootmem block by name.
+ *
+ * @param   size        size to be allocated in bytes
+ * @param   name        create named block with this name
+ * @param   alignment   alignment required.
+ *
+ * @return pointer to named block on success
+ *         NULL on failure
+ */
+
+void *hfa_bootmem_alloc_named( uint64_t size, uint64_t alignment, const char *name);
+
+/**
+ * Frees a named bootmem block by name.
+ *
+ * @param name   name of block to free
+ *
+ * @return 1 on success
+ *         0 on failure
+ */
+int  hfa_bootmem_free_named(const char *name);
+
+
+/**
+ * Flushes (and unlocks) the entire L2 cache.
+ * IMPORTANT: Must only be run by one core at a time due to use
+ * of L2C debug features.
+ */
+void hfa_l2c_flush(void);
+
+/**
+ * Given the chip processor ID from COP0, this function returns a
+ * string representing the chip model number. The string is of the
+ * form CNXXXXpX.X-FREQ-SUFFIX.
+ * - XXXX = The chip model number
+ * - X.X = Chip pass number
+ * - FREQ = Current frequency in Mhz
+ * - SUFFIX = NSP, EXP, SCP, SSP, or CP
+ *
+ * @param   chip_id     Chip ID
+ *
+ * @return Model string
+ */
+const char *hfa_octeon_model_get_string(uint32_t chip_id);
 
 #ifdef	__cplusplus
 /* *INDENT-OFF* */
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-hfa.c OCTEON-SDK/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-hfa.c
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-hfa.c	1970-01-01 05:30:00.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-hfa.c	2014-04-04 15:23:01.000000000 +0530
@@ -0,0 +1,276 @@
+/***********************license start***************
+ * Copyright (c) 2011  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Support library for CN6XXX and CN70/71XX hardware HFA engine.
+ *
+ */
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <linux/export.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-pko.h>
+#include <asm/octeon/cvmx-helper.h>
+#include <asm/octeon/cvmx-clock.h>
+#include <asm/octeon/cvmx-dfa-defs.h>
+#include <asm/octeon/cvmx-l2c.h>
+#include <asm/octeon/cvmx-hfa.h>
+#else
+#include "cvmx.h"
+#include "cvmx-fau.h"
+#include "cvmx-cmd-queue.h"
+#include "cvmx-helper.h"
+#include "cvmx-l2c.h"
+#include "cvmx-hfa.h"
+#ifdef CVMX_BUILD_FOR_LINUX_USER
+#include <sys/sysmips.h>
+#include <asm/sysmips.h>
+
+extern int errno;
+#endif
+#endif
+
+/**
+ * Initialize the DFA block
+ *
+ * @return Zero on success, negative on failure
+ */
+int cvmx_hfa_initialize(void)
+{
+	cvmx_dfa_difctl_t control;
+	cvmx_cmd_queue_result_t result;
+	void *initial_base_address;
+	int cmdsize;
+	int dfa_pool;
+	unsigned long int dfa_pool_size;
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+    dfa_pool = CVMX_FPA_DFA_POOL;
+    dfa_pool_size = CVMX_FPA_DFA_POOL_SIZE;
+#else 
+	dfa_pool = (int)cvmx_fpa_get_dfa_pool();
+	dfa_pool_size = cvmx_fpa_get_dfa_pool_block_size();
+#endif
+	cmdsize = ((dfa_pool_size - 8) / sizeof(cvmx_hfa_command_t)) * sizeof(cvmx_hfa_command_t);
+	result = cvmx_cmd_queue_initialize(CVMX_CMD_QUEUE_DFA, 0, 
+                                       dfa_pool, cmdsize + 8);
+    switch(result){
+        case CVMX_CMD_QUEUE_SUCCESS:
+            /*Do nothing*/
+        break;
+        case CVMX_CMD_QUEUE_ALREADY_SETUP:
+            return 0;
+        break;
+        default:
+            return (-1);
+        break;
+    }
+
+	control.u64 = 0;
+	control.cn31xx.dwbcnt = dfa_pool_size / 128;
+	control.s.pool = dfa_pool;
+	control.s.size = cmdsize / sizeof(cvmx_hfa_command_t);
+	CVMX_SYNCWS;
+	cvmx_write_csr(CVMX_DFA_DIFCTL, control.u64);
+	initial_base_address = cvmx_cmd_queue_buffer(CVMX_CMD_QUEUE_DFA);
+	CVMX_SYNCWS;
+	cvmx_write_csr(CVMX_DFA_DIFRDPTR, cvmx_ptr_to_phys(initial_base_address));
+	cvmx_read_csr(CVMX_DFA_DIFRDPTR);	/* Read to make sure setup is complete */
+	return 0;
+}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(cvmx_hfa_initialize);
+#endif
+
+/**
+ * Shutdown the DFA block. DFA must be idle when
+ * this function is called.
+ *
+ * @return Zero on success, negative on failure
+ */
+int cvmx_hfa_shutdown(void)
+{
+	if (cvmx_cmd_queue_length(CVMX_CMD_QUEUE_DFA)) {
+		cvmx_dprintf("ERROR: cvmx_hfa_shutdown: DFA not idle.\n");
+		return -1;
+	}
+	cvmx_cmd_queue_shutdown(CVMX_CMD_QUEUE_DFA);
+	return 0;
+}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(cvmx_hfa_shutdown);
+#endif
+
+/**
+ * Submit a command to the DFA block
+ *
+ * @param command DFA command to submit
+ *
+ * @return Zero on success, negative on failure
+ */
+int cvmx_hfa_submit(cvmx_hfa_command_t * command)
+{
+	cvmx_cmd_queue_result_t result = cvmx_cmd_queue_write(CVMX_CMD_QUEUE_DFA, 1, 4, command->u64);
+	if (result == CVMX_CMD_QUEUE_SUCCESS)
+		cvmx_write_csr(CVMX_DFA_DBELL, 1);
+	return result;
+}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(cvmx_hfa_submit);
+#endif
+
+void *hfa_bootmem_alloc(long unsigned int size, uint64_t alignment)
+{
+#ifndef CVMX_BOOTMEM_CORRUPT_CHECK
+    void *addr = NULL;
+    addr = cvmx_bootmem_alloc_range(size, alignment, 0, 0);
+#ifdef DEBUG
+    cvmx_dprintf("BOOTMEM ALLOC: ptr %p size %lu\n", addr, size); 
+#endif
+    return (addr);
+#else 
+    uint64_t alloc_size = size+(2*CHECK_SIZE);
+    void *addr = NULL;
+    addr = cvmx_bootmem_alloc_range(alloc_size, alignment, 0, 0);
+   
+    cvmx_dprintf("ALLOC: addr: %p size %lu\n", addr, size);
+    if(addr){ 
+        memset((uint8_t *)addr, 0xA, CHECK_SIZE);
+        memset((uint8_t *)addr+size+CHECK_SIZE, 0xB, CHECK_SIZE);
+        return ((uint8_t*)addr+CHECK_SIZE);
+    }
+    return addr;
+#endif
+}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_alloc);
+#endif
+
+int hfa_bootmem_free(void *ptr, long unsigned int size)
+{
+	uint64_t address;
+
+#ifdef CVMX_BOOTMEM_CORRUPT_CHECK
+    uint8_t buf1[CHECK_SIZE];
+    uint8_t buf2[CHECK_SIZE];
+   
+    memset(buf1, 0xA, CHECK_SIZE);
+    memset(buf2, 0xB, CHECK_SIZE);
+ 
+    if(memcmp((uint8_t *)(ptr-CHECK_SIZE), buf1, CHECK_SIZE)){
+        cvmx_dprintf("Buffer %p Accessed extra memory\n", 
+                                    ((uint8_t *)ptr-CHECK_SIZE));
+    }
+    if(memcmp((uint8_t *)ptr+size, buf2, CHECK_SIZE)){
+        cvmx_dprintf("Buffer(end) %p Accessed extra memory\n", 
+                                    ((uint8_t *)ptr-CHECK_SIZE));
+    }
+    memset((uint8_t *)(ptr-CHECK_SIZE), 0x0, CHECK_SIZE);
+    memset((uint8_t *)ptr+size, 0x0, CHECK_SIZE);
+    
+    size = (size+(2*CHECK_SIZE) + (CVMX_BOOTMEM_ALIGNMENT_SIZE -1)) & 
+                   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE -1);
+	address = cvmx_ptr_to_phys((uint8_t *)ptr-CHECK_SIZE);
+	return __cvmx_bootmem_phy_free(address, size, 0);
+#else
+#ifdef DEBUG
+    cvmx_dprintf("\t\t\t\tBOOTMEM FREE: ptr %p size %lu\n", ptr, size); 
+#endif    
+    /*Round size up of mult of minimum alignment bytes*/
+    size = (size + (CVMX_BOOTMEM_ALIGNMENT_SIZE -1)) & 
+                   ~(CVMX_BOOTMEM_ALIGNMENT_SIZE -1);
+	address = cvmx_ptr_to_phys(ptr);
+	return __cvmx_bootmem_phy_free(address, size, 0);
+#endif
+}
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_free);
+#endif
+
+const cvmx_bootmem_named_block_desc_t *
+hfa_bootmem_find_named_block(const char *name)
+{
+      return cvmx_bootmem_find_named_block(name);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_find_named_block);
+#endif
+
+void *hfa_bootmem_alloc_named(uint64_t size, uint64_t alignment, const char *name)
+{
+      return cvmx_bootmem_alloc_named(size, alignment, name);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_alloc_named);
+#endif
+
+int hfa_bootmem_free_named(const char *name)
+{
+      return cvmx_bootmem_free_named(name);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_bootmem_free_named);
+#endif
+
+void hfa_l2c_flush(void)
+{
+#ifdef CVMX_BUILD_FOR_LINUX_USER
+    sysmips(HFA_MIPS_CAVIUM_L2C_FLUSH);
+#else    
+        cvmx_l2c_flush();
+#endif
+}
+     
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_l2c_flush);
+#endif
+
+const char *hfa_octeon_model_get_string(uint32_t chip_id)
+{
+      return octeon_model_get_string(chip_id);
+}
+   
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+EXPORT_SYMBOL(hfa_octeon_model_get_string);
+#endif
+
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/cavium-octeon/executive/Makefile OCTEON-SDK/linux/kernel/linux/arch/mips/cavium-octeon/executive/Makefile
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/cavium-octeon/executive/Makefile	2014-04-04 15:14:12.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/cavium-octeon/executive/Makefile	2014-04-04 15:23:01.000000000 +0530
@@ -30,3 +30,5 @@ obj-$(CONFIG_CAVIUM_OCTEON_RAPIDIO) 	+= 
 obj-$(CONFIG_CAVIUM_OCTEON_NAND)	+= cvmx-bch.o cvmx-nand.o
 obj-$(CONFIG_CAVIUM_OCTEON_ERROR_TREE)	+= cvmx-error-trees.o
 obj-$(CONFIG_CAVIUM_GDB)		+= cvmx-debug.o cvmx-core.o cvmx-debug-handler.o cvmx-debug-uart.o cvmx-debug-remote.o
+
+obj-y += cvmx-hfa.o
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfa-defs.h OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfa-defs.h
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfa-defs.h	1970-01-01 05:30:00.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfa-defs.h	2014-04-04 15:23:01.000000000 +0530
@@ -0,0 +1,5700 @@
+/***********************license start***************
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+
+/**
+ * cvmx-dfa-defs.h
+ *
+ * Configuration and status register (CSR) type definitions for
+ * Octeon dfa.
+ *
+ * This file is auto generated. Do not edit.
+ *
+ * <hr>$Revision$<hr>
+ *
+ */
+#ifndef __CVMX_DFA_DEFS_H__
+#define __CVMX_DFA_DEFS_H__
+
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_BIST0 CVMX_DFA_BIST0_FUNC()
+static inline uint64_t CVMX_DFA_BIST0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_BIST0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370007F0ull);
+}
+#else
+#define CVMX_DFA_BIST0 (CVMX_ADD_IO_SEG(0x00011800370007F0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_BIST1 CVMX_DFA_BIST1_FUNC()
+static inline uint64_t CVMX_DFA_BIST1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_BIST1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370007F8ull);
+}
+#else
+#define CVMX_DFA_BIST1 (CVMX_ADD_IO_SEG(0x00011800370007F8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_BST0 CVMX_DFA_BST0_FUNC()
+static inline uint64_t CVMX_DFA_BST0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_BST0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800300007F0ull);
+}
+#else
+#define CVMX_DFA_BST0 (CVMX_ADD_IO_SEG(0x00011800300007F0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_BST1 CVMX_DFA_BST1_FUNC()
+static inline uint64_t CVMX_DFA_BST1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_BST1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800300007F8ull);
+}
+#else
+#define CVMX_DFA_BST1 (CVMX_ADD_IO_SEG(0x00011800300007F8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_CFG CVMX_DFA_CFG_FUNC()
+static inline uint64_t CVMX_DFA_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000000ull);
+}
+#else
+#define CVMX_DFA_CFG (CVMX_ADD_IO_SEG(0x0001180030000000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_CONFIG CVMX_DFA_CONFIG_FUNC()
+static inline uint64_t CVMX_DFA_CONFIG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_CONFIG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000000ull);
+}
+#else
+#define CVMX_DFA_CONFIG (CVMX_ADD_IO_SEG(0x0001180037000000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_CONTROL CVMX_DFA_CONTROL_FUNC()
+static inline uint64_t CVMX_DFA_CONTROL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_CONTROL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000020ull);
+}
+#else
+#define CVMX_DFA_CONTROL (CVMX_ADD_IO_SEG(0x0001180037000020ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DBELL CVMX_DFA_DBELL_FUNC()
+static inline uint64_t CVMX_DFA_DBELL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DBELL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001370000000000ull);
+}
+#else
+#define CVMX_DFA_DBELL (CVMX_ADD_IO_SEG(0x0001370000000000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_ADDR CVMX_DFA_DDR2_ADDR_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_ADDR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_ADDR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000210ull);
+}
+#else
+#define CVMX_DFA_DDR2_ADDR (CVMX_ADD_IO_SEG(0x0001180030000210ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_BUS CVMX_DFA_DDR2_BUS_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_BUS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_BUS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000080ull);
+}
+#else
+#define CVMX_DFA_DDR2_BUS (CVMX_ADD_IO_SEG(0x0001180030000080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_CFG CVMX_DFA_DDR2_CFG_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_CFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_CFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000208ull);
+}
+#else
+#define CVMX_DFA_DDR2_CFG (CVMX_ADD_IO_SEG(0x0001180030000208ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_COMP CVMX_DFA_DDR2_COMP_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_COMP_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_COMP not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000090ull);
+}
+#else
+#define CVMX_DFA_DDR2_COMP (CVMX_ADD_IO_SEG(0x0001180030000090ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_EMRS CVMX_DFA_DDR2_EMRS_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_EMRS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_EMRS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000268ull);
+}
+#else
+#define CVMX_DFA_DDR2_EMRS (CVMX_ADD_IO_SEG(0x0001180030000268ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_FCNT CVMX_DFA_DDR2_FCNT_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_FCNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_FCNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000078ull);
+}
+#else
+#define CVMX_DFA_DDR2_FCNT (CVMX_ADD_IO_SEG(0x0001180030000078ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_MRS CVMX_DFA_DDR2_MRS_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_MRS_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_MRS not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000260ull);
+}
+#else
+#define CVMX_DFA_DDR2_MRS (CVMX_ADD_IO_SEG(0x0001180030000260ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_OPT CVMX_DFA_DDR2_OPT_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_OPT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_OPT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000070ull);
+}
+#else
+#define CVMX_DFA_DDR2_OPT (CVMX_ADD_IO_SEG(0x0001180030000070ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_PLL CVMX_DFA_DDR2_PLL_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_PLL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_PLL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000088ull);
+}
+#else
+#define CVMX_DFA_DDR2_PLL (CVMX_ADD_IO_SEG(0x0001180030000088ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DDR2_TMG CVMX_DFA_DDR2_TMG_FUNC()
+static inline uint64_t CVMX_DFA_DDR2_TMG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_DDR2_TMG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000218ull);
+}
+#else
+#define CVMX_DFA_DDR2_TMG (CVMX_ADD_IO_SEG(0x0001180030000218ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DEBUG0 CVMX_DFA_DEBUG0_FUNC()
+static inline uint64_t CVMX_DFA_DEBUG0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DEBUG0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000040ull);
+}
+#else
+#define CVMX_DFA_DEBUG0 (CVMX_ADD_IO_SEG(0x0001180037000040ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DEBUG1 CVMX_DFA_DEBUG1_FUNC()
+static inline uint64_t CVMX_DFA_DEBUG1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DEBUG1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000048ull);
+}
+#else
+#define CVMX_DFA_DEBUG1 (CVMX_ADD_IO_SEG(0x0001180037000048ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DEBUG2 CVMX_DFA_DEBUG2_FUNC()
+static inline uint64_t CVMX_DFA_DEBUG2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DEBUG2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000050ull);
+}
+#else
+#define CVMX_DFA_DEBUG2 (CVMX_ADD_IO_SEG(0x0001180037000050ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DEBUG3 CVMX_DFA_DEBUG3_FUNC()
+static inline uint64_t CVMX_DFA_DEBUG3_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DEBUG3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000058ull);
+}
+#else
+#define CVMX_DFA_DEBUG3 (CVMX_ADD_IO_SEG(0x0001180037000058ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DIFCTL CVMX_DFA_DIFCTL_FUNC()
+static inline uint64_t CVMX_DFA_DIFCTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DIFCTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001370600000000ull);
+}
+#else
+#define CVMX_DFA_DIFCTL (CVMX_ADD_IO_SEG(0x0001370600000000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DIFRDPTR CVMX_DFA_DIFRDPTR_FUNC()
+static inline uint64_t CVMX_DFA_DIFRDPTR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DIFRDPTR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001370200000000ull);
+}
+#else
+#define CVMX_DFA_DIFRDPTR (CVMX_ADD_IO_SEG(0x0001370200000000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_DTCFADR CVMX_DFA_DTCFADR_FUNC()
+static inline uint64_t CVMX_DFA_DTCFADR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_DTCFADR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000060ull);
+}
+#else
+#define CVMX_DFA_DTCFADR (CVMX_ADD_IO_SEG(0x0001180037000060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_ECLKCFG CVMX_DFA_ECLKCFG_FUNC()
+static inline uint64_t CVMX_DFA_ECLKCFG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX)))
+		cvmx_warn("CVMX_DFA_ECLKCFG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000200ull);
+}
+#else
+#define CVMX_DFA_ECLKCFG (CVMX_ADD_IO_SEG(0x0001180030000200ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_ERR CVMX_DFA_ERR_FUNC()
+static inline uint64_t CVMX_DFA_ERR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_ERR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000028ull);
+}
+#else
+#define CVMX_DFA_ERR (CVMX_ADD_IO_SEG(0x0001180030000028ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_ERROR CVMX_DFA_ERROR_FUNC()
+static inline uint64_t CVMX_DFA_ERROR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_ERROR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000028ull);
+}
+#else
+#define CVMX_DFA_ERROR (CVMX_ADD_IO_SEG(0x0001180037000028ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_INTMSK CVMX_DFA_INTMSK_FUNC()
+static inline uint64_t CVMX_DFA_INTMSK_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX)))
+		cvmx_warn("CVMX_DFA_INTMSK not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000030ull);
+}
+#else
+#define CVMX_DFA_INTMSK (CVMX_ADD_IO_SEG(0x0001180037000030ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMCFG0 CVMX_DFA_MEMCFG0_FUNC()
+static inline uint64_t CVMX_DFA_MEMCFG0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_MEMCFG0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000008ull);
+}
+#else
+#define CVMX_DFA_MEMCFG0 (CVMX_ADD_IO_SEG(0x0001180030000008ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMCFG1 CVMX_DFA_MEMCFG1_FUNC()
+static inline uint64_t CVMX_DFA_MEMCFG1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_MEMCFG1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000010ull);
+}
+#else
+#define CVMX_DFA_MEMCFG1 (CVMX_ADD_IO_SEG(0x0001180030000010ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMCFG2 CVMX_DFA_MEMCFG2_FUNC()
+static inline uint64_t CVMX_DFA_MEMCFG2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_MEMCFG2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000060ull);
+}
+#else
+#define CVMX_DFA_MEMCFG2 (CVMX_ADD_IO_SEG(0x0001180030000060ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMFADR CVMX_DFA_MEMFADR_FUNC()
+static inline uint64_t CVMX_DFA_MEMFADR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_MEMFADR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000030ull);
+}
+#else
+#define CVMX_DFA_MEMFADR (CVMX_ADD_IO_SEG(0x0001180030000030ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMFCR CVMX_DFA_MEMFCR_FUNC()
+static inline uint64_t CVMX_DFA_MEMFCR_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_MEMFCR not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000038ull);
+}
+#else
+#define CVMX_DFA_MEMFCR (CVMX_ADD_IO_SEG(0x0001180030000038ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMHIDAT CVMX_DFA_MEMHIDAT_FUNC()
+static inline uint64_t CVMX_DFA_MEMHIDAT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN61XX) || OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX) || OCTEON_IS_MODEL(OCTEON_CN68XX) || OCTEON_IS_MODEL(OCTEON_CN70XX) || OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_MEMHIDAT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001370700000000ull);
+}
+#else
+#define CVMX_DFA_MEMHIDAT (CVMX_ADD_IO_SEG(0x0001370700000000ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_MEMRLD CVMX_DFA_MEMRLD_FUNC()
+static inline uint64_t CVMX_DFA_MEMRLD_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_MEMRLD not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000018ull);
+}
+#else
+#define CVMX_DFA_MEMRLD (CVMX_ADD_IO_SEG(0x0001180030000018ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_NCBCTL CVMX_DFA_NCBCTL_FUNC()
+static inline uint64_t CVMX_DFA_NCBCTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_NCBCTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000020ull);
+}
+#else
+#define CVMX_DFA_NCBCTL (CVMX_ADD_IO_SEG(0x0001180030000020ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC0_CNT CVMX_DFA_PFC0_CNT_FUNC()
+static inline uint64_t CVMX_DFA_PFC0_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC0_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000090ull);
+}
+#else
+#define CVMX_DFA_PFC0_CNT (CVMX_ADD_IO_SEG(0x0001180037000090ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC0_CTL CVMX_DFA_PFC0_CTL_FUNC()
+static inline uint64_t CVMX_DFA_PFC0_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC0_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000088ull);
+}
+#else
+#define CVMX_DFA_PFC0_CTL (CVMX_ADD_IO_SEG(0x0001180037000088ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC1_CNT CVMX_DFA_PFC1_CNT_FUNC()
+static inline uint64_t CVMX_DFA_PFC1_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC1_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370000A0ull);
+}
+#else
+#define CVMX_DFA_PFC1_CNT (CVMX_ADD_IO_SEG(0x00011800370000A0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC1_CTL CVMX_DFA_PFC1_CTL_FUNC()
+static inline uint64_t CVMX_DFA_PFC1_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC1_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000098ull);
+}
+#else
+#define CVMX_DFA_PFC1_CTL (CVMX_ADD_IO_SEG(0x0001180037000098ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC2_CNT CVMX_DFA_PFC2_CNT_FUNC()
+static inline uint64_t CVMX_DFA_PFC2_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC2_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370000B0ull);
+}
+#else
+#define CVMX_DFA_PFC2_CNT (CVMX_ADD_IO_SEG(0x00011800370000B0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC2_CTL CVMX_DFA_PFC2_CTL_FUNC()
+static inline uint64_t CVMX_DFA_PFC2_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC2_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370000A8ull);
+}
+#else
+#define CVMX_DFA_PFC2_CTL (CVMX_ADD_IO_SEG(0x00011800370000A8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC3_CNT CVMX_DFA_PFC3_CNT_FUNC()
+static inline uint64_t CVMX_DFA_PFC3_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC3_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370000C0ull);
+}
+#else
+#define CVMX_DFA_PFC3_CNT (CVMX_ADD_IO_SEG(0x00011800370000C0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC3_CTL CVMX_DFA_PFC3_CTL_FUNC()
+static inline uint64_t CVMX_DFA_PFC3_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC3_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800370000B8ull);
+}
+#else
+#define CVMX_DFA_PFC3_CTL (CVMX_ADD_IO_SEG(0x00011800370000B8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_PFC_GCTL CVMX_DFA_PFC_GCTL_FUNC()
+static inline uint64_t CVMX_DFA_PFC_GCTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN78XX)))
+		cvmx_warn("CVMX_DFA_PFC_GCTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180037000080ull);
+}
+#else
+#define CVMX_DFA_PFC_GCTL (CVMX_ADD_IO_SEG(0x0001180037000080ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_RODT_COMP_CTL CVMX_DFA_RODT_COMP_CTL_FUNC()
+static inline uint64_t CVMX_DFA_RODT_COMP_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_RODT_COMP_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000068ull);
+}
+#else
+#define CVMX_DFA_RODT_COMP_CTL (CVMX_ADD_IO_SEG(0x0001180030000068ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_SBD_DBG0 CVMX_DFA_SBD_DBG0_FUNC()
+static inline uint64_t CVMX_DFA_SBD_DBG0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_SBD_DBG0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000040ull);
+}
+#else
+#define CVMX_DFA_SBD_DBG0 (CVMX_ADD_IO_SEG(0x0001180030000040ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_SBD_DBG1 CVMX_DFA_SBD_DBG1_FUNC()
+static inline uint64_t CVMX_DFA_SBD_DBG1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_SBD_DBG1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000048ull);
+}
+#else
+#define CVMX_DFA_SBD_DBG1 (CVMX_ADD_IO_SEG(0x0001180030000048ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_SBD_DBG2 CVMX_DFA_SBD_DBG2_FUNC()
+static inline uint64_t CVMX_DFA_SBD_DBG2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_SBD_DBG2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000050ull);
+}
+#else
+#define CVMX_DFA_SBD_DBG2 (CVMX_ADD_IO_SEG(0x0001180030000050ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFA_SBD_DBG3 CVMX_DFA_SBD_DBG3_FUNC()
+static inline uint64_t CVMX_DFA_SBD_DBG3_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN58XX)))
+		cvmx_warn("CVMX_DFA_SBD_DBG3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x0001180030000058ull);
+}
+#else
+#define CVMX_DFA_SBD_DBG3 (CVMX_ADD_IO_SEG(0x0001180030000058ull))
+#endif
+
+/**
+ * cvmx_dfa_bist0
+ *
+ * This register shows the result of the BIST run on the HFA (per-DTC).
+ * 1 = BIST error, 0 = BIST passed, is in progress, or never ran.
+ */
+union cvmx_dfa_bist0 {
+	uint64_t u64;
+	struct cvmx_dfa_bist0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t gfb                          : 4;  /**< BIST results for GFB RAMs (per cluster) */
+	uint64_t stx3                         : 2;  /**< BIST Results for STX3 RAM(s) */
+	uint64_t stx2                         : 2;  /**< BIST results for STX2 RAMs */
+	uint64_t stx1                         : 2;  /**< BIST results for STX1 RAMs */
+	uint64_t stx                          : 2;  /**< BIST results for STX0 RAMs */
+	uint64_t dtx3                         : 2;  /**< BIST Results for DTX3 RAM(s) */
+	uint64_t dtx2                         : 2;  /**< BIST results for DTX2 RAMs */
+	uint64_t dtx1                         : 2;  /**< BIST results for DTX1 RAMs */
+	uint64_t dtx                          : 2;  /**< BIST results for DTX0 RAMs */
+	uint64_t rdf                          : 4;  /**< BIST results for RWB RAMs (per cluster) */
+	uint64_t pdb                          : 4;  /**< BIST results for PDB RAM(s) (per cluster) */
+#else
+	uint64_t pdb                          : 4;
+	uint64_t rdf                          : 4;
+	uint64_t dtx                          : 2;
+	uint64_t dtx1                         : 2;
+	uint64_t dtx2                         : 2;
+	uint64_t dtx3                         : 2;
+	uint64_t stx                          : 2;
+	uint64_t stx1                         : 2;
+	uint64_t stx2                         : 2;
+	uint64_t stx3                         : 2;
+	uint64_t gfb                          : 4;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} s;
+	struct cvmx_dfa_bist0_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t gfb                          : 1;  /**< Bist Results for GFB RAM(s) (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_18_23               : 6;
+	uint64_t stx                          : 2;  /**< Bist Results for STX0 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_10_15               : 6;
+	uint64_t dtx                          : 2;  /**< Bist Results for DTX0 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t rdf                          : 1;  /**< Bist Results for RWB RAM(s) (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t pdb                          : 1;  /**< Bist Results for PDB RAM(s) (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t pdb                          : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t rdf                          : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t dtx                          : 2;
+	uint64_t reserved_10_15               : 6;
+	uint64_t stx                          : 2;
+	uint64_t reserved_18_23               : 6;
+	uint64_t gfb                          : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_bist0_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t mwb                          : 1;  /**< Bist Results for MWB RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_25_27               : 3;
+	uint64_t gfb                          : 1;  /**< Bist Results for GFB RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_18_23               : 6;
+	uint64_t stx                          : 2;  /**< Bist Results for STX RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_10_15               : 6;
+	uint64_t dtx                          : 2;  /**< Bist Results for DTX RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t rdf                          : 1;  /**< Bist Results for RWB[3:0] RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_1_3                 : 3;
+	uint64_t pdb                          : 1;  /**< Bist Results for PDB RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t pdb                          : 1;
+	uint64_t reserved_1_3                 : 3;
+	uint64_t rdf                          : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t dtx                          : 2;
+	uint64_t reserved_10_15               : 6;
+	uint64_t stx                          : 2;
+	uint64_t reserved_18_23               : 6;
+	uint64_t gfb                          : 1;
+	uint64_t reserved_25_27               : 3;
+	uint64_t mwb                          : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} cn63xx;
+	struct cvmx_dfa_bist0_cn63xx          cn63xxp1;
+	struct cvmx_dfa_bist0_cn63xx          cn66xx;
+	struct cvmx_dfa_bist0_cn68xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t mrp                          : 2;  /**< Bist Results for MRP RAM(s) (per-DLC)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_27_27               : 1;
+	uint64_t gfb                          : 3;  /**< Bist Results for GFB RAM(s) (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_22_23               : 2;
+	uint64_t stx2                         : 2;  /**< Bist Results for STX2 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t stx1                         : 2;  /**< Bist Results for STX1 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t stx                          : 2;  /**< Bist Results for STX0 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_14_15               : 2;
+	uint64_t dtx2                         : 2;  /**< Bist Results for DTX2 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dtx1                         : 2;  /**< Bist Results for DTX1 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dtx                          : 2;  /**< Bist Results for DTX0 RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_7_7                 : 1;
+	uint64_t rdf                          : 3;  /**< Bist Results for RWB RAM(s) (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_3_3                 : 1;
+	uint64_t pdb                          : 3;  /**< Bist Results for PDB RAM(s) (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t pdb                          : 3;
+	uint64_t reserved_3_3                 : 1;
+	uint64_t rdf                          : 3;
+	uint64_t reserved_7_7                 : 1;
+	uint64_t dtx                          : 2;
+	uint64_t dtx1                         : 2;
+	uint64_t dtx2                         : 2;
+	uint64_t reserved_14_15               : 2;
+	uint64_t stx                          : 2;
+	uint64_t stx1                         : 2;
+	uint64_t stx2                         : 2;
+	uint64_t reserved_22_23               : 2;
+	uint64_t gfb                          : 3;
+	uint64_t reserved_27_27               : 1;
+	uint64_t mrp                          : 2;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} cn68xx;
+	struct cvmx_dfa_bist0_cn68xx          cn68xxp1;
+	struct cvmx_dfa_bist0_cn61xx          cn70xx;
+	struct cvmx_dfa_bist0_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_30_63               : 34;
+	uint64_t mrp                          : 2;  /**< BIST results for MRP RAM(s) (per-DLC) */
+	uint64_t gfb                          : 4;  /**< BIST results for GFB RAMs (per cluster) */
+	uint64_t stx3                         : 2;  /**< BIST Results for STX3 RAM(s) */
+	uint64_t stx2                         : 2;  /**< BIST results for STX2 RAMs */
+	uint64_t stx1                         : 2;  /**< BIST results for STX1 RAMs */
+	uint64_t stx                          : 2;  /**< BIST results for STX0 RAMs */
+	uint64_t dtx3                         : 2;  /**< BIST Results for DTX3 RAM(s) */
+	uint64_t dtx2                         : 2;  /**< BIST results for DTX2 RAMs */
+	uint64_t dtx1                         : 2;  /**< BIST results for DTX1 RAMs */
+	uint64_t dtx                          : 2;  /**< BIST results for DTX0 RAMs */
+	uint64_t rdf                          : 4;  /**< BIST results for RWB RAMs (per cluster) */
+	uint64_t pdb                          : 4;  /**< BIST results for PDB RAM(s) (per cluster) */
+#else
+	uint64_t pdb                          : 4;
+	uint64_t rdf                          : 4;
+	uint64_t dtx                          : 2;
+	uint64_t dtx1                         : 2;
+	uint64_t dtx2                         : 2;
+	uint64_t dtx3                         : 2;
+	uint64_t stx                          : 2;
+	uint64_t stx1                         : 2;
+	uint64_t stx2                         : 2;
+	uint64_t stx3                         : 2;
+	uint64_t gfb                          : 4;
+	uint64_t mrp                          : 2;
+	uint64_t reserved_30_63               : 34;
+#endif
+	} cn78xx;
+};
+typedef union cvmx_dfa_bist0 cvmx_dfa_bist0_t;
+
+/**
+ * cvmx_dfa_bist1
+ *
+ * This register shows the result of the BIST run on the HFA (globals).
+ * 1 = BIST error, 0 = BIST passed, is in progress, or never ran.
+ */
+union cvmx_dfa_bist1 {
+	uint64_t u64;
+	struct cvmx_dfa_bist1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t dc3ram3                      : 1;  /**< Cluster 3 BIST results for RAM3 RAM */
+	uint64_t dc3ram2                      : 1;  /**< Cluster 3 BIST results for RAM2 RAM */
+	uint64_t dc3ram1                      : 1;  /**< Cluster 3 BIST results for RAM1 RAM */
+	uint64_t dlc1ram                      : 1;  /**< DLC1 BIST results */
+	uint64_t dlc0ram                      : 1;  /**< DLC0 BIST results */
+	uint64_t dc2ram3                      : 1;  /**< Cluster 2 BIST results for RAM3 RAM */
+	uint64_t dc2ram2                      : 1;  /**< Cluster 2 BIST results for RAM2 RAM */
+	uint64_t dc2ram1                      : 1;  /**< Cluster 2 BIST results for RAM1 RAM */
+	uint64_t dc1ram3                      : 1;  /**< Cluster 1 BIST results for RAM3 RAM */
+	uint64_t dc1ram2                      : 1;  /**< Cluster 1 BIST results for RAM2 RAM */
+	uint64_t dc1ram1                      : 1;  /**< Cluster 1 BIST results for RAM1 RAM */
+	uint64_t ram3                         : 1;  /**< Cluster 0 BIST results for RAM3 RAM */
+	uint64_t ram2                         : 1;  /**< Cluster 0 BIST results for RAM2 RAM */
+	uint64_t ram1                         : 1;  /**< Cluster 0 BIST results for RAM1 RAM */
+	uint64_t crq                          : 1;  /**< BIST results for CRQ RAM */
+	uint64_t gutv                         : 1;  /**< BIST results for GUTV RAM */
+	uint64_t gutp                         : 4;  /**< BIST results for GUTP RAMs (per-cluster) */
+	uint64_t ncd                          : 1;  /**< BIST results for NCD RAM */
+	uint64_t gif                          : 1;  /**< BIST results for GIF RAM */
+	uint64_t gib                          : 1;  /**< BIST results for GIB RAM */
+	uint64_t gfu                          : 1;  /**< BIST results for GFU RAM */
+#else
+	uint64_t gfu                          : 1;
+	uint64_t gib                          : 1;
+	uint64_t gif                          : 1;
+	uint64_t ncd                          : 1;
+	uint64_t gutp                         : 4;
+	uint64_t gutv                         : 1;
+	uint64_t crq                          : 1;
+	uint64_t ram1                         : 1;
+	uint64_t ram2                         : 1;
+	uint64_t ram3                         : 1;
+	uint64_t dc1ram1                      : 1;
+	uint64_t dc1ram2                      : 1;
+	uint64_t dc1ram3                      : 1;
+	uint64_t dc2ram1                      : 1;
+	uint64_t dc2ram2                      : 1;
+	uint64_t dc2ram3                      : 1;
+	uint64_t dlc0ram                      : 1;
+	uint64_t dlc1ram                      : 1;
+	uint64_t dc3ram1                      : 1;
+	uint64_t dc3ram2                      : 1;
+	uint64_t dc3ram3                      : 1;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dfa_bist1_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_20_63               : 44;
+	uint64_t dlc0ram                      : 1;  /**< DLC0 Bist Results
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_13_18               : 6;
+	uint64_t ram3                         : 1;  /**< Cluster#0 Bist Results for RAM3 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram2                         : 1;  /**< Cluster#0 Bist Results for RAM2 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram1                         : 1;  /**< Cluster#0 Bist Results for RAM1 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gutv                         : 1;  /**< Bist Results for GUTV RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t gutp                         : 1;  /**< Bist Results for GUTP RAMs
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ncd                          : 1;  /**< Bist Results for NCD RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gif                          : 1;  /**< Bist Results for GIF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gib                          : 1;  /**< Bist Results for GIB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t gfu                          : 1;
+	uint64_t gib                          : 1;
+	uint64_t gif                          : 1;
+	uint64_t ncd                          : 1;
+	uint64_t gutp                         : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t gutv                         : 1;
+	uint64_t crq                          : 1;
+	uint64_t ram1                         : 1;
+	uint64_t ram2                         : 1;
+	uint64_t ram3                         : 1;
+	uint64_t reserved_13_18               : 6;
+	uint64_t dlc0ram                      : 1;
+	uint64_t reserved_20_63               : 44;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_bist1_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_13_63               : 51;
+	uint64_t ram3                         : 1;  /**< Bist Results for RAM3 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram2                         : 1;  /**< Bist Results for RAM2 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram1                         : 1;  /**< Bist Results for RAM1 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gutv                         : 1;  /**< Bist Results for GUTV RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t gutp                         : 1;  /**< Bist Results for NCD RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ncd                          : 1;  /**< Bist Results for NCD RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gif                          : 1;  /**< Bist Results for GIF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gib                          : 1;  /**< Bist Results for GIB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t gfu                          : 1;
+	uint64_t gib                          : 1;
+	uint64_t gif                          : 1;
+	uint64_t ncd                          : 1;
+	uint64_t gutp                         : 1;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t gutv                         : 1;
+	uint64_t crq                          : 1;
+	uint64_t ram1                         : 1;
+	uint64_t ram2                         : 1;
+	uint64_t ram3                         : 1;
+	uint64_t reserved_13_63               : 51;
+#endif
+	} cn63xx;
+	struct cvmx_dfa_bist1_cn63xx          cn63xxp1;
+	struct cvmx_dfa_bist1_cn63xx          cn66xx;
+	struct cvmx_dfa_bist1_cn68xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_21_63               : 43;
+	uint64_t dlc1ram                      : 1;  /**< DLC1 Bist Results
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dlc0ram                      : 1;  /**< DLC0 Bist Results
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dc2ram3                      : 1;  /**< Cluster#2 Bist Results for RAM3 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dc2ram2                      : 1;  /**< Cluster#2 Bist Results for RAM2 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dc2ram1                      : 1;  /**< Cluster#2 Bist Results for RAM1 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dc1ram3                      : 1;  /**< Cluster#1 Bist Results for RAM3 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dc1ram2                      : 1;  /**< Cluster#1 Bist Results for RAM2 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t dc1ram1                      : 1;  /**< Cluster#1 Bist Results for RAM1 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram3                         : 1;  /**< Cluster#0 Bist Results for RAM3 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram2                         : 1;  /**< Cluster#0 Bist Results for RAM2 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ram1                         : 1;  /**< Cluster#0 Bist Results for RAM1 RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gutv                         : 1;  /**< Bist Results for GUTV RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_7_7                 : 1;
+	uint64_t gutp                         : 3;  /**< Bist Results for GUTP RAMs (per-cluster)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ncd                          : 1;  /**< Bist Results for NCD RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gif                          : 1;  /**< Bist Results for GIF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gib                          : 1;  /**< Bist Results for GIB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t gfu                          : 1;
+	uint64_t gib                          : 1;
+	uint64_t gif                          : 1;
+	uint64_t ncd                          : 1;
+	uint64_t gutp                         : 3;
+	uint64_t reserved_7_7                 : 1;
+	uint64_t gutv                         : 1;
+	uint64_t crq                          : 1;
+	uint64_t ram1                         : 1;
+	uint64_t ram2                         : 1;
+	uint64_t ram3                         : 1;
+	uint64_t dc1ram1                      : 1;
+	uint64_t dc1ram2                      : 1;
+	uint64_t dc1ram3                      : 1;
+	uint64_t dc2ram1                      : 1;
+	uint64_t dc2ram2                      : 1;
+	uint64_t dc2ram3                      : 1;
+	uint64_t dlc0ram                      : 1;
+	uint64_t dlc1ram                      : 1;
+	uint64_t reserved_21_63               : 43;
+#endif
+	} cn68xx;
+	struct cvmx_dfa_bist1_cn68xx          cn68xxp1;
+	struct cvmx_dfa_bist1_cn61xx          cn70xx;
+	struct cvmx_dfa_bist1_s               cn78xx;
+};
+typedef union cvmx_dfa_bist1 cvmx_dfa_bist1_t;
+
+/**
+ * cvmx_dfa_bst0
+ *
+ * DFA_BST0 = DFA Bist Status
+ *
+ * Description:
+ */
+union cvmx_dfa_bst0 {
+	uint64_t u64;
+	struct cvmx_dfa_bst0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t rdf                          : 16; /**< Bist Results for RDF[3:0] RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t pdf                          : 16; /**< Bist Results for PDF[3:0] RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t pdf                          : 16;
+	uint64_t rdf                          : 16;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_dfa_bst0_s                cn31xx;
+	struct cvmx_dfa_bst0_s                cn38xx;
+	struct cvmx_dfa_bst0_s                cn38xxp2;
+	struct cvmx_dfa_bst0_cn58xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_20_63               : 44;
+	uint64_t rdf                          : 4;  /**< Bist Results for RDF[3:0] RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_4_15                : 12;
+	uint64_t pdf                          : 4;  /**< Bist Results for PDF[3:0] RAM(s)
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t pdf                          : 4;
+	uint64_t reserved_4_15                : 12;
+	uint64_t rdf                          : 4;
+	uint64_t reserved_20_63               : 44;
+#endif
+	} cn58xx;
+	struct cvmx_dfa_bst0_cn58xx           cn58xxp1;
+};
+typedef union cvmx_dfa_bst0 cvmx_dfa_bst0_t;
+
+/**
+ * cvmx_dfa_bst1
+ *
+ * DFA_BST1 = DFA Bist Status
+ *
+ * Description:
+ */
+union cvmx_dfa_bst1 {
+	uint64_t u64;
+	struct cvmx_dfa_bst1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_23_63               : 41;
+	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ifu                          : 1;  /**< Bist Results for IFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t drf                          : 1;  /**< Bist Results for DRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t crf                          : 1;  /**< Bist Results for CRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p0_bwb                       : 1;  /**< Bist Results for P0_BWB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p1_bwb                       : 1;  /**< Bist Results for P1_BWB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p0_brf                       : 8;  /**< Bist Results for P0_BRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p1_brf                       : 8;  /**< Bist Results for P1_BRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t p1_brf                       : 8;
+	uint64_t p0_brf                       : 8;
+	uint64_t p1_bwb                       : 1;
+	uint64_t p0_bwb                       : 1;
+	uint64_t crf                          : 1;
+	uint64_t drf                          : 1;
+	uint64_t gfu                          : 1;
+	uint64_t ifu                          : 1;
+	uint64_t crq                          : 1;
+	uint64_t reserved_23_63               : 41;
+#endif
+	} s;
+	struct cvmx_dfa_bst1_cn31xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_23_63               : 41;
+	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ifu                          : 1;  /**< Bist Results for IFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t drf                          : 1;  /**< Bist Results for DRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t crf                          : 1;  /**< Bist Results for CRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_0_17                : 18;
+#else
+	uint64_t reserved_0_17                : 18;
+	uint64_t crf                          : 1;
+	uint64_t drf                          : 1;
+	uint64_t gfu                          : 1;
+	uint64_t ifu                          : 1;
+	uint64_t crq                          : 1;
+	uint64_t reserved_23_63               : 41;
+#endif
+	} cn31xx;
+	struct cvmx_dfa_bst1_s                cn38xx;
+	struct cvmx_dfa_bst1_s                cn38xxp2;
+	struct cvmx_dfa_bst1_cn58xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_23_63               : 41;
+	uint64_t crq                          : 1;  /**< Bist Results for CRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t ifu                          : 1;  /**< Bist Results for IFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t gfu                          : 1;  /**< Bist Results for GFU RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t reserved_19_19               : 1;
+	uint64_t crf                          : 1;  /**< Bist Results for CRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p0_bwb                       : 1;  /**< Bist Results for P0_BWB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p1_bwb                       : 1;  /**< Bist Results for P1_BWB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p0_brf                       : 8;  /**< Bist Results for P0_BRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t p1_brf                       : 8;  /**< Bist Results for P1_BRF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t p1_brf                       : 8;
+	uint64_t p0_brf                       : 8;
+	uint64_t p1_bwb                       : 1;
+	uint64_t p0_bwb                       : 1;
+	uint64_t crf                          : 1;
+	uint64_t reserved_19_19               : 1;
+	uint64_t gfu                          : 1;
+	uint64_t ifu                          : 1;
+	uint64_t crq                          : 1;
+	uint64_t reserved_23_63               : 41;
+#endif
+	} cn58xx;
+	struct cvmx_dfa_bst1_cn58xx           cn58xxp1;
+};
+typedef union cvmx_dfa_bst1 cvmx_dfa_bst1_t;
+
+/**
+ * cvmx_dfa_cfg
+ *
+ * Specify the RSL base addresses for the block
+ *
+ *                  DFA_CFG = DFA Configuration
+ *
+ * Description:
+ */
+union cvmx_dfa_cfg {
+	uint64_t u64;
+	struct cvmx_dfa_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t nrpl_ena                     : 1;  /**< When set, allows the per-node replication feature to be
+                                                         enabled.
+                                                         In 36-bit mode: The IWORD0[31:30]=SNREPL field AND
+                                                         bits [21:20] of the Next Node ptr are used in generating
+                                                         the next node address (see OCTEON HRM - DFA Chapter for
+                                                         psuedo-code of DTE next node address generation).
+                                                         NOTE: When NRPL_ENA=1 and IWORD0[TY]=1(36b mode),
+                                                         (regardless of IWORD0[NRPLEN]), the Resultant Word1+
+                                                         [[47:44],[23:20]] = Next Node's [27:20] bits. This allows
+                                                         SW to use the RESERVED bits of the final node for SW
+                                                         caching. Also, if required, SW will use [22:21]=Node
+                                                         Replication to re-start the same graph walk(if graph
+                                                         walk prematurely terminated (ie: DATA_GONE).
+                                                         In 18-bit mode: The IWORD0[31:30]=SNREPL field AND
+                                                         bit [16:14] of the Next Node ptr are used in generating
+                                                         the next node address (see OCTEON HRM - DFA Chapter for
+                                                         psuedo-code of DTE next node address generation).
+                                                         If (IWORD0[NREPLEN]=1 and DFA_CFG[NRPL_ENA]=1) [
+                                                            If next node ptr[16] is set [
+                                                              next node ptr[15:14] indicates the next node repl
+                                                              next node ptr[13:0]  indicates the position of the
+                                                                 node relative to the first normal node (i.e.
+                                                                 IWORD3[Msize] must be added to get the final node)
+                                                            ]
+                                                            else If next node ptr[16] is not set [
+                                                              next node ptr[15:0] indicates the next node id
+                                                              next node repl = 0
+                                                            ]
+                                                         ]
+                                                         NOTE: For 18b node replication, MAX node space=64KB(2^16)
+                                                         is used in detecting terminal node space(see HRM for full
+                                                         description).
+                                                         NOTE: The DFA graphs MUST BE built/written to DFA LLM memory
+                                                         aware of the "per-node" replication. */
+	uint64_t nxor_ena                     : 1;  /**< When set, allows the DTE Instruction IWORD0[NXOREN]
+                                                         to be used to enable/disable the per-node address 'scramble'
+                                                         of the LLM address to lessen the effects of bank conflicts.
+                                                         If IWORD0[NXOREN] is also set, then:
+                                                         In 36-bit mode: The node_Id[7:0] 8-bit value is XORed
+                                                         against the LLM address addr[9:2].
+                                                         In 18-bit mode: The node_id[6:0] 7-bit value is XORed
+                                                         against the LLM address addr[8:2]. (note: we don't address
+                                                         scramble outside the mode's node space).
+                                                         NOTE: The DFA graphs MUST BE built/written to DFA LLM memory
+                                                         aware of the "per-node" address scramble.
+                                                         NOTE: The address 'scramble' ocurs for BOTH DFA LLM graph
+                                                         read/write operations. */
+	uint64_t gxor_ena                     : 1;  /**< When set, the DTE Instruction IWORD0[GXOR]
+                                                         field is used to 'scramble' the LLM address
+                                                         to lessen the effects of bank conflicts.
+                                                         In 36-bit mode: The GXOR[7:0] 8-bit value is XORed
+                                                         against the LLM address addr[9:2].
+                                                         In 18-bit mode: GXOR[6:0] 7-bit value is XORed against
+                                                         the LLM address addr[8:2]. (note: we don't address
+                                                         scramble outside the mode's node space)
+                                                         NOTE: The DFA graphs MUST BE built/written to DFA LLM memory
+                                                         aware of the "per-graph" address scramble.
+                                                         NOTE: The address 'scramble' ocurs for BOTH DFA LLM graph
+                                                         read/write operations. */
+	uint64_t sarb                         : 1;  /**< DFA Source Arbiter Mode
+                                                         Selects the arbitration mode used to select DFA
+                                                         requests issued from either CP2 or the DTE (NCB-CSR
+                                                         or DFA HW engine).
+                                                            - 0: Fixed Priority [Highest=CP2, Lowest=DTE]
+                                                            - 1: Round-Robin
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t sarb                         : 1;
+	uint64_t gxor_ena                     : 1;
+	uint64_t nxor_ena                     : 1;
+	uint64_t nrpl_ena                     : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_dfa_cfg_s                 cn38xx;
+	struct cvmx_dfa_cfg_cn38xxp2 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_1_63                : 63;
+	uint64_t sarb                         : 1;  /**< DFA Source Arbiter Mode
+                                                         Selects the arbitration mode used to select DFA
+                                                         requests issued from either CP2 or the DTE (NCB-CSR
+                                                         or DFA HW engine).
+                                                            - 0: Fixed Priority [Highest=CP2, Lowest=DTE]
+                                                            - 1: Round-Robin
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t sarb                         : 1;
+	uint64_t reserved_1_63                : 63;
+#endif
+	} cn38xxp2;
+	struct cvmx_dfa_cfg_s                 cn58xx;
+	struct cvmx_dfa_cfg_s                 cn58xxp1;
+};
+typedef union cvmx_dfa_cfg cvmx_dfa_cfg_t;
+
+/**
+ * cvmx_dfa_config
+ *
+ * Specify the RSL base addresses for the block
+ * DFA_CONFIG = DFA Configuration Register
+ * Description:
+ */
+union cvmx_dfa_config {
+	uint64_t u64;
+	struct cvmx_dfa_config_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_11_63               : 53;
+	uint64_t dlcclear_bist                : 1;  /**< When DLCSTART_BIST is written 0->1, if DLCCLEAR_BIST=1, all previous DLC BIST state is
+                                                         cleared. Note the following:
+                                                         DLCCLEAR_BIST must be written to 1 before DLCSTART_BIST is written to 1 using a separate
+                                                         CSR write.
+                                                         DLCCLEAR_BIST must not be changed after writing DLCSTART_BIST 0->1 until the BIST
+                                                         operation completes. */
+	uint64_t dlcstart_bist                : 1;  /**< When software writes DLCSTART_BIST=0->1, a BIST is executed for the DLC sub-block RAMs
+                                                         which contains DCLK domain asynchronous RAMs. Note the following:
+                                                         This bit should only be written after DCLK has been enabled by software and is stable.
+                                                         (See LMC initialization routine for details on how to enable the DDR3 memory (DCLK)--which
+                                                         requires LMC PLL init, clock divider, and proper DLL initialization sequence.) */
+	uint64_t repl_ena                     : 1;  /**< Replication mode enable.
+                                                         This is used by the memory controller to support graph data in multiple ports (or port
+                                                         sets), so that the least full port can be selected to minimize latency effects.
+                                                         Software Note: Using this mode requires the HFA software compiler and HFA driver to be
+                                                         aware of the address replication changes. This involves changes to the MLOAD/GWALK HFA
+                                                         instruction format (See IWORD2.SREPL), as well as changes to node arc and metadata
+                                                         definitions which support an additional REPL field. When clear, replication mode is
+                                                         disabled, and HFA interprets HFA instructions and node-arc formats which do not have
+                                                         address replication information. */
+	uint64_t clmskcrip                    : 4;  /**< Cluster cripple mask. A 1 in each bit of the mask represents which HTE cluster to cripple.
+                                                         CN78XX has four clusters (therefore CLMSKCRIP<3:0> are used.)
+                                                         The MIO_FUS_DFA_CLMASK_CRIPPLE[3:0] fuse bits are forced into this register at reset. Any
+                                                         fuse bits that contain 1 are disallowed during a write and are always read as 1. */
+	uint64_t cldtecrip                    : 3;  /**< Encoding that represents the number of HTEs to cripple for each cluster. Typically
+                                                         DTE_CLCRIP = 0, which enables all HTEs within each cluster. However, when the HFA
+                                                         performance counters are used, software may want to limit the number of HTEs per cluster
+                                                         available, as there are only four parallel performance counters.
+                                                         DTE_CLCRIP No. of HTEs crippled (per cluster)
+                                                         0 0 HTE[15:0]:ON
+                                                         1 1/2 HTE[15:8]:OFF  /HTE[7:0]:ON
+                                                         2 1/4 HTE[15:12]:OFF /HTE[11:0]:ON
+                                                         3 3/4 HTE[15:4]:OFF  /HTE[3:0]:ON
+                                                         4 1/8 HTE[15:14]:OFF /HTE[13:0]:ON
+                                                         5 5/8 HTE[15:6]:OFF  /HTE[5:0]:ON
+                                                         6 3/8 HTE[15:10]:OFF /HTE[9:0]:ON
+                                                         7 7/8 HTE[15:2]:OFF  /HTE[1:0]:ON
+                                                         Higher numbered HTEs are crippled first. For instance, on CN78XX (with 16 HTEs/cluster),
+                                                         if DTE_CLCRIP = 1 (1/4), then [15:8] within the cluster are crippled and only HTE numbers
+                                                         [7:0] are available.
+                                                         The MIO_FUS_DFA_NUMDTE_CRIPPLE[3:0] fuse bits are forced into this register at reset. Any
+                                                         fuse bits that contain 1 are disallowed during a write and are always read as 1. */
+	uint64_t dteclkdis                    : 1;  /**< HFA clock disable source. When set, the HFA clocks for HTE (thread engine) operations are
+                                                         disabled to conserve overall chip clocking power when the HFA function is not used.
+                                                         When set, software must never issue IOI-direct CSR operations to the HFA (will result in
+                                                         IOI timeout errors).
+                                                         This should only be written to a different value during power-on software initialization.
+                                                         The MIO_FUS_DFA_DTE_DISABLE fuse bit is forced into this register at reset. If the fuse
+                                                         bit contains 1, write operations to DTECLKDIS are disallowed and are always read as 1. */
+#else
+	uint64_t dteclkdis                    : 1;
+	uint64_t cldtecrip                    : 3;
+	uint64_t clmskcrip                    : 4;
+	uint64_t repl_ena                     : 1;
+	uint64_t dlcstart_bist                : 1;
+	uint64_t dlcclear_bist                : 1;
+	uint64_t reserved_11_63               : 53;
+#endif
+	} s;
+	struct cvmx_dfa_config_s              cn61xx;
+	struct cvmx_dfa_config_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t repl_ena                     : 1;  /**< Replication Mode Enable
+                                                         *** o63-P2 NEW ***
+                                                         When set, enables replication mode performance enhancement
+                                                         feature. This enables the DFA to communicate address
+                                                         replication information during memory references to the DFM
+                                                         (memory controller). This in turn is used by the DFM to support
+                                                         graph data in multiple banks (or bank sets), so that the least
+                                                         full bank can be selected to minimize the effects of DDR3 bank
+                                                         conflicts (ie: tRC=row cycle time).
+                                                         SWNOTE: Using this mode requires the DFA SW compiler and DFA
+                                                         driver to be aware of the o63-P2 address replication changes.
+                                                         This involves changes to the MLOAD/GWALK DFA instruction format
+                                                         (see: IWORD2.SREPL), as well as changes to node arc and metadata
+                                                         definitions which now support an additional REPL field.
+                                                         When clear, replication mode is disabled, and DFA will interpret
+                                                         o63-P1 DFA instructions and node-arc formats which DO NOT have
+                                                         address replication information. */
+	uint64_t clmskcrip                    : 4;  /**< Cluster Cripple Mask
+                                                         A one in each bit of the mask represents which DTE cluster to
+                                                         cripple.
+                                                         NOTE: o63 has only a single Cluster (therefore CLMSKCRIP[0]
+                                                         is the only bit used.
+                                                         o2 has 4 clusters, where all CLMSKCRIP mask bits are used.
+                                                         SWNOTE: The MIO_FUS___DFA_CLMASK_CRIPPLE[3:0] fuse bits will
+                                                         be forced into this register at reset. Any fuse bits that
+                                                         contain '1' will be disallowed during a write and will always
+                                                         be read as '1'. */
+	uint64_t cldtecrip                    : 3;  /**< Encoding which represents \#of DTEs to cripple for each
+                                                         cluster. Typically DTE_CLCRIP=0 which enables all DTEs
+                                                         within each cluster. However, when the DFA performance
+                                                         counters are used, SW may want to limit the \#of DTEs
+                                                         per cluster available, as there are only 4 parallel
+                                                         performance counters.
+                                                            DTE_CLCRIP | \#DTEs crippled(per cluster)
+                                                         ------------+-----------------------------
+                                                                0    |  0      DTE[15:0]:ON
+                                                                1    |  1/2    DTE[15:8]:OFF  /DTE[7:0]:ON
+                                                                2    |  1/4    DTE[15:12]:OFF /DTE[11:0]:ON
+                                                                3    |  3/4    DTE[15:4]:OFF  /DTE[3:0]:ON
+                                                                4    |  1/8    DTE[15:14]:OFF /DTE[13:0]:ON
+                                                                5    |  5/8    DTE[15:6]:OFF  /DTE[5:0]:ON
+                                                                6    |  3/8    DTE[15:10]:OFF /DTE[9:0]:ON
+                                                                7    |  7/8    DTE[15:2]:OFF  /DTE[1:0]:ON
+                                                         NOTE: Higher numbered DTEs are crippled first. For instance,
+                                                         on o63 (with 16 DTEs/cluster), if DTE_CLCRIP=1(1/2), then
+                                                         DTE#s [15:8] within the cluster are crippled and only
+                                                         DTE#s [7:0] are available.
+                                                         IMPNOTE: The encodings are done in such a way as to later
+                                                         be used with fuses (for future o2 revisions which will disable
+                                                         some \#of DTEs). Blowing a fuse has the effect that there will
+                                                         always be fewer DTEs available. [ie: we never want a customer
+                                                         to blow additional fuses to get more DTEs].
+                                                         SWNOTE: The MIO_FUS___DFA_NUMDTE_CRIPPLE[2:0] fuse bits will
+                                                         be forced into this register at reset. Any fuse bits that
+                                                         contain '1' will be disallowed during a write and will always
+                                                         be read as '1'. */
+	uint64_t dteclkdis                    : 1;  /**< DFA Clock Disable Source
+                                                         When SET, the DFA clocks for DTE(thread engine)
+                                                         operation are disabled (to conserve overall chip clocking
+                                                         power when the DFA function is not used).
+                                                         NOTE: When SET, SW MUST NEVER issue NCB-Direct CSR
+                                                         operations to the DFA (will result in NCB Bus Timeout
+                                                         errors).
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         SWNOTE: The MIO_FUS___DFA_DTE_DISABLE fuse bit will
+                                                         be forced into this register at reset. If the fuse bit
+                                                         contains '1', writes to DTECLKDIS are disallowed and
+                                                         will always be read as '1'. */
+#else
+	uint64_t dteclkdis                    : 1;
+	uint64_t cldtecrip                    : 3;
+	uint64_t clmskcrip                    : 4;
+	uint64_t repl_ena                     : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} cn63xx;
+	struct cvmx_dfa_config_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_8_63                : 56;
+	uint64_t clmskcrip                    : 4;  /**< Cluster Cripple Mask
+                                                         A one in each bit of the mask represents which DTE cluster to
+                                                         cripple.
+                                                         NOTE: o63 has only a single Cluster (therefore CLMSKCRIP[0]
+                                                         is the only bit used.
+                                                         o2 has 4 clusters, where all CLMSKCRIP mask bits are used.
+                                                         SWNOTE: The MIO_FUS___DFA_CLMASK_CRIPPLE[3:0] fuse bits will
+                                                         be forced into this register at reset. Any fuse bits that
+                                                         contain '1' will be disallowed during a write and will always
+                                                         be read as '1'. */
+	uint64_t cldtecrip                    : 3;  /**< Encoding which represents \#of DTEs to cripple for each
+                                                         cluster. Typically DTE_CLCRIP=0 which enables all DTEs
+                                                         within each cluster. However, when the DFA performance
+                                                         counters are used, SW may want to limit the \#of DTEs
+                                                         per cluster available, as there are only 4 parallel
+                                                         performance counters.
+                                                            DTE_CLCRIP | \#DTEs crippled(per cluster)
+                                                         ------------+-----------------------------
+                                                                0    |  0      DTE[15:0]:ON
+                                                                1    |  1/2    DTE[15:8]:OFF  /DTE[7:0]:ON
+                                                                2    |  1/4    DTE[15:12]:OFF /DTE[11:0]:ON
+                                                                3    |  3/4    DTE[15:4]:OFF  /DTE[3:0]:ON
+                                                                4    |  1/8    DTE[15:14]:OFF /DTE[13:0]:ON
+                                                                5    |  5/8    DTE[15:6]:OFF  /DTE[5:0]:ON
+                                                                6    |  3/8    DTE[15:10]:OFF /DTE[9:0]:ON
+                                                                7    |  7/8    DTE[15:2]:OFF  /DTE[1:0]:ON
+                                                         NOTE: Higher numbered DTEs are crippled first. For instance,
+                                                         on o63 (with 16 DTEs/cluster), if DTE_CLCRIP=1(1/2), then
+                                                         DTE#s [15:8] within the cluster are crippled and only
+                                                         DTE#s [7:0] are available.
+                                                         IMPNOTE: The encodings are done in such a way as to later
+                                                         be used with fuses (for future o2 revisions which will disable
+                                                         some \#of DTEs). Blowing a fuse has the effect that there will
+                                                         always be fewer DTEs available. [ie: we never want a customer
+                                                         to blow additional fuses to get more DTEs].
+                                                         SWNOTE: The MIO_FUS___DFA_NUMDTE_CRIPPLE[2:0] fuse bits will
+                                                         be forced into this register at reset. Any fuse bits that
+                                                         contain '1' will be disallowed during a write and will always
+                                                         be read as '1'. */
+	uint64_t dteclkdis                    : 1;  /**< DFA Clock Disable Source
+                                                         When SET, the DFA clocks for DTE(thread engine)
+                                                         operation are disabled (to conserve overall chip clocking
+                                                         power when the DFA function is not used).
+                                                         NOTE: When SET, SW MUST NEVER issue NCB-Direct CSR
+                                                         operations to the DFA (will result in NCB Bus Timeout
+                                                         errors).
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         SWNOTE: The MIO_FUS___DFA_DTE_DISABLE fuse bit will
+                                                         be forced into this register at reset. If the fuse bit
+                                                         contains '1', writes to DTECLKDIS are disallowed and
+                                                         will always be read as '1'. */
+#else
+	uint64_t dteclkdis                    : 1;
+	uint64_t cldtecrip                    : 3;
+	uint64_t clmskcrip                    : 4;
+	uint64_t reserved_8_63                : 56;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfa_config_cn63xx         cn66xx;
+	struct cvmx_dfa_config_s              cn68xx;
+	struct cvmx_dfa_config_s              cn68xxp1;
+	struct cvmx_dfa_config_s              cn70xx;
+	struct cvmx_dfa_config_s              cn78xx;
+};
+typedef union cvmx_dfa_config cvmx_dfa_config_t;
+
+/**
+ * cvmx_dfa_control
+ *
+ * Description:
+ *
+ */
+union cvmx_dfa_control {
+	uint64_t u64;
+	struct cvmx_dfa_control_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t sbdnum                       : 6;  /**< Reserved. INTERNAL: DFA Scoreboard debug control. Selects which one of 48 DFA Scoreboard
+                                                         entries is latched into the DFA_SBD_DBG[0-3] registers. */
+	uint64_t sbdlck                       : 1;  /**< Reserved. INTERNAL: DFA Scoreboard LOCK stribe. When written with a '1', the DFA
+                                                         Scoreboard Debug registers (DFA_SBD_DBG[0-3]) are all locked down. This allows SW to lock
+                                                         down the contents of the entire SBD for a single instant in time. All subsequent reads of
+                                                         the DFA scoreboard registers will return the data from that instant in time. */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t pmode                        : 1;  /**< Reserved. INTERNAL: NCB-NRP Arbiter Mode.
+                                                         (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR.
+                                                         NOTE: This should only be written to a different value during power-on SW initialization. */
+	uint64_t qmode                        : 1;  /**< Reserved. INTERNAL: NCB-NRQ Arbiter Mode.
+                                                         (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR
+                                                         NOTE: This should only be written to a different value during power-on SW initialization. */
+	uint64_t imode                        : 1;  /**< Reserved. INTERNAL: NCB-Inbound Arbiter.
+                                                         (0=FP [LP=NRQ,HP=NRP], 1=RR)
+                                                         NOTE: This should only be written to a different value during power-on SW initialization. */
+#else
+	uint64_t imode                        : 1;
+	uint64_t qmode                        : 1;
+	uint64_t pmode                        : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t sbdlck                       : 1;
+	uint64_t sbdnum                       : 6;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_dfa_control_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t sbdnum                       : 4;  /**< SBD Debug Entry#
+                                                         *FOR INTERNAL USE ONLY*
+                                                         DFA Scoreboard debug control
+                                                         Selects which one of 16 DFA Scoreboard entries is
+                                                         latched into the DFA_SBD_DBG[0-3] registers. */
+	uint64_t sbdlck                       : 1;  /**< DFA Scoreboard LOCK Strobe
+                                                         *FOR INTERNAL USE ONLY*
+                                                         DFA Scoreboard debug control
+                                                         When written with a '1', the DFA Scoreboard Debug
+                                                         registers (DFA_SBD_DBG[0-3]) are all locked down.
+                                                         This allows SW to lock down the contents of the entire
+                                                         SBD for a single instant in time. All subsequent reads
+                                                         of the DFA scoreboard registers will return the data
+                                                         from that instant in time. */
+	uint64_t reserved_3_4                 : 2;
+	uint64_t pmode                        : 1;  /**< NCB-NRP Arbiter Mode
+                                                         (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t qmode                        : 1;  /**< NCB-NRQ Arbiter Mode
+                                                         (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t imode                        : 1;  /**< NCB-Inbound Arbiter
+                                                         (0=FP [LP=NRQ,HP=NRP], 1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t imode                        : 1;
+	uint64_t qmode                        : 1;
+	uint64_t pmode                        : 1;
+	uint64_t reserved_3_4                 : 2;
+	uint64_t sbdlck                       : 1;
+	uint64_t sbdnum                       : 4;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_control_cn61xx        cn63xx;
+	struct cvmx_dfa_control_cn61xx        cn63xxp1;
+	struct cvmx_dfa_control_cn61xx        cn66xx;
+	struct cvmx_dfa_control_s             cn68xx;
+	struct cvmx_dfa_control_s             cn68xxp1;
+	struct cvmx_dfa_control_cn61xx        cn70xx;
+	struct cvmx_dfa_control_s             cn78xx;
+};
+typedef union cvmx_dfa_control cvmx_dfa_control_t;
+
+/**
+ * cvmx_dfa_dbell
+ *
+ * To write to DFA_DBELL, a device issues an IOBST request directed at the HFA with addr[34:33] =
+ * 0x0. To read DFA_DBELL, a device issues an IOBLD64 request directed at the HFA with
+ * addr[34:33] = 0x0.
+ * If DFA_CONFIG[DTECLKDIS] = 1 (i.e. HFA-HTE clocks are disabled) or if FUSE[90]= 'HFA HTE
+ * disable' is blown, read/write operations to DFA_DBELL do not take effect.
+ */
+union cvmx_dfa_dbell {
+	uint64_t u64;
+	struct cvmx_dfa_dbell_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_20_63               : 44;
+	uint64_t dbell                        : 20; /**< Represents the cumulative total of pending HFA instructions that software has previously
+                                                         written into the HFA instruction FIFO (DIF) in main memory. Each HFA instruction contains
+                                                         a fixed size 64-byte instruction word which is executed by the HFA hardware.
+                                                         The DBL register can hold up to 1M-1 (2^20-1) pending HFA instruction requests. During a
+                                                         read (by software), the 'most recent' contents of the DFA_DBELL register are returned at
+                                                         the time the IOI-INB bus is driven.
+                                                         Since HFA hardware updates this register, its contents are unpredictable in software. */
+#else
+	uint64_t dbell                        : 20;
+	uint64_t reserved_20_63               : 44;
+#endif
+	} s;
+	struct cvmx_dfa_dbell_s               cn31xx;
+	struct cvmx_dfa_dbell_s               cn38xx;
+	struct cvmx_dfa_dbell_s               cn38xxp2;
+	struct cvmx_dfa_dbell_s               cn58xx;
+	struct cvmx_dfa_dbell_s               cn58xxp1;
+	struct cvmx_dfa_dbell_s               cn61xx;
+	struct cvmx_dfa_dbell_s               cn63xx;
+	struct cvmx_dfa_dbell_s               cn63xxp1;
+	struct cvmx_dfa_dbell_s               cn66xx;
+	struct cvmx_dfa_dbell_s               cn68xx;
+	struct cvmx_dfa_dbell_s               cn68xxp1;
+	struct cvmx_dfa_dbell_s               cn70xx;
+	struct cvmx_dfa_dbell_s               cn78xx;
+};
+typedef union cvmx_dfa_dbell cvmx_dfa_dbell_t;
+
+/**
+ * cvmx_dfa_ddr2_addr
+ *
+ * DFA_DDR2_ADDR = DFA DDR2  fclk-domain Memory Address Config Register
+ *
+ *
+ * Description: The following registers are used to compose the DFA's DDR2 address into ROW/COL/BNK
+ *              etc.
+ */
+union cvmx_dfa_ddr2_addr {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_addr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t rdimm_ena                    : 1;  /**< If there is a need to insert a register chip on the
+                                                         system (the equivalent of a registered DIMM) to
+                                                         provide better setup for the command and control bits
+                                                         turn this mode on.
+                                                             RDIMM_ENA
+                                                                0           Registered Mode OFF
+                                                                1           Registered Mode ON */
+	uint64_t num_rnks                     : 2;  /**< NUM_RNKS is programmed based on how many ranks there
+                                                         are in the system. This needs to be programmed correctly
+                                                         regardless of whether we are in RNK_LO mode or not.
+                                                            NUM_RNKS     \# of Ranks
+                                                              0              1
+                                                              1              2
+                                                              2              4
+                                                              3              RESERVED */
+	uint64_t rnk_lo                       : 1;  /**< When this mode is turned on, consecutive addresses
+                                                         outside the bank boundary
+                                                         are programmed to go to different ranks in order to
+                                                         minimize bank conflicts. It is useful in 4-bank DDR2
+                                                         parts based memory to extend out the \#physical banks
+                                                         available and minimize bank conflicts.
+                                                         On 8 bank ddr2 parts, this mode is not very useful
+                                                         because this mode does come with
+                                                         a penalty which is that every successive reads that
+                                                         cross rank boundary will need a 1 cycle bubble
+                                                         inserted to prevent bus turnaround conflicts.
+                                                            RNK_LO
+                                                             0      - OFF
+                                                             1      - ON */
+	uint64_t num_colrows                  : 3;  /**< NUM_COLROWS    is used to set the MSB of the ROW_ADDR
+                                                         and the LSB of RANK address when not in RNK_LO mode.
+                                                         Calculate the sum of \#COL and \#ROW and program the
+                                                         controller appropriately
+                                                            RANK_LSB        \#COLs + \#ROWs
+                                                            ------------------------------
+                                                             - 000:                   22
+                                                             - 001:                   23
+                                                             - 010:                   24
+                                                             - 011:                   25
+                                                            - 100-111:             RESERVED */
+	uint64_t num_cols                     : 2;  /**< The Long word address that the controller receives
+                                                         needs to be converted to Row, Col, Rank and Bank
+                                                         addresses depending on the memory part's micro arch.
+                                                         NUM_COL tells the controller how many colum bits
+                                                         there are and the controller uses this info to map
+                                                         the LSB of the row address
+                                                             - 00: num_cols = 9
+                                                             - 01: num_cols = 10
+                                                             - 10: num_cols = 11
+                                                             - 11: RESERVED */
+#else
+	uint64_t num_cols                     : 2;
+	uint64_t num_colrows                  : 3;
+	uint64_t rnk_lo                       : 1;
+	uint64_t num_rnks                     : 2;
+	uint64_t rdimm_ena                    : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_addr_s           cn31xx;
+};
+typedef union cvmx_dfa_ddr2_addr cvmx_dfa_ddr2_addr_t;
+
+/**
+ * cvmx_dfa_ddr2_bus
+ *
+ * DFA_DDR2_BUS = DFA DDR Bus Activity Counter
+ *
+ *
+ * Description: This counter counts \# cycles that the memory bus is doing a read/write/command
+ *              Useful to benchmark the bus utilization as a ratio of
+ *              \#Cycles of Data Transfer/\#Cycles since init or
+ *              \#Cycles of Data Transfer/\#Cycles that memory controller is active
+ */
+union cvmx_dfa_ddr2_bus {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_bus_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t bus_cnt                      : 47; /**< Counter counts the \# cycles of Data transfer */
+#else
+	uint64_t bus_cnt                      : 47;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_bus_s            cn31xx;
+};
+typedef union cvmx_dfa_ddr2_bus cvmx_dfa_ddr2_bus_t;
+
+/**
+ * cvmx_dfa_ddr2_cfg
+ *
+ * DFA_DDR2_CFG = DFA DDR2 fclk-domain Memory Configuration \#0 Register
+ *
+ * Description:
+ */
+union cvmx_dfa_ddr2_cfg {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_cfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_41_63               : 23;
+	uint64_t trfc                         : 5;  /**< Establishes tRFC(from DDR2 data sheets) in \# of
+                                                         4 fclk intervals.
+                                                         General Equation:
+                                                         TRFC(csr) = ROUNDUP[tRFC(data-sheet-ns)/(4 * fclk(ns))]
+                                                         Example:
+                                                            tRFC(data-sheet-ns) = 127.5ns
+                                                            Operational Frequency: 533MHz DDR rate
+                                                                [fclk=266MHz(3.75ns)]
+                                                         Then:
+                                                            TRFC(csr) = ROUNDUP[127.5ns/(4 * 3.75ns)]
+                                                                      = 9 */
+	uint64_t mrs_pgm                      : 1;  /**< When clear, the HW initialization sequence fixes
+                                                         some of the *MRS register bit definitions.
+                                                            EMRS:
+                                                              A[14:13] = 0 RESERVED
+                                                              A[12] = 0    Output Buffers Enabled (FIXED)
+                                                              A[11] = 0    RDQS Disabled (FIXED)
+                                                              A[10] = 0    DQSn Enabled (FIXED)
+                                                              A[9:7] = 0   OCD Not supported (FIXED)
+                                                              A[6] = 0     RTT Disabled (FIXED)
+                                                              A[5:3]=DFA_DDR2_TMG[ADDLAT] (if DFA_DDR2_TMG[POCAS]=1)
+                                                                            Additive LATENCY (Programmable)
+                                                              A[2]=0       RTT Disabled (FIXED)
+                                                              A[1]=DFA_DDR2_TMG[DIC] (Programmable)
+                                                              A[0] = 0     DLL Enabled (FIXED)
+                                                            MRS:
+                                                              A[14:13] = 0 RESERVED
+                                                              A[12] = 0    Fast Active Power Down Mode (FIXED)
+                                                              A[11:9] = DFA_DDR2_TMG[TWR](Programmable)
+                                                              A[8] = 1     DLL Reset (FIXED)
+                                                              A[7] = 0     Test Mode (FIXED)
+                                                              A[6:4]=DFA_DDR2_TMG[CASLAT] CAS LATENCY (Programmable)
+                                                              A[3] = 0     Burst Type(must be 0:Sequential) (FIXED)
+                                                              A[2:0] = 2   Burst Length=4 (must be 0:Sequential) (FIXED)
+                                                         When set, the HW initialization sequence sources
+                                                         the DFA_DDR2_MRS, DFA_DDR2_EMRS registers which are
+                                                         driven onto the DFA_A[] pins. (this allows the MRS/EMRS
+                                                         fields to be completely programmable - however care
+                                                         must be taken by software).
+                                                         This mode is useful for customers who wish to:
+                                                            1) override the FIXED definitions(above), or
+                                                            2) Use a "clamshell mode" of operation where the
+                                                               address bits(per rank) are swizzled on the
+                                                               board to reduce stub lengths for optimal
+                                                               frequency operation.
+                                                         Use this in combination with DFA_DDR2_CFG[RNK_MSK]
+                                                         to specify the INIT sequence for each of the 4
+                                                         supported ranks. */
+	uint64_t fpip                         : 3;  /**< Early Fill Programmable Pipe [\#fclks]
+                                                         This field dictates the \#fclks prior to the arrival
+                                                         of fill data(in fclk domain), to start the 'early' fill
+                                                         command pipe (in the eclk domain) so as to minimize the
+                                                         overall fill latency.
+                                                         The programmable early fill command signal is synchronized
+                                                         into the eclk domain, where it is used to pull data out of
+                                                         asynchronous RAM as fast as possible.
+                                                         NOTE: A value of FPIP=0 is the 'safest' setting and will
+                                                         result in the early fill command pipe starting in the
+                                                         same cycle as the fill data.
+                                                         General Equation: (for FPIP)
+                                                             FPIP <= MIN[6, (ROUND_DOWN[6/EF_RATIO] + 1)]
+                                                         where:
+                                                           EF_RATIO = ECLK/FCLK Ratio [eclk(MHz)/fclk(MHz)]
+                                                         Example: FCLK=200MHz/ECLK=600MHz
+                                                            FPIP = MIN[6, (ROUND_DOWN[6/(600/200))] + 1)]
+                                                            FPIP <= 3 */
+	uint64_t reserved_29_31               : 3;
+	uint64_t ref_int                      : 13; /**< Refresh Interval (represented in \#of fclk
+                                                         increments).
+                                                         Each refresh interval will generate a single
+                                                         auto-refresh command sequence which implicitly targets
+                                                         all banks within the device:
+                                                         Example: For fclk=200MHz(5ns)/400MHz(DDR):
+                                                           trefint(ns) = [tREFI(max)=3.9us = 3900ns [datasheet]
+                                                           REF_INT = ROUND_DOWN[(trefint/fclk)]
+                                                                   = ROUND_DOWN[(3900ns/5ns)]
+                                                                   = 780 fclks (0x30c)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t tskw                         : 2;  /**< Board Skew (represented in \#fclks)
+                                                         Represents additional board skew of DQ/DQS.
+                                                             - 00: board-skew = 0 fclk
+                                                             - 01: board-skew = 1 fclk
+                                                             - 10: board-skew = 2 fclk
+                                                             - 11: board-skew = 3 fclk
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t rnk_msk                      : 4;  /**< Controls the CS_N[3:0] during a) a HW Initialization
+                                                         sequence (triggered by DFA_DDR2_CFG[INIT]) or
+                                                         b) during a normal refresh sequence. If
+                                                         the RNK_MSK[x]=1, the corresponding CS_N[x] is driven.
+                                                         NOTE: This is required for DRAM used in a
+                                                         clamshell configuration, since the address lines
+                                                         carry Mode Register write data that is unique
+                                                         per rank(or clam). In a clamshell configuration,
+                                                         the N3K DFA_A[x] pin may be tied into Clam#0's A[x]
+                                                         and also into Clam#1's 'mirrored' address bit A[y]
+                                                         (eg: Clam0 sees A[5] and Clam1 sees A[15]).
+                                                         To support clamshell designs, SW must initiate
+                                                         separate HW init sequences each unique rank address
+                                                         mapping. Before each HW init sequence is triggered,
+                                                         SW must preload the DFA_DDR2_MRS/EMRS registers with
+                                                         the data that will be driven onto the A[14:0] wires
+                                                         during the EMRS/MRS mode register write(s).
+                                                         NOTE: After the final HW initialization sequence has
+                                                         been triggered, SW must wait 64K eclks before writing
+                                                         the RNK_MSK[3:0] field = 3'b1111 (so that CS_N[3:0]
+                                                         is driven during refresh sequences in normal operation.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t silo_qc                      : 1;  /**< Enables Quarter Cycle move of the Rd sampling window */
+	uint64_t silo_hc                      : 1;  /**< A combination of SILO_HC, SILO_QC and TSKW
+                                                         specifies the positioning of the sampling strobe
+                                                         when receiving read data back from DDR2. This is
+                                                         done to offset any board trace induced delay on
+                                                         the DQ and DQS which inherently makes these
+                                                         asynchronous with respect to the internal clk of
+                                                         controller. TSKW moves this sampling window by
+                                                         integer cycles. SILO_QC and HC move this quarter
+                                                         and half a cycle respectively. */
+	uint64_t sil_lat                      : 2;  /**< Silo Latency (\#fclks): On reads, determines how many
+                                                         additional fclks to wait (on top of CASLAT+1) before
+                                                         pulling data out of the padring silos used for time
+                                                         domain boundary crossing.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t bprch                        : 1;  /**< Tristate Enable (back porch) (\#fclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable back porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t fprch                        : 1;  /**< Tristate Enable (front porch) (\#fclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable front porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t init                         : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for the LLM Memory Port is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Enable memory port
+                                                               a) PRTENA=1
+                                                           2) Wait 200us (to ensure a stable clock
+                                                              to the DDR2) - as per DDR2 spec.
+                                                           3) Write a '1' to the INIT which
+                                                              will initiate a hardware initialization
+                                                              sequence.
+                                                         NOTE: After writing a '1', SW must wait 64K eclk
+                                                         cycles to ensure the HW init sequence has completed
+                                                         before writing to ANY of the DFA_DDR2* registers.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t prtena                       : 1;  /**< Enable DFA Memory
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for DFA-LLM memory port. */
+#else
+	uint64_t prtena                       : 1;
+	uint64_t init                         : 1;
+	uint64_t fprch                        : 1;
+	uint64_t bprch                        : 1;
+	uint64_t sil_lat                      : 2;
+	uint64_t silo_hc                      : 1;
+	uint64_t silo_qc                      : 1;
+	uint64_t rnk_msk                      : 4;
+	uint64_t tskw                         : 2;
+	uint64_t reserved_14_15               : 2;
+	uint64_t ref_int                      : 13;
+	uint64_t reserved_29_31               : 3;
+	uint64_t fpip                         : 3;
+	uint64_t mrs_pgm                      : 1;
+	uint64_t trfc                         : 5;
+	uint64_t reserved_41_63               : 23;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_cfg_s            cn31xx;
+};
+typedef union cvmx_dfa_ddr2_cfg cvmx_dfa_ddr2_cfg_t;
+
+/**
+ * cvmx_dfa_ddr2_comp
+ *
+ * DFA_DDR2_COMP = DFA DDR2 I/O PVT Compensation Configuration
+ *
+ *
+ * Description: The following are registers to program the DDR2 PLL and DLL
+ */
+union cvmx_dfa_ddr2_comp {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_comp_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t dfa__pctl                    : 4;  /**< DFA DDR pctl from compensation circuit
+                                                         Internal DBG only */
+	uint64_t dfa__nctl                    : 4;  /**< DFA DDR nctl from compensation circuit
+                                                         Internal DBG only */
+	uint64_t reserved_9_55                : 47;
+	uint64_t pctl_csr                     : 4;  /**< Compensation control bits */
+	uint64_t nctl_csr                     : 4;  /**< Compensation control bits */
+	uint64_t comp_bypass                  : 1;  /**< Compensation Bypass */
+#else
+	uint64_t comp_bypass                  : 1;
+	uint64_t nctl_csr                     : 4;
+	uint64_t pctl_csr                     : 4;
+	uint64_t reserved_9_55                : 47;
+	uint64_t dfa__nctl                    : 4;
+	uint64_t dfa__pctl                    : 4;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_comp_s           cn31xx;
+};
+typedef union cvmx_dfa_ddr2_comp cvmx_dfa_ddr2_comp_t;
+
+/**
+ * cvmx_dfa_ddr2_emrs
+ *
+ * DFA_DDR2_EMRS = DDR2 EMRS Register(s) EMRS1[14:0], EMRS1_OCD[14:0]
+ * Description: This register contains the data driven onto the Address[14:0] lines during  DDR INIT
+ * To support Clamshelling (where N3K DFA_A[] pins are not 1:1 mapped to each clam(or rank), a HW init
+ * sequence is allowed on a "per-rank" basis. Care must be taken in the values programmed into these
+ * registers during the HW initialization sequence (see N3K specific restrictions in notes below).
+ * DFA_DDR2_CFG[MRS_PGM] must be 1 to support this feature.
+ *
+ * Notes:
+ * For DDR-II please consult your device's data sheet for further details:
+ *
+ */
+union cvmx_dfa_ddr2_emrs {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_emrs_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_31_63               : 33;
+	uint64_t emrs1_ocd                    : 15; /**< Memory Address[14:0] during "EMRS1 (OCD Calibration)"
+                                                         step \#12a "EMRS OCD Default Command" A[9:7]=111
+                                                         of DDR2 HW initialization sequence.
+                                                         (See JEDEC DDR2 specification (JESD79-2):
+                                                         Power Up and initialization sequence).
+                                                            A[14:13] = 0, RESERVED
+                                                            A[12] = 0, Output Buffers Enabled
+                                                            A[11] = 0, RDQS Disabled (we do not support RDQS)
+                                                            A[10] = 0, DQSn Enabled
+                                                            A[9:7] = 7, OCD Calibration Mode Default
+                                                            A[6] = 0, ODT Disabled
+                                                            A[5:3]=DFA_DDR2_TMG[ADDLAT]  Additive LATENCY (Default 0)
+                                                            A[2]=0    Termination Res RTT (ODT off Default)
+                                                            [A6,A2] = 0 -> ODT Disabled
+                                                                      1 -> 75 ohm; 2 -> 150 ohm; 3 - Reserved
+                                                            A[1]=0  Normal Output Driver Imp mode
+                                                                    (1 - weak ie., 60% of normal drive strength)
+                                                            A[0] = 0 DLL Enabled */
+	uint64_t reserved_15_15               : 1;
+	uint64_t emrs1                        : 15; /**< Memory Address[14:0] during:
+                                                           a) Step \#7 "EMRS1 to enable DLL (A[0]=0)"
+                                                           b) Step \#12b "EMRS OCD Calibration Mode Exit"
+                                                         steps of DDR2 HW initialization sequence.
+                                                         (See JEDEC DDR2 specification (JESD79-2): Power Up and
+                                                         initialization sequence).
+                                                           A[14:13] = 0, RESERVED
+                                                           A[12] = 0, Output Buffers Enabled
+                                                           A[11] = 0, RDQS Disabled (we do not support RDQS)
+                                                           A[10] = 0, DQSn Enabled
+                                                           A[9:7] = 0, OCD Calibration Mode exit/maintain
+                                                           A[6] = 0, ODT Disabled
+                                                           A[5:3]=DFA_DDR2_TMG[ADDLAT]  Additive LATENCY (Default 0)
+                                                           A[2]=0    Termination Res RTT (ODT off Default)
+                                                           [A6,A2] = 0 -> ODT Disabled
+                                                                     1 -> 75 ohm; 2 -> 150 ohm; 3 - Reserved
+                                                           A[1]=0  Normal Output Driver Imp mode
+                                                                   (1 - weak ie., 60% of normal drive strength)
+                                                           A[0] = 0 DLL Enabled */
+#else
+	uint64_t emrs1                        : 15;
+	uint64_t reserved_15_15               : 1;
+	uint64_t emrs1_ocd                    : 15;
+	uint64_t reserved_31_63               : 33;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_emrs_s           cn31xx;
+};
+typedef union cvmx_dfa_ddr2_emrs cvmx_dfa_ddr2_emrs_t;
+
+/**
+ * cvmx_dfa_ddr2_fcnt
+ *
+ * DFA_DDR2_FCNT = DFA FCLK Counter
+ *
+ *
+ * Description: This FCLK cycle counter gets going after memory has been initialized
+ */
+union cvmx_dfa_ddr2_fcnt {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_fcnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t fcyc_cnt                     : 47; /**< Counter counts FCLK cycles or \# cycles that the memory
+                                                         controller has requests queued up depending on FCNT_MODE
+                                                         If FCNT_MODE = 0, this counter counts the \# FCLK cycles
+                                                         If FCNT_MODE = 1, this counter counts the \# cycles the
+                                                         controller is active with memory requests. */
+#else
+	uint64_t fcyc_cnt                     : 47;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_fcnt_s           cn31xx;
+};
+typedef union cvmx_dfa_ddr2_fcnt cvmx_dfa_ddr2_fcnt_t;
+
+/**
+ * cvmx_dfa_ddr2_mrs
+ *
+ * DFA_DDR2_MRS = DDR2 MRS Register(s) MRS_DLL[14:0], MRS[14:0]
+ * Description: This register contains the data driven onto the Address[14:0] lines during DDR INIT
+ * To support Clamshelling (where N3K DFA_A[] pins are not 1:1 mapped to each clam(or rank), a HW init
+ * sequence is allowed on a "per-rank" basis. Care must be taken in the values programmed into these
+ * registers during the HW initialization sequence (see N3K specific restrictions in notes below).
+ * DFA_DDR2_CFG[MRS_PGM] must be 1 to support this feature.
+ *
+ * Notes:
+ * For DDR-II please consult your device's data sheet for further details:
+ *
+ */
+union cvmx_dfa_ddr2_mrs {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_mrs_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_31_63               : 33;
+	uint64_t mrs                          : 15; /**< Memory Address[14:0] during "MRS without resetting
+                                                         DLL A[8]=0" step of HW initialization sequence.
+                                                         (See JEDEC DDR2 specification (JESD79-2): Power Up
+                                                         and initialization sequence - Step \#11).
+                                                           A[14:13] = 0, RESERVED
+                                                           A[12] = 0, Fast Active Power Down Mode
+                                                           A[11:9] = DFA_DDR2_TMG[TWR]
+                                                           A[8] = 0, for DLL Reset
+                                                           A[7] =0  Test Mode (must be 0 for normal operation)
+                                                           A[6:4]=DFA_DDR2_TMG[CASLAT] CAS LATENCY (default 4)
+                                                           A[3]=0    Burst Type(must be 0:Sequential)
+                                                           A[2:0]=2  Burst Length=4(default) */
+	uint64_t reserved_15_15               : 1;
+	uint64_t mrs_dll                      : 15; /**< Memory Address[14:0] during "MRS for DLL_RESET A[8]=1"
+                                                         step of HW initialization sequence.
+                                                         (See JEDEC DDR2 specification (JESD79-2): Power Up
+                                                         and initialization sequence - Step \#8).
+                                                           A[14:13] = 0, RESERVED
+                                                           A[12] = 0, Fast Active Power Down Mode
+                                                           A[11:9] = DFA_DDR2_TMG[TWR]
+                                                           A[8] = 1, for DLL Reset
+                                                           A[7] = 0  Test Mode (must be 0 for normal operation)
+                                                           A[6:4]=DFA_DDR2_TMG[CASLAT]    CAS LATENCY (default 4)
+                                                           A[3] = 0    Burst Type(must be 0:Sequential)
+                                                           A[2:0] = 2  Burst Length=4(default) */
+#else
+	uint64_t mrs_dll                      : 15;
+	uint64_t reserved_15_15               : 1;
+	uint64_t mrs                          : 15;
+	uint64_t reserved_31_63               : 33;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_mrs_s            cn31xx;
+};
+typedef union cvmx_dfa_ddr2_mrs cvmx_dfa_ddr2_mrs_t;
+
+/**
+ * cvmx_dfa_ddr2_opt
+ *
+ * DFA_DDR2_OPT = DFA DDR2 Optimization Registers
+ *
+ *
+ * Description: The following are registers to tweak certain parameters to boost performance
+ */
+union cvmx_dfa_ddr2_opt {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_opt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t max_read_batch               : 5;  /**< Maximum number of consecutive read to service before
+                                                         allowing write to interrupt. */
+	uint64_t max_write_batch              : 5;  /**< Maximum number of consecutive writes to service before
+                                                         allowing reads to interrupt. */
+#else
+	uint64_t max_write_batch              : 5;
+	uint64_t max_read_batch               : 5;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_opt_s            cn31xx;
+};
+typedef union cvmx_dfa_ddr2_opt cvmx_dfa_ddr2_opt_t;
+
+/**
+ * cvmx_dfa_ddr2_pll
+ *
+ * DFA_DDR2_PLL = DFA DDR2 PLL and DLL Configuration
+ *
+ *
+ * Description: The following are registers to program the DDR2 PLL and DLL
+ */
+union cvmx_dfa_ddr2_pll {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_pll_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pll_setting                  : 17; /**< Internal Debug Use Only */
+	uint64_t reserved_32_46               : 15;
+	uint64_t setting90                    : 5;  /**< Contains the setting of DDR DLL; Internal DBG only */
+	uint64_t reserved_21_26               : 6;
+	uint64_t dll_setting                  : 5;  /**< Contains the open loop setting value for the DDR90 delay
+                                                         line. */
+	uint64_t dll_byp                      : 1;  /**< DLL Bypass. When set, the DDR90 DLL is bypassed and
+                                                         the DLL behaves in Open Loop giving a fixed delay
+                                                         set by DLL_SETTING */
+	uint64_t qdll_ena                     : 1;  /**< DDR Quad DLL Enable: A 0->1 transition on this bit after
+                                                         erst deassertion will reset the DDR 90 DLL. Allow
+                                                         200 micro seconds for Lock before DDR Init. */
+	uint64_t bw_ctl                       : 4;  /**< Internal Use Only - for Debug */
+	uint64_t bw_upd                       : 1;  /**< Internal Use Only - for Debug */
+	uint64_t pll_div2                     : 1;  /**< PLL Output is further divided by 2. Useful for slow
+                                                         fclk frequencies where the PLL may be out of range. */
+	uint64_t reserved_7_7                 : 1;
+	uint64_t pll_ratio                    : 5;  /**< Bits <6:2> sets the clk multiplication ratio
+                                                         If the fclk frequency desired is less than 260MHz
+                                                         (lower end saturation point of the pll), write 2x
+                                                         the ratio desired in this register and set PLL_DIV2 */
+	uint64_t pll_bypass                   : 1;  /**< PLL Bypass. Uses the ref_clk without multiplication. */
+	uint64_t pll_init                     : 1;  /**< Need a 0 to 1 pulse on this CSR to get the DFA
+                                                         Clk Generator Started. Write this register before
+                                                         starting anything. Allow 200 uS for PLL Lock before
+                                                         doing anything. */
+#else
+	uint64_t pll_init                     : 1;
+	uint64_t pll_bypass                   : 1;
+	uint64_t pll_ratio                    : 5;
+	uint64_t reserved_7_7                 : 1;
+	uint64_t pll_div2                     : 1;
+	uint64_t bw_upd                       : 1;
+	uint64_t bw_ctl                       : 4;
+	uint64_t qdll_ena                     : 1;
+	uint64_t dll_byp                      : 1;
+	uint64_t dll_setting                  : 5;
+	uint64_t reserved_21_26               : 6;
+	uint64_t setting90                    : 5;
+	uint64_t reserved_32_46               : 15;
+	uint64_t pll_setting                  : 17;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_pll_s            cn31xx;
+};
+typedef union cvmx_dfa_ddr2_pll cvmx_dfa_ddr2_pll_t;
+
+/**
+ * cvmx_dfa_ddr2_tmg
+ *
+ * DFA_DDR2_TMG = DFA DDR2 Memory Timing Config Register
+ *
+ *
+ * Description: The following are registers to program the DDR2 memory timing parameters.
+ */
+union cvmx_dfa_ddr2_tmg {
+	uint64_t u64;
+	struct cvmx_dfa_ddr2_tmg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t fcnt_mode                    : 1;  /**< If FCNT_MODE = 0, this counter counts the \# FCLK cycles
+                                                         If FCNT_MODE = 1, this counter counts the \# cycles the
+                                                         controller is active with memory requests. */
+	uint64_t cnt_clr                      : 1;  /**< Clears the FCLK Cyc & Bus Util counter */
+	uint64_t cavmipo                      : 1;  /**< RESERVED */
+	uint64_t ctr_rst                      : 1;  /**< Reset oneshot pulse for refresh counter & Perf counters
+                                                         SW should first write this field to a one to clear
+                                                         & then write to a zero for normal operation */
+	uint64_t odt_rtt                      : 2;  /**< DDR2 Termination Resistor Setting
+                                                         These two bits are loaded into the RTT
+                                                         portion of the EMRS register bits A6 & A2. If DDR2's
+                                                         termination (for the memory's DQ/DQS/DM pads) is not
+                                                         desired, set it to 00. If it is, chose between
+                                                         01 for 75 ohm and 10 for 150 ohm termination.
+                                                              00 = ODT Disabled
+                                                              01 = 75 ohm Termination
+                                                              10 = 150 ohm Termination
+                                                              11 = 50 ohm Termination */
+	uint64_t dqsn_ena                     : 1;  /**< For DDR-II Mode, DIC[1] is used to load into EMRS
+                                                         bit 10 - DQSN Enable/Disable field. By default, we
+                                                         program the DDR's to drive the DQSN also. Set it to
+                                                         1 if DQSN should be Hi-Z.
+                                                              0 - DQSN Enable
+                                                              1 - DQSN Disable */
+	uint64_t dic                          : 1;  /**< Drive Strength Control:
+                                                         For DDR-I/II Mode, DIC[0] is
+                                                         loaded into the Extended Mode Register (EMRS) A1 bit
+                                                         during initialization. (see DDR-I data sheet EMRS
+                                                         description)
+                                                              0 = Normal
+                                                              1 = Reduced */
+	uint64_t r2r_slot                     : 1;  /**< A 1 on this register will force the controller to
+                                                         slot a bubble between every reads */
+	uint64_t tfaw                         : 5;  /**< tFAW - Cycles = RNDUP[tFAW(ns)/tcyc(ns)] - 1
+                                                         Four Access Window time. Relevant only in
+                                                         8-bank parts.
+                                                              TFAW = 5'b0 for DDR2-4bank
+                                                              TFAW = RNDUP[tFAW(ns)/tcyc(ns)] - 1 in DDR2-8bank */
+	uint64_t twtr                         : 4;  /**< tWTR Cycles = RNDUP[tWTR(ns)/tcyc(ns)]
+                                                         Last Wr Data to Rd Command time.
+                                                         (Represented in fclk cycles)
+                                                         TYP=15ns
+                                                              - 0000: RESERVED
+                                                              - 0001: 1
+                                                              - ...
+                                                              - 0111: 7
+                                                              - 1000-1111: RESERVED */
+	uint64_t twr                          : 3;  /**< DDR Write Recovery time (tWR). Last Wr Brst to Prech
+                                                         This is not a direct encoding of the value. Its
+                                                         programmed as below per DDR2 spec. The decimal number
+                                                         on the right is RNDUP(tWR(ns) / clkFreq)
+                                                         TYP=15ns
+                                                              - 000: RESERVED
+                                                              - 001: 2
+                                                              - 010: 3
+                                                              - 011: 4
+                                                              - 100: 5
+                                                              - 101: 6
+                                                              - 110-111: RESERVED */
+	uint64_t trp                          : 4;  /**< tRP Cycles = RNDUP[tRP(ns)/tcyc(ns)]
+                                                         (Represented in fclk cycles)
+                                                         TYP=15ns
+                                                              - 0000: RESERVED
+                                                              - 0001: 1
+                                                              - ...
+                                                              - 0111: 7
+                                                              - 1000-1111: RESERVED
+                                                         When using parts with 8 banks (DFA_CFG->MAX_BNK
+                                                         is 1), load tRP cycles + 1 into this register. */
+	uint64_t tras                         : 5;  /**< tRAS Cycles = RNDUP[tRAS(ns)/tcyc(ns)]
+                                                         (Represented in fclk cycles)
+                                                         TYP=45ns
+                                                              - 00000-0001: RESERVED
+                                                              - 00010: 2
+                                                              - ...
+                                                              - 10100: 20
+                                                              - 10101-11111: RESERVED */
+	uint64_t trrd                         : 3;  /**< tRRD cycles: ACT-ACT timing parameter for different
+                                                         banks. (Represented in fclk cycles)
+                                                         For DDR2, TYP=7.5ns
+                                                             - 000: RESERVED
+                                                             - 001: 1 tCYC
+                                                             - 010: 2 tCYC
+                                                             - 011: 3 tCYC
+                                                             - 100: 4 tCYC
+                                                             - 101: 5 tCYC
+                                                             - 110-111: RESERVED */
+	uint64_t trcd                         : 4;  /**< tRCD Cycles = RNDUP[tRCD(ns)/tcyc(ns)]
+                                                         (Represented in fclk cycles)
+                                                         TYP=15ns
+                                                              - 0000: RESERVED
+                                                              - 0001: 2 (2 is the smallest value allowed)
+                                                              - 0002: 2
+                                                              - ...
+                                                              - 0111: 7
+                                                              - 1110-1111: RESERVED */
+	uint64_t addlat                       : 3;  /**< When in Posted CAS mode ADDLAT needs to be programmed
+                                                         to tRCD-1
+                                                               ADDLAT         \#additional latency cycles
+                                                                000              0
+                                                                001              1 (tRCD = 2 fclk's)
+                                                                010              2 (tRCD = 3 fclk's)
+                                                                011              3 (tRCD = 4 fclk's)
+                                                                100              4 (tRCD = 5 fclk's)
+                                                                101              5 (tRCD = 6 fclk's)
+                                                                110              6 (tRCD = 7 fclk's)
+                                                                111              7 (tRCD = 8 fclk's) */
+	uint64_t pocas                        : 1;  /**< Posted CAS mode. When 1, we use DDR2's Posted CAS
+                                                         feature. When using this mode, ADDLAT needs to be
+                                                         programmed as well */
+	uint64_t caslat                       : 3;  /**< CAS Latency in \# fclk Cycles
+                                                         CASLAT           \#  CAS latency cycles
+                                                          000 - 010           RESERVED
+                                                          011                    3
+                                                          100                    4
+                                                          101                    5
+                                                          110                    6
+                                                          111                    7 */
+	uint64_t tmrd                         : 2;  /**< tMRD Cycles
+                                                         (Represented in fclk tCYC)
+                                                         For DDR2, its TYP 2*tCYC)
+                                                             - 000: RESERVED
+                                                             - 001: 1
+                                                             - 010: 2
+                                                             - 011: 3 */
+	uint64_t ddr2t                        : 1;  /**< When 2T mode is turned on, command signals are
+                                                         setup a cycle ahead of when the CS is enabled
+                                                         and kept for a total of 2 cycles. This mode is
+                                                         enabled in higher speeds when there is difficulty
+                                                         meeting setup. Performance could
+                                                         be negatively affected in 2T mode */
+#else
+	uint64_t ddr2t                        : 1;
+	uint64_t tmrd                         : 2;
+	uint64_t caslat                       : 3;
+	uint64_t pocas                        : 1;
+	uint64_t addlat                       : 3;
+	uint64_t trcd                         : 4;
+	uint64_t trrd                         : 3;
+	uint64_t tras                         : 5;
+	uint64_t trp                          : 4;
+	uint64_t twr                          : 3;
+	uint64_t twtr                         : 4;
+	uint64_t tfaw                         : 5;
+	uint64_t r2r_slot                     : 1;
+	uint64_t dic                          : 1;
+	uint64_t dqsn_ena                     : 1;
+	uint64_t odt_rtt                      : 2;
+	uint64_t ctr_rst                      : 1;
+	uint64_t cavmipo                      : 1;
+	uint64_t cnt_clr                      : 1;
+	uint64_t fcnt_mode                    : 1;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfa_ddr2_tmg_s            cn31xx;
+};
+typedef union cvmx_dfa_ddr2_tmg cvmx_dfa_ddr2_tmg_t;
+
+/**
+ * cvmx_dfa_debug0
+ *
+ * When the DFA_CONTROL[SBDLCK] bit is written '1', the contents of this register are locked
+ * down. Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard
+ * at the time of the CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * model) on the reads unless the DTE Engine specified by DFA_CONTROL[SBDNUM] has previously been
+ * assigned an instruction.
+ */
+union cvmx_dfa_debug0 {
+	uint64_t u64;
+	struct cvmx_dfa_debug0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd0                         : 64; /**< DFA ScoreBoard 0 Data (DFA Scoreboard Debug).
+                                                         [63:38]   (26) rptr[28:3]: Result Base Pointer (QW-aligned)
+                                                         [37:22]   (16) Cumulative Result Write Counter (for HDR write)
+                                                         [21]       (1) Waiting for GRdRsp EOT
+                                                         [20]       (1) Waiting for GRdReq Issue (to NRQ)
+                                                         [19]       (1) GLPTR/GLCNT Valid
+                                                         [18]       (1) Completion Mark Detected
+                                                         [17:15]    (3) Completion Code [0=PDGONE/1=PERR/2=RFULL/3=TERM]
+                                                         [14]       (1) Completion Detected
+                                                         [13]       (1) Waiting for HDR RWrCmtRsp
+                                                         [12]       (1) Waiting for LAST RESULT RWrCmtRsp
+                                                         [11]       (1) Waiting for HDR RWrReq
+                                                         [10]        (1) Waiting for RWrReq
+                                                         [9]        (1) Waiting for WQWrReq issue
+                                                         [8]        (1) Waiting for PRdRsp EOT
+                                                         [7]        (1) Waiting for PRdReq Issue (to NRQ)
+                                                         [6]        (1) Packet Data Valid
+                                                         [5]        (1) WQVLD
+                                                         [4]        (1) WQ Done Point (either WQWrReq issued (for WQPTR<>0) OR HDR RWrCmtRsp)
+                                                         [3]        (1) Resultant write STF/P Mode
+                                                         [2]        (1) Packet Data LDT mode
+                                                         [1]        (1) Gather Mode
+                                                         [0]        (1) Valid */
+#else
+	uint64_t sbd0                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_debug0_s              cn78xx;
+};
+typedef union cvmx_dfa_debug0 cvmx_dfa_debug0_t;
+
+/**
+ * cvmx_dfa_debug1
+ *
+ * When the DFA_CONTROL[SBDLCK] bit is written '1', the contents of this register are locked
+ * down. Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard
+ * at the time of the CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral
+ * model) on the reads unless the DTE Engine specified by DFA_CONTROL[SBDNUM] has previously been
+ * assigned an instruction.
+ */
+union cvmx_dfa_debug1 {
+	uint64_t u64;
+	struct cvmx_dfa_debug1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd1                         : 64; /**< DFA Scoreboard 1 Debug Data.
+                                                         [63:56]   (8) Reserved.
+                                                         [55:16]  (40) Packet Data Pointer.
+                                                         [15:0]   (16) Packet Data Counter. */
+#else
+	uint64_t sbd1                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_debug1_s              cn78xx;
+};
+typedef union cvmx_dfa_debug1 cvmx_dfa_debug1_t;
+
+/**
+ * cvmx_dfa_debug2
+ *
+ * When DFA_CONTROL[SBDLCK] is written to 1, the contents of this register are locked down.
+ * Otherwise, the contents of this register are the active contents of the HFA scoreboard at the
+ * time of the CSR read. VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can
+ * propagate (in the behavioral model) on the reads unless the DTE Engine specified by
+ * DFA_CONTROL[SBDNUM] has previously been assigned an instruction.
+ */
+union cvmx_dfa_debug2 {
+	uint64_t u64;
+	struct cvmx_dfa_debug2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd2                         : 64; /**< HFA scoreboard 2 data.
+                                                         <63:45> (19) Reserved.
+                                                         <44:42> (3) Instruction type.
+                                                         <41:5> (37) rwptr<39:3>: Result write pointer.
+                                                         <4:0> (5) prwcnt<4:0>: Pending result write counter. */
+#else
+	uint64_t sbd2                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_debug2_s              cn61xx;
+	struct cvmx_dfa_debug2_s              cn63xx;
+	struct cvmx_dfa_debug2_s              cn63xxp1;
+	struct cvmx_dfa_debug2_s              cn66xx;
+	struct cvmx_dfa_debug2_s              cn68xx;
+	struct cvmx_dfa_debug2_s              cn68xxp1;
+	struct cvmx_dfa_debug2_s              cn70xx;
+	struct cvmx_dfa_debug2_s              cn78xx;
+};
+typedef union cvmx_dfa_debug2 cvmx_dfa_debug2_t;
+
+/**
+ * cvmx_dfa_debug3
+ *
+ * When DFA_CONTROL[SBDLCK] is written to 1, the contents of this register are locked down.
+ * Otherwise, the contents of this register are the active contents of the HFA Scoreboard at the
+ * time of the CSR read. VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can
+ * propagate (in the behavioral model) on the reads unless the DTE Engine specified by
+ * DFA_CONTROL[SBDNUM] has previously been assigned an instruction.
+ */
+union cvmx_dfa_debug3 {
+	uint64_t u64;
+	struct cvmx_dfa_debug3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd3                         : 64; /**< HFA scoreboard 3 data.
+                                                         <63:52> (11) rptr<39:29>: Result base pointer (QW-aligned).
+                                                         <52:16> (37) glptr<39:3>: Gather list pointer.
+                                                         <15:0> (16) glcnt Gather list counter. */
+#else
+	uint64_t sbd3                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_debug3_s              cn61xx;
+	struct cvmx_dfa_debug3_s              cn63xx;
+	struct cvmx_dfa_debug3_s              cn63xxp1;
+	struct cvmx_dfa_debug3_s              cn66xx;
+	struct cvmx_dfa_debug3_s              cn68xx;
+	struct cvmx_dfa_debug3_s              cn68xxp1;
+	struct cvmx_dfa_debug3_s              cn70xx;
+	struct cvmx_dfa_debug3_s              cn78xx;
+};
+typedef union cvmx_dfa_debug3 cvmx_dfa_debug3_t;
+
+/**
+ * cvmx_dfa_difctl
+ *
+ * To write to DFA_DIFCTL, a device issues an IOBST request directed at the HFA with addr[34:32]
+ * = 0x6. To read DFA_DIFCTL, a device issues an IOBLD64 request directed at the HFA with
+ * addr[34:32] = 0x6. This register is intended to only be written once (at power-up). Any future
+ * write operations could cause the HFA and FPA hardware to become unpredictable.
+ * If DFA_CONFIG[DTECLKDIS] = 1 (i.e. HFA-HTE clocks are disabled) or if FUSE[90] = 'HFA HTE
+ * disable' is blown, read/write operations to DFA_DIFCTL do not take effect.
+ */
+union cvmx_dfa_difctl {
+	uint64_t u64;
+	struct cvmx_dfa_difctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t aura                         : 16; /**< Represents the 16-bit Aura ID used by HFA hardware when the HFA instruction chunk is
+                                                         recycled back to the free page list maintained by the FPA hardware (once the HFA
+                                                         instruction has been issued). */
+	uint64_t msegbase                     : 6;  /**< Reserved. */
+	uint64_t reserved_12_19               : 8;
+	uint64_t pool                         : 3;  /**< Represents the 3bit buffer pool-id  used by DFA HW
+                                                         when the DFA instruction chunk is recycled back
+                                                         to the Free Page List maintained by the FPA HW
+                                                         (once the DFA instruction has been issued). */
+	uint64_t size                         : 9;  /**< Represents the number of 64-byte instructions contained within each HFA instruction chunk.
+                                                         At power-on, software seeds the SIZE register with a fixed chunk-size (must be at least
+                                                         0x3). HFA hardware uses this field to determine the size of each HFA instruction chunk, in
+                                                         order to:
+                                                         a) determine when to read the next HFA instruction chunk pointer which is written by
+                                                         software at the end of the current HFA instruction chunk (see HFA description of next
+                                                         chunk buffer Ptr for format).
+                                                         b) determine when a HFA instruction chunk can be returned to the free page list maintained
+                                                         by the FPA hardware. */
+#else
+	uint64_t size                         : 9;
+	uint64_t pool                         : 3;
+	uint64_t reserved_12_19               : 8;
+	uint64_t msegbase                     : 6;
+	uint64_t aura                         : 16;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_dfa_difctl_cn31xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_20_63               : 44;
+	uint64_t dwbcnt                       : 8;  /**< Represents the \# of cache lines in the instruction
+                                                         buffer that may be dirty and should not be
+                                                         written-back to memory when the instruction
+                                                         chunk is returned to the Free Page list.
+                                                         NOTE: Typically SW will want to mark all DFA
+                                                         Instruction memory returned to the Free Page list
+                                                         as DWB (Don't WriteBack), therefore SW should
+                                                         seed this register as:
+                                                           DFA_DIFCTL[DWBCNT] = (DFA_DIFCTL[SIZE] + 4)/4 */
+	uint64_t pool                         : 3;  /**< Represents the 3bit buffer pool-id  used by DFA HW
+                                                         when the DFA instruction chunk is recycled back
+                                                         to the Free Page List maintained by the FPA HW
+                                                         (once the DFA instruction has been issued). */
+	uint64_t size                         : 9;  /**< Represents the \# of 32B instructions contained
+                                                         within each DFA instruction chunk. At Power-on,
+                                                         SW will seed the SIZE register with a fixed
+                                                         chunk-size. (Must be at least 3)
+                                                         DFA HW uses this field to determine the size
+                                                         of each DFA instruction chunk, in order to:
+                                                            a) determine when to read the next DFA
+                                                               instruction chunk pointer which is
+                                                               written by SW at the end of the current
+                                                               DFA instruction chunk (see DFA description
+                                                               of next chunk buffer Ptr for format).
+                                                            b) determine when a DFA instruction chunk
+                                                               can be returned to the Free Page List
+                                                               maintained by the FPA HW. */
+#else
+	uint64_t size                         : 9;
+	uint64_t pool                         : 3;
+	uint64_t dwbcnt                       : 8;
+	uint64_t reserved_20_63               : 44;
+#endif
+	} cn31xx;
+	struct cvmx_dfa_difctl_cn31xx         cn38xx;
+	struct cvmx_dfa_difctl_cn31xx         cn38xxp2;
+	struct cvmx_dfa_difctl_cn31xx         cn58xx;
+	struct cvmx_dfa_difctl_cn31xx         cn58xxp1;
+	struct cvmx_dfa_difctl_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_26_63               : 38;
+	uint64_t msegbase                     : 6;  /**< Memory Segmentation Base Address
+                                                         For debug purposes, backdoor accesses to the DFA
+                                                         memory are supported via NCB-Direct CSR accesses to
+                                                         the DFA Memory REGION(if addr[34:32]=5. However due
+                                                         to the existing NCB address decoding scheme, the
+                                                         address only offers a 4GB extent into the DFA memory
+                                                         REGION. Therefore, the MSEGBASE CSR field provides
+                                                         the additional upper memory address bits to allow access
+                                                         to the full extent of memory (128GB MAX).
+                                                         For DFA Memory REGION read NCB-Direct CSR accesses, the
+                                                         38bit L2/DRAM memory byte address is generated as follows:
+                                                           memaddr[37:0] = [DFA_DIFCTL[MSEGBASE],ncb_addr[31:3],3'b0]
+                                                         NOTE: See the upper 6bits of the memory address are sourced
+                                                         from DFA_DIFCTL[MSEGBASE] CSR field. The lower 4GB address
+                                                         offset is directly referenced using the NCB address bits during
+                                                         the reference itself.
+                                                         NOTE: The DFA_DIFCTL[MSEGBASE] is shared amongst all references.
+                                                         As such, if multiple PPs are accessing different segments in memory,
+                                                         their must be a SW mutual exclusive lock during each DFA Memory
+                                                         REGION access to avoid collisions between PPs using the same MSEGBASE
+                                                         CSR field.
+                                                         NOTE: See also DFA_ERROR[DFANXM] programmable interrupt which is
+                                                         flagged if SW tries to access non-existent memory space (address hole
+                                                         or upper unused region of 38bit address space). */
+	uint64_t dwbcnt                       : 8;  /**< Represents the \# of cache lines in the instruction
+                                                         buffer that may be dirty and should not be
+                                                         written-back to memory when the instruction
+                                                         chunk is returned to the Free Page list.
+                                                         NOTE: Typically SW will want to mark all DFA
+                                                         Instruction memory returned to the Free Page list
+                                                         as DWB (Don't WriteBack), therefore SW should
+                                                         seed this register as:
+                                                           DFA_DIFCTL[DWBCNT] = (DFA_DIFCTL[SIZE] + 4)/4 */
+	uint64_t pool                         : 3;  /**< Represents the 3bit buffer pool-id  used by DFA HW
+                                                         when the DFA instruction chunk is recycled back
+                                                         to the Free Page List maintained by the FPA HW
+                                                         (once the DFA instruction has been issued). */
+	uint64_t size                         : 9;  /**< Represents the \# of 32B instructions contained
+                                                         within each DFA instruction chunk. At Power-on,
+                                                         SW will seed the SIZE register with a fixed
+                                                         chunk-size. (Must be at least 3)
+                                                         DFA HW uses this field to determine the size
+                                                         of each DFA instruction chunk, in order to:
+                                                            a) determine when to read the next DFA
+                                                               instruction chunk pointer which is
+                                                               written by SW at the end of the current
+                                                               DFA instruction chunk (see DFA description
+                                                               of next chunk buffer Ptr for format).
+                                                            b) determine when a DFA instruction chunk
+                                                               can be returned to the Free Page List
+                                                               maintained by the FPA HW. */
+#else
+	uint64_t size                         : 9;
+	uint64_t pool                         : 3;
+	uint64_t dwbcnt                       : 8;
+	uint64_t msegbase                     : 6;
+	uint64_t reserved_26_63               : 38;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_difctl_cn31xx         cn63xx;
+	struct cvmx_dfa_difctl_cn31xx         cn63xxp1;
+	struct cvmx_dfa_difctl_cn31xx         cn66xx;
+	struct cvmx_dfa_difctl_cn61xx         cn68xx;
+	struct cvmx_dfa_difctl_cn61xx         cn68xxp1;
+	struct cvmx_dfa_difctl_cn61xx         cn70xx;
+	struct cvmx_dfa_difctl_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t aura                         : 16; /**< Represents the 16-bit Aura ID used by HFA hardware when the HFA instruction chunk is
+                                                         recycled back to the free page list maintained by the FPA hardware (once the HFA
+                                                         instruction has been issued). */
+	uint64_t msegbase                     : 6;  /**< Reserved. */
+	uint64_t reserved_13_19               : 7;
+	uint64_t ldwb                         : 1;  /**< Load don't write back. When set, the hardware issues LDWB command towards the cache when
+                                                         fetching the last word of instructions; as a result the line will not be written back when
+                                                         replaced.
+                                                         When clear, the hardware issues regular load towards the cache, which will cause the line
+                                                         to be written back before being replaced. */
+	uint64_t reserved_9_11                : 3;
+	uint64_t size                         : 9;  /**< Represents the number of 64-byte instructions contained within each HFA instruction chunk.
+                                                         At power-on, software seeds the SIZE register with a fixed chunk-size (must be at least
+                                                         0x3). HFA hardware uses this field to determine the size of each HFA instruction chunk, in
+                                                         order to:
+                                                         a) determine when to read the next HFA instruction chunk pointer which is written by
+                                                         software at the end of the current HFA instruction chunk (see HFA description of next
+                                                         chunk buffer Ptr for format).
+                                                         b) determine when a HFA instruction chunk can be returned to the free page list maintained
+                                                         by the FPA hardware. */
+#else
+	uint64_t size                         : 9;
+	uint64_t reserved_9_11                : 3;
+	uint64_t ldwb                         : 1;
+	uint64_t reserved_13_19               : 7;
+	uint64_t msegbase                     : 6;
+	uint64_t aura                         : 16;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} cn78xx;
+};
+typedef union cvmx_dfa_difctl cvmx_dfa_difctl_t;
+
+/**
+ * cvmx_dfa_difrdptr
+ *
+ * To write to DFA_DIFRDPTR, a device issues an IOBST request directed at the HFA with
+ * addr[34:33] = 0x1. To read DFA_DIFRDPTR, a device issues an IOBLD64 request directed at the
+ * HFA with addr[34:33] = 0x1.
+ * If DFA_CONFIG[DTECLKDIS] = 1 (i.e. HFA-HTE clocks are disabled) or if FUSE[90] = 'HFA HTE
+ * disable' is blown, read/write operations to DFA_DIFRDPTR do not take effect.
+ */
+union cvmx_dfa_difrdptr {
+	uint64_t u64;
+	struct cvmx_dfa_difrdptr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_0_63                : 64;
+#else
+	uint64_t reserved_0_63                : 64;
+#endif
+	} s;
+	struct cvmx_dfa_difrdptr_cn31xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_36_63               : 28;
+	uint64_t rdptr                        : 31; /**< Represents the 32B-aligned address of the current
+                                                         instruction in the DFA Instruction FIFO in main
+                                                         memory. The RDPTR must be seeded by software at
+                                                         boot time, and is then maintained thereafter
+                                                         by DFA HW.
+                                                         During the seed write (by SW), RDPTR[6:5]=0,
+                                                         since DFA instruction chunks must be 128B aligned.
+                                                         During a read (by SW), the 'most recent' contents
+                                                         of the RDPTR register are returned at the time
+                                                         the NCB-INB bus is driven.
+                                                         NOTE: Since DFA HW updates this register, its
+                                                         contents are unpredictable in SW (unless
+                                                         its guaranteed that no new DoorBell register
+                                                         writes have occurred and the DoorBell register is
+                                                         read as zero). */
+	uint64_t reserved_0_4                 : 5;
+#else
+	uint64_t reserved_0_4                 : 5;
+	uint64_t rdptr                        : 31;
+	uint64_t reserved_36_63               : 28;
+#endif
+	} cn31xx;
+	struct cvmx_dfa_difrdptr_cn31xx       cn38xx;
+	struct cvmx_dfa_difrdptr_cn31xx       cn38xxp2;
+	struct cvmx_dfa_difrdptr_cn31xx       cn58xx;
+	struct cvmx_dfa_difrdptr_cn31xx       cn58xxp1;
+	struct cvmx_dfa_difrdptr_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t rdptr                        : 35; /**< Represents the 32B-aligned address of the current
+                                                         instruction in the DFA Instruction FIFO in main
+                                                         memory. The RDPTR must be seeded by software at
+                                                         boot time, and is then maintained thereafter
+                                                         by DFA HW.
+                                                         During the seed write (by SW), RDPTR[6:5]=0,
+                                                         since DFA instruction chunks must be 128B aligned.
+                                                         During a read (by SW), the 'most recent' contents
+                                                         of the RDPTR register are returned at the time
+                                                         the NCB-INB bus is driven.
+                                                         NOTE: Since DFA HW updates this register, its
+                                                         contents are unpredictable in SW (unless
+                                                         its guaranteed that no new DoorBell register
+                                                         writes have occurred and the DoorBell register is
+                                                         read as zero). */
+	uint64_t reserved_0_4                 : 5;
+#else
+	uint64_t reserved_0_4                 : 5;
+	uint64_t rdptr                        : 35;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_difrdptr_cn61xx       cn63xx;
+	struct cvmx_dfa_difrdptr_cn61xx       cn63xxp1;
+	struct cvmx_dfa_difrdptr_cn61xx       cn66xx;
+	struct cvmx_dfa_difrdptr_cn61xx       cn68xx;
+	struct cvmx_dfa_difrdptr_cn61xx       cn68xxp1;
+	struct cvmx_dfa_difrdptr_cn61xx       cn70xx;
+	struct cvmx_dfa_difrdptr_cn78xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t rdptr                        : 36; /**< Represents the 64-byte-aligned address of the current instruction in the HFA Instruction
+                                                         FIFO in main memory. The RDPTR must be seeded by software at boot time, and is then
+                                                         maintained thereafter by HFA hardware. During the seed write operation (by software),
+                                                         RDPTR<6:5> = 0, since HFA instruction chunks must be 128-byte-aligned. During a read
+                                                         operation (by software), the most-recent contents of the RDPTR register are returned at
+                                                         the time the IOI-INB bus is driven.
+                                                         Since HFA hardware updates this register, its contents are unpredictable in software
+                                                         (unless it is guaranteed that no new doorbell register write operations have occurred and
+                                                         the doorbell register is read as zero). */
+	uint64_t reserved_0_5                 : 6;
+#else
+	uint64_t reserved_0_5                 : 6;
+	uint64_t rdptr                        : 36;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} cn78xx;
+};
+typedef union cvmx_dfa_difrdptr cvmx_dfa_difrdptr_t;
+
+/**
+ * cvmx_dfa_dtcfadr
+ *
+ * This register contains HFA graph-cache failing address/control error capture information. It
+ * contains useful information to help in isolating a graph-cache RAM failure.
+ */
+union cvmx_dfa_dtcfadr {
+	uint64_t u64;
+	struct cvmx_dfa_dtcfadr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_44_63               : 20;
+	uint64_t ram3fadr                     : 12; /**< HFA RAM3 failing address. If DFA_ERR[DC0PERR<2>] = 1, this field indicates the failing
+                                                         RAM3 address. The failing address is locked down until the DC0PERR<2> W1C occurs.
+                                                         If multiple DC0PERR<0>=1 errors are detected, the LSB cluster error information is
+                                                         captured. */
+	uint64_t reserved_25_31               : 7;
+	uint64_t ram2fadr                     : 9;  /**< HFA RAM2 failing address. If DFA_ERR[DC0PERR<1>] = 1, this field indicates the failing
+                                                         RAM2 address. The failing address is locked down until the DC0PERR<1> W1C occurs.
+                                                         If multiple DC0PERR<0>=1 errors are detected, the LSB cluster error information is
+                                                         captured. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t ram1fadr                     : 14; /**< HFA RAM1 failing address. If DFA_ERR[DC0PERR<0>] = 1, this field indicates the failing
+                                                         RAM1 address. The failing address is locked down until the DC0PERR<0> W1C occurs.
+                                                         If multiple DC0PERR<0>=1 errors are detected, the LSB cluster error information is
+                                                         captured. */
+#else
+	uint64_t ram1fadr                     : 14;
+	uint64_t reserved_14_15               : 2;
+	uint64_t ram2fadr                     : 9;
+	uint64_t reserved_25_31               : 7;
+	uint64_t ram3fadr                     : 12;
+	uint64_t reserved_44_63               : 20;
+#endif
+	} s;
+	struct cvmx_dfa_dtcfadr_s             cn61xx;
+	struct cvmx_dfa_dtcfadr_s             cn63xx;
+	struct cvmx_dfa_dtcfadr_s             cn63xxp1;
+	struct cvmx_dfa_dtcfadr_s             cn66xx;
+	struct cvmx_dfa_dtcfadr_s             cn68xx;
+	struct cvmx_dfa_dtcfadr_s             cn68xxp1;
+	struct cvmx_dfa_dtcfadr_s             cn70xx;
+	struct cvmx_dfa_dtcfadr_s             cn78xx;
+};
+typedef union cvmx_dfa_dtcfadr cvmx_dfa_dtcfadr_t;
+
+/**
+ * cvmx_dfa_eclkcfg
+ *
+ * Specify the RSL base addresses for the block
+ *
+ *                  DFA_ECLKCFG = DFA eclk-domain Configuration Registers
+ *
+ * Description:
+ */
+union cvmx_dfa_eclkcfg {
+	uint64_t u64;
+	struct cvmx_dfa_eclkcfg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_19_63               : 45;
+	uint64_t sbdnum                       : 3;  /**< SBD Debug Entry#
+                                                         For internal use only. (DFA Scoreboard debug)
+                                                         Selects which one of 8 DFA Scoreboard entries is
+                                                         latched into the DFA_SBD_DBG[0-3] registers. */
+	uint64_t reserved_15_15               : 1;
+	uint64_t sbdlck                       : 1;  /**< DFA Scoreboard LOCK Strobe
+                                                         For internal use only. (DFA Scoreboard debug)
+                                                         When written with a '1', the DFA Scoreboard Debug
+                                                         registers (DFA_SBD_DBG[0-3]) are all locked down.
+                                                         This allows SW to lock down the contents of the entire
+                                                         SBD for a single instant in time. All subsequent reads
+                                                         of the DFA scoreboard registers will return the data
+                                                         from that instant in time. */
+	uint64_t dcmode                       : 1;  /**< DRF-CRQ/DTE Arbiter Mode
+                                                         DTE-DRF Arbiter (0=FP [LP=CRQ/HP=DTE],1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t dtmode                       : 1;  /**< DRF-DTE Arbiter Mode
+                                                         DTE-DRF Arbiter (0=FP [LP=DTE[15],...,HP=DTE[0]],1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t pmode                        : 1;  /**< NCB-NRP Arbiter Mode
+                                                         (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t qmode                        : 1;  /**< NCB-NRQ Arbiter Mode
+                                                         (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t imode                        : 1;  /**< NCB-Inbound Arbiter
+                                                         (0=FP [LP=NRQ,HP=NRP], 1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t sarb                         : 1;  /**< DFA Source Arbiter Mode
+                                                         Selects the arbitration mode used to select DFA requests
+                                                         issued from either CP2 or the DTE (NCB-CSR or DFA HW engine).
+                                                          - 0: Fixed Priority [Highest=CP2, Lowest=DTE]
+                                                          - 1: Round-Robin
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t reserved_3_7                 : 5;
+	uint64_t dteclkdis                    : 1;  /**< DFA DTE Clock Disable
+                                                         When SET, the DFA clocks for DTE(thread engine)
+                                                         operation are disabled.
+                                                         NOTE: When SET, SW MUST NEVER issue ANY operations to
+                                                         the DFA via the NCB Bus. All DFA Operations must be
+                                                         issued solely through the CP2 interface. */
+	uint64_t maxbnk                       : 1;  /**< Maximum Banks per-device (used by the address mapper
+                                                         when extracting address bits for the memory bank#.
+                                                                 - 0: 4 banks/device
+                                                                 - 1: 8 banks/device */
+	uint64_t dfa_frstn                    : 1;  /**< Hold this 0 until the DFA DDR PLL and DLL lock
+                                                         and then write a 1. A 1 on this register deasserts
+                                                         the internal frst_n. Refer to DFA_DDR2_PLL registers for more
+                                                         startup information.
+                                                         Startup sequence if DFA interface needs to be ON:
+                                                          After valid power up,
+                                                          Write DFA_DDR2_PLL-> PLL_RATIO & PLL_DIV2 & PLL_BYPASS
+                                                          to the appropriate values
+                                                          Wait a few cycles
+                                                          Write a 1 DFA_DDR2_PLL -> PLL_INIT
+                                                          Wait 100 microseconds
+                                                          Write a 1 to DFA_DDR2_PLL -> QDLL_ENA
+                                                          Wait 10 microseconds
+                                                          Write a 1 to this register DFA_FRSTN to pull DFA out of
+                                                          reset
+                                                          Now the DFA block is ready to be initialized (follow the
+                                                          DDR init sequence). */
+#else
+	uint64_t dfa_frstn                    : 1;
+	uint64_t maxbnk                       : 1;
+	uint64_t dteclkdis                    : 1;
+	uint64_t reserved_3_7                 : 5;
+	uint64_t sarb                         : 1;
+	uint64_t imode                        : 1;
+	uint64_t qmode                        : 1;
+	uint64_t pmode                        : 1;
+	uint64_t dtmode                       : 1;
+	uint64_t dcmode                       : 1;
+	uint64_t sbdlck                       : 1;
+	uint64_t reserved_15_15               : 1;
+	uint64_t sbdnum                       : 3;
+	uint64_t reserved_19_63               : 45;
+#endif
+	} s;
+	struct cvmx_dfa_eclkcfg_s             cn31xx;
+};
+typedef union cvmx_dfa_eclkcfg cvmx_dfa_eclkcfg_t;
+
+/**
+ * cvmx_dfa_err
+ *
+ * DFA_ERR = DFA ERROR Register
+ *
+ * Description:
+ */
+union cvmx_dfa_err {
+	uint64_t u64;
+	struct cvmx_dfa_err_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_33_63               : 31;
+	uint64_t dblina                       : 1;  /**< Doorbell Overflow Interrupt Enable bit.
+                                                         When set, doorbell overflow conditions are reported. */
+	uint64_t dblovf                       : 1;  /**< Doorbell Overflow detected - Status bit
+                                                         When set, the 20b accumulated doorbell register
+                                                         had overflowed (SW wrote too many doorbell requests).
+                                                         If the DBLINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         NOTE: Detection of a Doorbell Register overflow
+                                                         is a catastrophic error which may leave the DFA
+                                                         HW in an unrecoverable state. */
+	uint64_t cp2pina                      : 1;  /**< CP2 LW Mode Parity Error Interrupt Enable bit.
+                                                         When set, all PP-generated LW Mode read
+                                                         transactions which encounter a parity error (across
+                                                         the 36b of data) are reported. */
+	uint64_t cp2perr                      : 1;  /**< PP-CP2 Parity Error Detected - Status bit
+                                                         When set, a parity error had been detected for a
+                                                         PP-generated LW Mode read transaction.
+                                                         If the CP2PINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         See also: DFA_MEMFADR CSR which contains more data
+                                                         about the memory address/control to help isolate
+                                                         the failure. */
+	uint64_t cp2parena                    : 1;  /**< CP2 LW Mode Parity Error Enable
+                                                         When set, all PP-generated LW Mode read
+                                                         transactions which encounter a parity error (across
+                                                         the 36b of data) are reported.
+                                                         NOTE: This signal must only be written to a different
+                                                         value when there are no PP-CP2 transactions
+                                                         (preferrably during power-on software initialization). */
+	uint64_t dtepina                      : 1;  /**< DTE Parity Error Interrupt Enable bit
+                                                         (for 18b SIMPLE mode ONLY).
+                                                         When set, all DTE-generated 18b SIMPLE Mode read
+                                                         transactions which encounter a parity error (across
+                                                         the 17b of data) are reported. */
+	uint64_t dteperr                      : 1;  /**< DTE Parity Error Detected (for 18b SIMPLE mode ONLY)
+                                                         When set, all DTE-generated 18b SIMPLE Mode read
+                                                         transactions which encounter a parity error (across
+                                                         the 17b of data) are reported. */
+	uint64_t dteparena                    : 1;  /**< DTE Parity Error Enable (for 18b SIMPLE mode ONLY)
+                                                         When set, all DTE-generated 18b SIMPLE Mode read
+                                                         transactions which encounter a parity error (across
+                                                         the 17b of data) are reported.
+                                                         NOTE: This signal must only be written to a different
+                                                         value when there are no DFA thread engines active
+                                                         (preferrably during power-on). */
+	uint64_t dtesyn                       : 7;  /**< DTE 29b ECC Failing 6bit Syndrome
+                                                         When DTESBE or DTEDBE are set, this field contains
+                                                         the failing 7b ECC syndrome. */
+	uint64_t dtedbina                     : 1;  /**< DTE 29b Double Bit Error Interrupt Enable bit
+                                                         When set, an interrupt is posted for any DTE-generated
+                                                         36b SIMPLE Mode read which encounters a double bit
+                                                         error. */
+	uint64_t dtesbina                     : 1;  /**< DTE 29b Single Bit Error Interrupt Enable bit
+                                                         When set, an interrupt is posted for any DTE-generated
+                                                         36b SIMPLE Mode read which encounters a single bit
+                                                         error (which is also corrected). */
+	uint64_t dtedbe                       : 1;  /**< DTE 29b Double Bit Error Detected - Status bit
+                                                         When set, a double bit error had been detected
+                                                         for a DTE-generated 36b SIMPLE Mode read transaction.
+                                                         The DTESYN contains the failing syndrome.
+                                                         If the DTEDBINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         See also: DFA_MEMFADR CSR which contains more data
+                                                         about the memory address/control to help isolate
+                                                         the failure.
+                                                         NOTE: DTE-generated 18b SIMPLE Mode Read transactions
+                                                         do not participate in ECC check/correct). */
+	uint64_t dtesbe                       : 1;  /**< DTE 29b Single Bit Error Corrected - Status bit
+                                                         When set, a single bit error had been detected and
+                                                         corrected for a DTE-generated 36b SIMPLE Mode read
+                                                         transaction.
+                                                         If the DTEDBE=0, then the DTESYN contains the
+                                                         failing syndrome (used during correction).
+                                                         NOTE: DTE-generated 18b SIMPLE Mode Read
+                                                         transactions do not participate in ECC check/correct).
+                                                         If the DTESBINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         See also: DFA_MEMFADR CSR which contains more data
+                                                         about the memory address/control to help isolate
+                                                         the failure. */
+	uint64_t dteeccena                    : 1;  /**< DTE 29b ECC Enable (for 36b SIMPLE mode ONLY)
+                                                         When set, 29b ECC is enabled on all DTE-generated
+                                                         36b SIMPLE Mode read transactions.
+                                                         NOTE: This signal must only be written to a different
+                                                         value when there are no DFA thread engines active
+                                                         (preferrably during power-on software initialization). */
+	uint64_t cp2syn                       : 8;  /**< PP-CP2 QW ECC Failing 8bit Syndrome
+                                                         When CP2SBE or CP2DBE are set, this field contains
+                                                         the failing ECC 8b syndrome.
+                                                         Refer to CP2ECCENA. */
+	uint64_t cp2dbina                     : 1;  /**< PP-CP2 Double Bit Error Interrupt Enable bit
+                                                         When set, an interrupt is posted for any PP-generated
+                                                         QW Mode read which encounters a double bit error.
+                                                         Refer to CP2DBE. */
+	uint64_t cp2sbina                     : 1;  /**< PP-CP2 Single Bit Error Interrupt Enable bit
+                                                         When set, an interrupt is posted for any PP-generated
+                                                         QW Mode read which encounters a single bit error
+                                                         (which is also corrected).
+                                                         Refer to CP2SBE. */
+	uint64_t cp2dbe                       : 1;  /**< PP-CP2 Double Bit Error Detected - Status bit
+                                                         When set, a double bit error had been detected
+                                                         for a PP-generated QW Mode read transaction.
+                                                         The CP2SYN contains the failing syndrome.
+                                                          NOTE: PP-generated LW Mode Read transactions
+                                                         do not participate in ECC check/correct).
+                                                         Refer to CP2ECCENA.
+                                                         If the CP2DBINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         See also: DFA_MEMFADR CSR which contains more data
+                                                         about the memory address/control to help isolate
+                                                         the failure. */
+	uint64_t cp2sbe                       : 1;  /**< PP-CP2 Single Bit Error Corrected - Status bit
+                                                         When set, a single bit error had been detected and
+                                                         corrected for a PP-generated QW Mode read
+                                                         transaction.
+                                                         If the CP2DBE=0, then the CP2SYN contains the
+                                                         failing syndrome (used during correction).
+                                                         Refer to CP2ECCENA.
+                                                         If the CP2SBINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         See also: DFA_MEMFADR CSR which contains more data
+                                                         about the memory address/control to help isolate
+                                                         the failure.
+                                                         NOTE: PP-generated LW Mode Read transactions
+                                                         do not participate in ECC check/correct). */
+	uint64_t cp2eccena                    : 1;  /**< PP-CP2 QW ECC Enable (for QW Mode transactions)
+                                                         When set, 8bit QW ECC is enabled on all PP-generated
+                                                         QW Mode read transactions, CP2SBE and
+                                                         CP2DBE may be set, and CP2SYN may be filled.
+                                                         NOTE: This signal must only be written to a different
+                                                         value when there are no PP-CP2 transactions
+                                                         (preferrably during power-on software initialization).
+                                                         NOTE: QW refers to a 64-bit LLM Load/Store (intiated
+                                                         by a processor core). LW refers to a 36-bit load/store. */
+#else
+	uint64_t cp2eccena                    : 1;
+	uint64_t cp2sbe                       : 1;
+	uint64_t cp2dbe                       : 1;
+	uint64_t cp2sbina                     : 1;
+	uint64_t cp2dbina                     : 1;
+	uint64_t cp2syn                       : 8;
+	uint64_t dteeccena                    : 1;
+	uint64_t dtesbe                       : 1;
+	uint64_t dtedbe                       : 1;
+	uint64_t dtesbina                     : 1;
+	uint64_t dtedbina                     : 1;
+	uint64_t dtesyn                       : 7;
+	uint64_t dteparena                    : 1;
+	uint64_t dteperr                      : 1;
+	uint64_t dtepina                      : 1;
+	uint64_t cp2parena                    : 1;
+	uint64_t cp2perr                      : 1;
+	uint64_t cp2pina                      : 1;
+	uint64_t dblovf                       : 1;
+	uint64_t dblina                       : 1;
+	uint64_t reserved_33_63               : 31;
+#endif
+	} s;
+	struct cvmx_dfa_err_s                 cn31xx;
+	struct cvmx_dfa_err_s                 cn38xx;
+	struct cvmx_dfa_err_s                 cn38xxp2;
+	struct cvmx_dfa_err_s                 cn58xx;
+	struct cvmx_dfa_err_s                 cn58xxp1;
+};
+typedef union cvmx_dfa_err cvmx_dfa_err_t;
+
+/**
+ * cvmx_dfa_error
+ *
+ * Description:
+ *
+ */
+union cvmx_dfa_error {
+	uint64_t u64;
+	struct cvmx_dfa_error_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_20_63               : 44;
+	uint64_t osmerr                       : 1;  /**< OSM reported an error with the response data. */
+	uint64_t replerr                      : 1;  /**< HFA illegal replication factor error. HFA only supports 1*, 2*, and 4* port replication.
+                                                         Legal configurations for memory are to support 2 port or 4 port configurations.
+                                                         The REPLERR interrupt is set in the following illegal configuration cases:
+                                                         An 8* replication factor is detected for any memory reference.
+                                                         A 4* replication factor is detected for any memory reference when only 2 memory ports are
+                                                         enabled.
+                                                         If REPLERR is set during a HFA graph walk operation, the walk prematurely terminates with
+                                                         RWORD0[REA]=ERR. If REPLERR is set during a IOI-direct CSR read access to HFA memory
+                                                         region, the CSR read response data is unpredictable. */
+	uint64_t dfanxm                       : 1;  /**< HFA nonexistent memory access. HTEs (and backdoor CSR HFA memory region reads) have access
+                                                         to the following 40-bit L2/DRAM address space, which maps to a 38-bit physical DDR3 SDRAM
+                                                         address space.
+                                                         DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF
+                                                         maps to lower 256MB of physical DDR3 SDRAM
+                                                         DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF
+                                                         maps to upper 127.75GB of DDR3 SDRAM
+                                                         In the event the HFA generates a reference to the L2/DRAM address hole (0x0000.0FFF.FFFF -
+                                                         0x0000.1FFF.FFFF) or to an address above 0x0020.0FFF.FFFF, the DFANXM programmable
+                                                         interrupt bit will be set.
+                                                         Software Note:
+                                                         Both the 1) software HFA graph compiler and the 2) software IOI-direct CSR accesses to HFA
+                                                         memory region must avoid making references to these nonexistent memory regions.
+                                                         If DFANXM is set during a HFA graph walk operation, the walk is prematurely terminated
+                                                         with RWORD0[REA]=ERR. If DFANXM is set during a IOI-direct CSR read access to HFA memory
+                                                         region, the CSR read response data is forced to
+                                                         128'hBADE_FEED_DEAD_BEEF_FACE_CAFE_BEAD_C0DE. (The 64-bit doubleword being accessed,
+                                                         either the upper or lower doubleword will be returned). */
+	uint64_t cndrd                        : 1;  /**< If any of the clusters detected a parity error on RAM1, this additional bit further
+                                                         specifies that the RAM1 parity error was detected during a CND-RD (cache node metadata
+                                                         read).
+                                                         This bit is set if ANY node cluster's RAM1 accesses detect a CNDRD error.
+                                                         INTERNAL: For CNDRD Parity Error, the previous CNA arc fetch information is written to
+                                                         RWORD1+ as follows:
+                                                         RWORD1+[NTYPE]=MNODE
+                                                         RWORD1+[NDNID]=cna.ndnid
+                                                         RWORD1+[NHMSK]=cna.hmsk
+                                                         RWORD1+[NNPTR]=cna.nnptr[13:0] */
+	uint64_t reserved_15_15               : 1;
+	uint64_t dlc1_ovferr                  : 1;  /**< DLC1 FIFO overflow error detected. This condition should never architecturally occur, and
+                                                         is here in case hardware credit/debit scheme is not working. */
+	uint64_t dlc0_ovferr                  : 1;  /**< DLC0 FIFO overflow error detected. This condition should never architecturally occur, and
+                                                         is here in case hardware credit/debit scheme is not working. */
+	uint64_t dc3perr                      : 3;  /**< Cluster 3 RAM[3:1] parity error detected. See also DFA_DTCFADR, which contains the failing
+                                                         addresses for the internal node cache RAMs. */
+	uint64_t dc2perr                      : 3;  /**< Cluster 2 RAM[3:1] parity error detected. See also DFA_DTCFADR, which contains the failing
+                                                         addresses for the internal node cache RAMs. */
+	uint64_t dc1perr                      : 3;  /**< Cluster 1 RAM[3:1] parity error detected. See also DFA_DTCFADR, which contains the failing
+                                                         addresses for the internal node cache RAMs. */
+	uint64_t dc0perr                      : 3;  /**< Cluster 0 RAM[3:1] parity error detected. See also DFA_DTCFADR register, which contains
+                                                         the failing addresses for the graph-cache RAMs. */
+	uint64_t dblovf                       : 1;  /**< Doorbell overflow detected - status bit. When set, the 20b accumulated doorbell register
+                                                         had overflowed (software wrote too many doorbell requests). If the DBLINA had previously
+                                                         been enabled (set), an interrupt will be posted. Software can clear the interrupt by
+                                                         writing a 1 to this register bit.
+                                                         Detection of a doorbell register overflow is a catastrophic error that may leave the HFA
+                                                         hardware in an unrecoverable state. */
+#else
+	uint64_t dblovf                       : 1;
+	uint64_t dc0perr                      : 3;
+	uint64_t dc1perr                      : 3;
+	uint64_t dc2perr                      : 3;
+	uint64_t dc3perr                      : 3;
+	uint64_t dlc0_ovferr                  : 1;
+	uint64_t dlc1_ovferr                  : 1;
+	uint64_t reserved_15_15               : 1;
+	uint64_t cndrd                        : 1;
+	uint64_t dfanxm                       : 1;
+	uint64_t replerr                      : 1;
+	uint64_t osmerr                       : 1;
+	uint64_t reserved_20_63               : 44;
+#endif
+	} s;
+	struct cvmx_dfa_error_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_19_63               : 45;
+	uint64_t replerr                      : 1;  /**< DFA Illegal Replication Factor Error
+                                                         For o68: DFA only supports 1x, 2x, and 4x port replication.
+                                                         Legal configurations for memory are to support 2 port or
+                                                         4 port configurations.
+                                                         The REPLERR interrupt will be set in the following illegal
+                                                         configuration cases:
+                                                             1) An 8x replication factor is detected for any memory reference.
+                                                             2) A 4x replication factor is detected for any memory reference
+                                                                when only 2 memory ports are enabled.
+                                                         NOTE: If REPLERR is set during a DFA Graph Walk operation,
+                                                         then the walk will prematurely terminate with RWORD0[REA]=ERR.
+                                                         If REPLERR is set during a NCB-Direct CSR read access to DFA
+                                                         Memory REGION, then the CSR read response data is UNPREDICTABLE. */
+	uint64_t dfanxm                       : 1;  /**< DFA Non-existent Memory Access
+                                                         For o68/o61: DTEs (and backdoor CSR DFA Memory REGION reads)
+                                                         have access to the following 38bit L2/DRAM address space
+                                                         which maps to a 37bit physical DDR3 SDRAM address space.
+                                                         see:
+                                                         DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF
+                                                                 maps to lower 256MB of physical DDR3 SDRAM
+                                                         DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF
+                                                                 maps to upper 127.75GB of DDR3 SDRAM
+                                                                    L2/DRAM address space                     Physical DDR3 SDRAM Address space
+                                                                      (38bit address)                           (37bit address)
+                                                                       +-----------+ 0x0020.0FFF.FFFF
+                                                                       |
+                                                                      ===   DR1   ===                          +-----------+ 0x001F.FFFF.FFFF
+                                                          (128GB-256MB)|           |                           |
+                                                                       |           |                     =>    |           |  (128GB-256MB)
+                                                                       +-----------+ 0x0000.1FFF.FFFF          |   DR1
+                                                               256MB   |   HOLE    |   (DO NOT USE)            |
+                                                                       +-----------+ 0x0000.0FFF.FFFF          +-----------+ 0x0000.0FFF.FFFF
+                                                               256MB   |    DR0    |                           |   DR0     |   (256MB)
+                                                                       +-----------+ 0x0000.0000.0000          +-----------+ 0x0000.0000.0000
+                                                         In the event the DFA generates a reference to the L2/DRAM
+                                                         address hole (0x0000.0FFF.FFFF - 0x0000.1FFF.FFFF) or to
+                                                         an address above 0x0020.0FFF.FFFF, the DFANXM programmable
+                                                         interrupt bit will be set.
+                                                         SWNOTE: Both the 1) SW DFA Graph compiler and the 2) SW NCB-Direct CSR
+                                                         accesses to DFA Memory REGION MUST avoid making references
+                                                         to these non-existent memory regions.
+                                                         NOTE: If DFANXM is set during a DFA Graph Walk operation,
+                                                         then the walk will prematurely terminate with RWORD0[REA]=ERR.
+                                                         If DFANXM is set during a NCB-Direct CSR read access to DFA
+                                                         Memory REGION, then the CSR read response data is forced to
+                                                         128'hBADE_FEED_DEAD_BEEF_FACE_CAFE_BEAD_C0DE. (NOTE: the QW
+                                                         being accessed, either the upper or lower QW will be returned). */
+	uint64_t cndrd                        : 1;  /**< If any of the cluster's detected a Parity error on RAM1
+                                                         this additional bit further specifies that the
+                                                         RAM1 parity error was detected during a CND-RD
+                                                         (Cache Node Metadata Read).
+
+                                                         For CNDRD Parity Error, the previous CNA arc fetch
+                                                         information is written to RWORD1+ as follows:
+                                                            RWORD1+[NTYPE]=MNODE
+                                                            RWORD1+[NDNID]=cna.ndnid
+                                                            RWORD1+[NHMSK]=cna.hmsk
+                                                            RWORD1+[NNPTR]=cna.nnptr[13:0]
+                                                         NOTE: This bit is set if ANY node cluster's RAM1 accesses
+                                                         detect a CNDRD error. */
+	uint64_t reserved_14_15               : 2;
+	uint64_t dlc0_ovferr                  : 1;  /**< DLC0 Fifo Overflow Error Detected
+                                                         This condition should NEVER architecturally occur, and
+                                                         is here in case HW credit/debit scheme is not working. */
+	uint64_t reserved_4_12                : 9;
+	uint64_t dc0perr                      : 3;  /**< Cluster#0 RAM[3:1] Parity Error Detected
+                                                         See also DFA_DTCFADR register which contains the
+                                                         failing addresses for the internal node cache RAMs. */
+	uint64_t dblovf                       : 1;  /**< Doorbell Overflow detected - Status bit
+                                                         When set, the 20b accumulated doorbell register
+                                                         had overflowed (SW wrote too many doorbell requests).
+                                                         If the DBLINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         NOTE: Detection of a Doorbell Register overflow
+                                                         is a catastrophic error which may leave the DFA
+                                                         HW in an unrecoverable state. */
+#else
+	uint64_t dblovf                       : 1;
+	uint64_t dc0perr                      : 3;
+	uint64_t reserved_4_12                : 9;
+	uint64_t dlc0_ovferr                  : 1;
+	uint64_t reserved_14_15               : 2;
+	uint64_t cndrd                        : 1;
+	uint64_t dfanxm                       : 1;
+	uint64_t replerr                      : 1;
+	uint64_t reserved_19_63               : 45;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_error_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_17_63               : 47;
+	uint64_t cndrd                        : 1;  /**< If DC0PERR[0]=1 indicating a RAM1 Parity error,
+                                                         this additional bit further specifies that the
+                                                         RAM1 parity error was detected during a CND-RD
+                                                         (Cache Node Metadata Read).
+
+                                                         For CNDRD Parity Error, the previous CNA arc fetch
+                                                         information is written to RWORD1+ as follows:
+                                                            RWORD1+[NTYPE]=MNODE
+                                                            RWORD1+[NDNID]=cna.ndnid
+                                                            RWORD1+[NHMSK]=cna.hmsk
+                                                            RWORD1+[NNPTR]=cna.nnptr[13:0] */
+	uint64_t reserved_4_15                : 12;
+	uint64_t dc0perr                      : 3;  /**< RAM[3:1] Parity Error Detected from Node Cluster \#0
+                                                         See also DFA_DTCFADR register which contains the
+                                                         failing addresses for the internal node cache RAMs. */
+	uint64_t dblovf                       : 1;  /**< Doorbell Overflow detected - Status bit
+                                                         When set, the 20b accumulated doorbell register
+                                                         had overflowed (SW wrote too many doorbell requests).
+                                                         If the DBLINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         NOTE: Detection of a Doorbell Register overflow
+                                                         is a catastrophic error which may leave the DFA
+                                                         HW in an unrecoverable state. */
+#else
+	uint64_t dblovf                       : 1;
+	uint64_t dc0perr                      : 3;
+	uint64_t reserved_4_15                : 12;
+	uint64_t cndrd                        : 1;
+	uint64_t reserved_17_63               : 47;
+#endif
+	} cn63xx;
+	struct cvmx_dfa_error_cn63xx          cn63xxp1;
+	struct cvmx_dfa_error_cn63xx          cn66xx;
+	struct cvmx_dfa_error_cn68xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_19_63               : 45;
+	uint64_t replerr                      : 1;  /**< DFA Illegal Replication Factor Error
+                                                         For o68: DFA only supports 1x, 2x, and 4x port replication.
+                                                         Legal configurations for memory are to support 2 port or
+                                                         4 port configurations.
+                                                         The REPLERR interrupt will be set in the following illegal
+                                                         configuration cases:
+                                                             1) An 8x replication factor is detected for any memory reference.
+                                                             2) A 4x replication factor is detected for any memory reference
+                                                                when only 2 memory ports are enabled.
+                                                         NOTE: If REPLERR is set during a DFA Graph Walk operation,
+                                                         then the walk will prematurely terminate with RWORD0[REA]=ERR.
+                                                         If REPLERR is set during a NCB-Direct CSR read access to DFA
+                                                         Memory REGION, then the CSR read response data is UNPREDICTABLE. */
+	uint64_t dfanxm                       : 1;  /**< DFA Non-existent Memory Access
+                                                         For o68: DTEs (and backdoor CSR DFA Memory REGION reads)
+                                                         have access to the following 38bit L2/DRAM address space
+                                                         which maps to a 37bit physical DDR3 SDRAM address space.
+                                                         see:
+                                                         DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF
+                                                                 maps to lower 256MB of physical DDR3 SDRAM
+                                                         DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF
+                                                                 maps to upper 127.75GB of DDR3 SDRAM
+                                                                    L2/DRAM address space                     Physical DDR3 SDRAM Address space
+                                                                      (38bit address)                           (37bit address)
+                                                                       +-----------+ 0x0020.0FFF.FFFF
+                                                                       |
+                                                                      ===   DR1   ===                          +-----------+ 0x001F.FFFF.FFFF
+                                                          (128GB-256MB)|           |                           |
+                                                                       |           |                     =>    |           |  (128GB-256MB)
+                                                                       +-----------+ 0x0000.1FFF.FFFF          |   DR1
+                                                               256MB   |   HOLE    |   (DO NOT USE)            |
+                                                                       +-----------+ 0x0000.0FFF.FFFF          +-----------+ 0x0000.0FFF.FFFF
+                                                               256MB   |    DR0    |                           |   DR0     |   (256MB)
+                                                                       +-----------+ 0x0000.0000.0000          +-----------+ 0x0000.0000.0000
+                                                         In the event the DFA generates a reference to the L2/DRAM
+                                                         address hole (0x0000.0FFF.FFFF - 0x0000.1FFF.FFFF) or to
+                                                         an address above 0x0020.0FFF.FFFF, the DFANXM programmable
+                                                         interrupt bit will be set.
+                                                         SWNOTE: Both the 1) SW DFA Graph compiler and the 2) SW NCB-Direct CSR
+                                                         accesses to DFA Memory REGION MUST avoid making references
+                                                         to these non-existent memory regions.
+                                                         NOTE: If DFANXM is set during a DFA Graph Walk operation,
+                                                         then the walk will prematurely terminate with RWORD0[REA]=ERR.
+                                                         If DFANXM is set during a NCB-Direct CSR read access to DFA
+                                                         Memory REGION, then the CSR read response data is forced to
+                                                         128'hBADE_FEED_DEAD_BEEF_FACE_CAFE_BEAD_C0DE. (NOTE: the QW
+                                                         being accessed, either the upper or lower QW will be returned). */
+	uint64_t cndrd                        : 1;  /**< If Any of the cluster's detected a Parity error on RAM1
+                                                         this additional bit further specifies that the
+                                                         RAM1 parity error was detected during a CND-RD
+                                                         (Cache Node Metadata Read).
+
+                                                         For CNDRD Parity Error, the previous CNA arc fetch
+                                                         information is written to RWORD1+ as follows:
+                                                            RWORD1+[NTYPE]=MNODE
+                                                            RWORD1+[NDNID]=cna.ndnid
+                                                            RWORD1+[NHMSK]=cna.hmsk
+                                                            RWORD1+[NNPTR]=cna.nnptr[13:0]
+                                                         NOTE: This bit is set if ANY node cluster's RAM1 accesses
+                                                         detect a CNDRD error. */
+	uint64_t reserved_15_15               : 1;
+	uint64_t dlc1_ovferr                  : 1;  /**< DLC1 Fifo Overflow Error Detected
+                                                         This condition should NEVER architecturally occur, and
+                                                         is here in case HW credit/debit scheme is not working. */
+	uint64_t dlc0_ovferr                  : 1;  /**< DLC0 Fifo Overflow Error Detected
+                                                         This condition should NEVER architecturally occur, and
+                                                         is here in case HW credit/debit scheme is not working. */
+	uint64_t reserved_10_12               : 3;
+	uint64_t dc2perr                      : 3;  /**< Cluster#2 RAM[3:1] Parity Error Detected
+                                                         See also DFA_DTCFADR register which contains the
+                                                         failing addresses for the internal node cache RAMs. */
+	uint64_t dc1perr                      : 3;  /**< Cluster#1 RAM[3:1] Parity Error Detected
+                                                         See also DFA_DTCFADR register which contains the
+                                                         failing addresses for the internal node cache RAMs. */
+	uint64_t dc0perr                      : 3;  /**< Cluster#0 RAM[3:1] Parity Error Detected
+                                                         See also DFA_DTCFADR register which contains the
+                                                         failing addresses for the internal node cache RAMs. */
+	uint64_t dblovf                       : 1;  /**< Doorbell Overflow detected - Status bit
+                                                         When set, the 20b accumulated doorbell register
+                                                         had overflowed (SW wrote too many doorbell requests).
+                                                         If the DBLINA had previously been enabled(set),
+                                                         an interrupt will be posted. Software can clear
+                                                         the interrupt by writing a 1 to this register bit.
+                                                         NOTE: Detection of a Doorbell Register overflow
+                                                         is a catastrophic error which may leave the DFA
+                                                         HW in an unrecoverable state. */
+#else
+	uint64_t dblovf                       : 1;
+	uint64_t dc0perr                      : 3;
+	uint64_t dc1perr                      : 3;
+	uint64_t dc2perr                      : 3;
+	uint64_t reserved_10_12               : 3;
+	uint64_t dlc0_ovferr                  : 1;
+	uint64_t dlc1_ovferr                  : 1;
+	uint64_t reserved_15_15               : 1;
+	uint64_t cndrd                        : 1;
+	uint64_t dfanxm                       : 1;
+	uint64_t replerr                      : 1;
+	uint64_t reserved_19_63               : 45;
+#endif
+	} cn68xx;
+	struct cvmx_dfa_error_cn68xx          cn68xxp1;
+	struct cvmx_dfa_error_cn61xx          cn70xx;
+	struct cvmx_dfa_error_s               cn78xx;
+};
+typedef union cvmx_dfa_error cvmx_dfa_error_t;
+
+/**
+ * cvmx_dfa_intmsk
+ *
+ * Description:
+ *
+ */
+union cvmx_dfa_intmsk {
+	uint64_t u64;
+	struct cvmx_dfa_intmsk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_19_63               : 45;
+	uint64_t replerrena                   : 1;  /**< DFA Illegal Replication Factor Interrupt Enable */
+	uint64_t dfanxmena                    : 1;  /**< DFA Non-existent Memory Access Interrupt Enable */
+	uint64_t reserved_15_16               : 2;
+	uint64_t dlc1_ovfena                  : 1;  /**< DLC1 Fifo Overflow Error Interrupt Enable */
+	uint64_t dlc0_ovfena                  : 1;  /**< DLC0 Fifo Overflow Error Interrupt Enable */
+	uint64_t reserved_10_12               : 3;
+	uint64_t dc2pena                      : 3;  /**< RAM[3:1] Parity Error Enabled Node Cluster \#2 */
+	uint64_t dc1pena                      : 3;  /**< RAM[3:1] Parity Error Enabled Node Cluster \#1 */
+	uint64_t dc0pena                      : 3;  /**< "RAM[3:1] Parity Error Enabled Node Cluster \#0" */
+	uint64_t dblina                       : 1;  /**< Doorbell Overflow Interrupt Enable bit.
+                                                         When set, doorbell overflow conditions are reported. */
+#else
+	uint64_t dblina                       : 1;
+	uint64_t dc0pena                      : 3;
+	uint64_t dc1pena                      : 3;
+	uint64_t dc2pena                      : 3;
+	uint64_t reserved_10_12               : 3;
+	uint64_t dlc0_ovfena                  : 1;
+	uint64_t dlc1_ovfena                  : 1;
+	uint64_t reserved_15_16               : 2;
+	uint64_t dfanxmena                    : 1;
+	uint64_t replerrena                   : 1;
+	uint64_t reserved_19_63               : 45;
+#endif
+	} s;
+	struct cvmx_dfa_intmsk_cn61xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_19_63               : 45;
+	uint64_t replerrena                   : 1;  /**< DFA Illegal Replication Factor Interrupt Enable */
+	uint64_t dfanxmena                    : 1;  /**< DFA Non-existent Memory Access Interrupt Enable */
+	uint64_t reserved_14_16               : 3;
+	uint64_t dlc0_ovfena                  : 1;  /**< DLC0 Fifo Overflow Error Interrupt Enable */
+	uint64_t reserved_4_12                : 9;
+	uint64_t dc0pena                      : 3;  /**< RAM[3:1] Parity Error Enabled Node Cluster \#0 */
+	uint64_t dblina                       : 1;  /**< Doorbell Overflow Interrupt Enable bit.
+                                                         When set, doorbell overflow conditions are reported. */
+#else
+	uint64_t dblina                       : 1;
+	uint64_t dc0pena                      : 3;
+	uint64_t reserved_4_12                : 9;
+	uint64_t dlc0_ovfena                  : 1;
+	uint64_t reserved_14_16               : 3;
+	uint64_t dfanxmena                    : 1;
+	uint64_t replerrena                   : 1;
+	uint64_t reserved_19_63               : 45;
+#endif
+	} cn61xx;
+	struct cvmx_dfa_intmsk_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t dc0pena                      : 3;  /**< RAM[3:1] Parity Error Enabled Node Cluster \#0 */
+	uint64_t dblina                       : 1;  /**< Doorbell Overflow Interrupt Enable bit.
+                                                         When set, doorbell overflow conditions are reported. */
+#else
+	uint64_t dblina                       : 1;
+	uint64_t dc0pena                      : 3;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} cn63xx;
+	struct cvmx_dfa_intmsk_cn63xx         cn63xxp1;
+	struct cvmx_dfa_intmsk_cn63xx         cn66xx;
+	struct cvmx_dfa_intmsk_s              cn68xx;
+	struct cvmx_dfa_intmsk_s              cn68xxp1;
+	struct cvmx_dfa_intmsk_cn61xx         cn70xx;
+};
+typedef union cvmx_dfa_intmsk cvmx_dfa_intmsk_t;
+
+/**
+ * cvmx_dfa_memcfg0
+ *
+ * DFA_MEMCFG0 = DFA Memory Configuration
+ *
+ * Description:
+ */
+union cvmx_dfa_memcfg0 {
+	uint64_t u64;
+	struct cvmx_dfa_memcfg0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_32_63               : 32;
+	uint64_t rldqck90_rst                 : 1;  /**< RLDCK90 and RLDQK90 DLL SW Reset
+                                                         When written with a '1' the RLDCK90 and RLDQK90 DLL are
+                                                         in soft-reset. */
+	uint64_t rldck_rst                    : 1;  /**< RLDCK Zero Delay DLL(Clock Generator) SW Reset
+                                                         When written with a '1' the RLDCK zero delay DLL is in
+                                                         soft-reset. */
+	uint64_t clkdiv                       : 2;  /**< RLDCLK Divisor Select
+                                                           - 0: RLDx_CK_H/L = Core Clock /2
+                                                           - 1: RESERVED (must not be used)
+                                                           - 2: RLDx_CK_H/L = Core Clock /3
+                                                           - 3: RLDx_CK_H/L = Core Clock /4
+                                                         The DFA LLM interface(s) are tied to the core clock
+                                                         frequency through this programmable clock divisor.
+                                                         Examples:
+                                                            Core Clock(MHz) | DFA-LLM Clock(MHz) | CLKDIV
+                                                           -----------------+--------------------+--------
+                                                                 800        |    400/(800-DDR)   |  /2
+                                                                1000        |    333/(666-DDR)   |  /3
+                                                                 800        |    200/(400-DDR)   |  /4
+                                                         NOTE: This value MUST BE programmed BEFORE doing a
+                                                         Hardware init sequence (see: DFA_MEMCFG0[INIT_Px] bits). */
+	uint64_t lpp_ena                      : 1;  /**< PP Linear Port Addressing Mode Enable
+                                                         When enabled, PP-core LLM accesses to the lower-512MB
+                                                         LLM address space are sent to the single DFA port
+                                                         which is enabled. NOTE: If LPP_ENA=1, only
+                                                         one DFA RLDRAM port may be enabled for RLDRAM accesses
+                                                         (ie: ENA_P0 and ENA_P1 CAN NEVER BOTH be set).
+                                                         PP-core LLM accesses to the upper-512MB LLM address
+                                                         space are sent to the other 'disabled' DFA port.
+                                                         SW RESTRICTION: If LPP_ENA=1, then only one DFA port
+                                                         may be enabled for RLDRAM accesses (ie: ENA_P0 and
+                                                         ENA_P1 CAN NEVER BOTH be set).
+                                                         NOTE: This bit is used to allow PP-Core LLM accesses to a
+                                                         disabled port, such that each port can be sequentially
+                                                         addressed (ie: disable LW address interleaving).
+                                                         Enabling this bit allows BOTH PORTs to be active and
+                                                         sequentially addressable. The single port that is
+                                                         enabled(ENA_Px) will respond to the low-512MB LLM address
+                                                         space, and the other 'disabled' port will respond to the
+                                                         high-512MB LLM address space.
+                                                         Example usage:
+                                                            - DFA RLD0 pins used for TCAM-FPGA(CP2 accesses)
+                                                            - DFA RLD1 pins used for RLDRAM (DTE/CP2 accesses).
+                                                         USAGE NOTE:
+                                                         If LPP_ENA=1 and SW DOES NOT initialize the disabled port
+                                                         (ie: INIT_Px=0->1), then refreshes and the HW init
+                                                         sequence WILL NOT occur for the disabled port.
+                                                         If LPP_ENA=1 and SW does initialize the disabled port
+                                                         (INIT_Px=0->1 with ENA_Px=0), then refreshes and
+                                                         the HW init sequence WILL occur to the disabled port. */
+	uint64_t bunk_init                    : 2;  /**< Controls the CS_N[1:0] during a) a HW Initialization
+                                                         sequence (triggered by DFA_MEMCFG0[INIT_Px]) or
+                                                         b) during a normal refresh sequence. If
+                                                         the BNK_INIT[x]=1, the corresponding CS_N[x] is driven.
+                                                         NOTE: This is required for DRAM used in a
+                                                         clamshell configuration, since the address lines
+                                                         carry Mode Register write data that is unique
+                                                         per bunk(or clam). In a clamshell configuration,
+                                                         The N3K A[x] pin may be tied into Clam#0's A[x]
+                                                         and also into Clam#1's 'mirrored' address bit A[y]
+                                                         (eg: Clam0 sees A[5] and Clam1 sees A[15]).
+                                                         To support clamshell designs, SW must initiate
+                                                         two separate HW init sequences for the two bunks
+                                                         (or clams) . Before each HW init sequence is triggered,
+                                                         SW must preload the DFA_MEMRLD[22:0] with the data
+                                                         that will be driven onto the A[22:0] wires during
+                                                         an MRS mode register write.
+                                                         NOTE: After the final HW initialization sequence has
+                                                         been triggered, SW must wait 64K eclks before writing
+                                                         the BUNK_INIT[1:0] field = 3'b11 (so that CS_N[1:0] is
+                                                         driven during refresh sequences in normal operation.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t init_p0                      : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for Memory Port \#0 is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Set up the DFA_MEMCFG0[CLKDIV] ratio for intended
+                                                              RLDRAM operation.
+                                                                [legal values 0: DIV2 2: DIV3 3: DIV4]
+                                                           2) Write a '1' into BOTH the DFA_MEM_CFG0[RLDCK_RST]
+                                                              and DFA_MEM_CFG0[RLDQCK90_RST] field at
+                                                              the SAME TIME. This step puts all three DLLs in
+                                                              SW reset (RLDCK, RLDCK90, RLDQK90 DLLs).
+                                                           3) Write a '0' into the DFA_MEM_CFG0[RLDCK_RST] field.
+                                                              This step takes the RLDCK DLL out of soft-reset so
+                                                              that the DLL can generate the RLDx_CK_H/L clock pins.
+                                                           4) Wait 1ms (for RLDCK DLL to achieve lock)
+                                                           5) Write a '0' into DFA_MEM_CFG0[RLDQCK90_RST] field.
+                                                              This step takes the RLDCK90 DLL AND RLDQK90 DLL out
+                                                              of soft-reset.
+                                                           6) Wait 1ms (for RLDCK90/RLDQK90 DLLs to achieve lock)
+                                                           7) Enable memory port(s):  ENA_P0=1/ENA_P1=1
+                                                           8) Wait 100us (to ensure a stable clock
+                                                              to the RLDRAMs) - as per RLDRAM spec.
+                                                           - - - - - Hardware Initialization Sequence - - - - -
+                                                           9) Setup the DFA_MEMCFG0[BUNK_INIT] for the bunk(s)
+                                                              intended to be initialized.
+                                                          10) Write a '1' to the corresponding INIT_Px which
+                                                              will initiate a hardware initialization
+                                                              sequence to that'specific' port.
+                                                          11) Wait (DFA_MEMCFG0[CLKDIV] * 32K) eclk cycles.
+                                                              [to ensure the HW init sequence has completed
+                                                              before writing to ANY of the DFA_MEM* registers]
+                                                           - - - - - Hardware Initialization Sequence - - - - -
+                                                          12) Write the DFA_MEMCFG0[BUNK_INIT]=3 to enable
+                                                              refreshes to BOTH bunks.
+                                                         NOTE: In some cases (where the address wires are routed
+                                                         differently between the front and back 'bunks'),
+                                                         SW will need to use DFA_MEMCFG0[BUNK_INIT] bits to
+                                                         control the Hardware initialization sequence for a
+                                                         'specific bunk'. In these cases, SW would setup the
+                                                         BUNK_INIT and repeat Steps \#9-11 for each bunk/port.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: DFA Memory Port#0 corresponds to the Octeon
+                                                         RLD0_* pins. */
+	uint64_t init_p1                      : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for Memory Port \#1 is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Set up the DFA_MEMCFG0[CLKDIV] ratio for intended
+                                                              RLDRAM operation.
+                                                                [legal values 0: DIV2 2: DIV3 3: DIV4]
+                                                           2) Write a '1' into BOTH the DFA_MEM_CFG0[RLDCK_RST]
+                                                              and DFA_MEM_CFG0[RLDQCK90_RST] field at
+                                                              the SAME TIME. This step puts all three DLLs in
+                                                              SW reset (RLDCK, RLDCK90, RLDQK90 DLLs).
+                                                           3) Write a '0' into the DFA_MEM_CFG0[RLDCK_RST] field.
+                                                              This step takes the RLDCK DLL out of soft-reset so
+                                                              that the DLL can generate the RLDx_CK_H/L clock pins.
+                                                           4) Wait 1ms (for RLDCK DLL to achieve lock)
+                                                           5) Write a '0' into DFA_MEM_CFG0[RLDQCK90_RST] field.
+                                                              This step takes the RLDCK90 DLL AND RLDQK90 DLL out
+                                                              of soft-reset.
+                                                           6) Wait 1ms (for RLDCK90/RLDQK90 DLLs to achieve lock)
+                                                           7) Enable memory port(s) ENA_P0=1/ENA_P1=1
+                                                           8) Wait 100us (to ensure a stable clock
+                                                              to the RLDRAMs) - as per RLDRAM spec.
+                                                           - - - - - Hardware Initialization Sequence - - - - -
+                                                           9) Setup the DFA_MEMCFG0[BUNK_INIT] for the bunk(s)
+                                                              intended to be initialized.
+                                                          10) Write a '1' to the corresponding INIT_Px which
+                                                              will initiate a hardware initialization
+                                                              sequence to that'specific' port.
+                                                          11) Wait (DFA_MEMCFG0[CLKDIV] * 32K) eclk cycles.
+                                                              [to ensure the HW init sequence has completed
+                                                              before writing to ANY of the DFA_MEM* registers]
+                                                           - - - - - Hardware Initialization Sequence - - - - -
+                                                          12) Write the DFA_MEMCFG0[BUNK_INIT]=3 to enable
+                                                              refreshes to BOTH bunks.
+                                                         NOTE: In some cases (where the address wires are routed
+                                                         differently between the front and back 'bunks'),
+                                                         SW will need to use DFA_MEMCFG0[BUNK_INIT] bits to
+                                                         control the Hardware initialization sequence for a
+                                                         'specific bunk'. In these cases, SW would setup the
+                                                         BUNK_INIT and repeat Steps \#9-11 for each bunk/port.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: DFA Memory Port#1 corresponds to the Octeon
+                                                         RLD1_* pins. */
+	uint64_t r2r_pbunk                    : 1;  /**< When enabled, an additional command bubble is inserted
+                                                         if back to back reads are issued to different physical
+                                                         bunks. This is to avoid DQ data bus collisions when
+                                                         references cross between physical bunks.
+                                                         [NOTE: the physical bunk address boundary is determined
+                                                         by the PBUNK bit].
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t pbunk                        : 3;  /**< Physical Bunk address bit pointer.
+                                                         Specifies which address bit within the Longword
+                                                         Memory address MA[23:0] is used to determine the
+                                                         chip selects.
+                                                         [RLD_CS0_N corresponds to physical bunk \#0, and
+                                                         RLD_CS1_N corresponds to physical bunk \#1].
+                                                           - 000: CS0_N = MA[19]/CS1_N = !MA[19]
+                                                           - 001: CS0_N = MA[20]/CS1_N = !MA[20]
+                                                           - 010: CS0_N = MA[21]/CS1_N = !MA[21]
+                                                           - 011: CS0_N = MA[22]/CS1_N = !MA[22]
+                                                           - 100: CS0_N = MA[23]/CS1_N = !MA[23]
+                                                           - 101-111: CS0_N = 0 /CS1_N = 1
+                                                         Example(s):
+                                                         To build out a 128MB DFA memory, 4x 32Mx9
+                                                         parts could be used to fill out TWO physical
+                                                         bunks (clamshell configuration). Each (of the
+                                                         two) physical bunks contains 2x 32Mx9 = 16Mx36.
+                                                         Each RLDRAM device also contains 8 internal banks,
+                                                         therefore the memory Address is 16M/8banks = 2M
+                                                         addresses/bunk (2^21). In this case, MA[21] would
+                                                         select the physical bunk.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         be used to determine the Chip Select(s). */
+	uint64_t blen                         : 1;  /**< Device Burst Length  (0=2-burst/1=4-burst)
+                                                         NOTE: RLDRAM-II MUST USE BLEN=0(2-burst) */
+	uint64_t bprch                        : 2;  /**< Tristate Enable (back porch) (\#dclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable back porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t fprch                        : 2;  /**< Tristate Enable (front porch) (\#dclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable front porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t wr_dly                       : 4;  /**< Write->Read CMD Delay (\#mclks):
+                                                         Determines \#mclk cycles to insert when controller
+                                                         switches from write to read. This allows programmer
+                                                         to control the data bus contention.
+                                                         For RLDRAM-II(BL2): (TBL=1)
+                                                         WR_DLY = ROUND_UP[((TWL+TBL)*2 - TSKW + FPRCH) / 2] - TRL + 1
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For aggressive(performance optimal) designs,
+                                                         the WR_DLY 'may' be tuned down(-1) if bus fight
+                                                         on W->R transitions is not pronounced. */
+	uint64_t rw_dly                       : 4;  /**< Read->Write CMD Delay (\#mclks):
+                                                         Determines \#mclk cycles to insert when controller
+                                                         switches from read to write. This allows programmer
+                                                         to control the data bus contention.
+                                                         For RLDRAM-II(BL2): (TBL=1)
+                                                         RW_DLY = ROUND_UP[((TRL+TBL)*2 + TSKW + BPRCH+2)/2] - TWL + 1
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For aggressive(performance optimal) designs,
+                                                         the RW_DLY 'may' be tuned down(-1) if bus fight
+                                                         on R->W transitions is not pronounced. */
+	uint64_t sil_lat                      : 2;  /**< Silo Latency (\#dclks): On reads, determines how many
+                                                         additional dclks to wait (on top of tRL+1) before
+                                                         pulling data out of the padring silos used for time
+                                                         domain boundary crossing.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t mtype                        : 1;  /**< FCRAM-II Memory Type
+                                                         *** CN58XX UNSUPPORTED *** */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t ena_p0                       : 1;  /**< Enable DFA RLDRAM Port#0
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for memory port \#0.
+                                                         NOTE: a customer is at
+                                                         liberty to enable either Port#0 or Port#1 or both.
+                                                         NOTE: Once a port has been disabled, it MUST NEVER
+                                                         be re-enabled. [the only way to enable a port is
+                                                         through a chip reset].
+                                                         NOTE: DFA Memory Port#0 corresponds to the Octeon
+                                                         RLD0_* pins. */
+	uint64_t ena_p1                       : 1;  /**< Enable DFA RLDRAM Port#1
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for memory port \#1.
+                                                         NOTE: a customer is at
+                                                         liberty to enable either Port#0 or Port#1 or both.
+                                                         NOTE: Once a port has been disabled, it MUST NEVER
+                                                         be re-enabled. [the only way to enable a port is
+                                                         through a chip reset].
+                                                         NOTE: DFA Memory Port#1 corresponds to the Octeon
+                                                         RLD1_* pins. */
+#else
+	uint64_t ena_p1                       : 1;
+	uint64_t ena_p0                       : 1;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mtype                        : 1;
+	uint64_t sil_lat                      : 2;
+	uint64_t rw_dly                       : 4;
+	uint64_t wr_dly                       : 4;
+	uint64_t fprch                        : 2;
+	uint64_t bprch                        : 2;
+	uint64_t blen                         : 1;
+	uint64_t pbunk                        : 3;
+	uint64_t r2r_pbunk                    : 1;
+	uint64_t init_p1                      : 1;
+	uint64_t init_p0                      : 1;
+	uint64_t bunk_init                    : 2;
+	uint64_t lpp_ena                      : 1;
+	uint64_t clkdiv                       : 2;
+	uint64_t rldck_rst                    : 1;
+	uint64_t rldqck90_rst                 : 1;
+	uint64_t reserved_32_63               : 32;
+#endif
+	} s;
+	struct cvmx_dfa_memcfg0_cn38xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_28_63               : 36;
+	uint64_t lpp_ena                      : 1;  /**< PP Linear Port Addressing Mode Enable
+                                                         When enabled, PP-core LLM accesses to the lower-512MB
+                                                         LLM address space are sent to the single DFA port
+                                                         which is enabled. NOTE: If LPP_ENA=1, only
+                                                         one DFA RLDRAM port may be enabled for RLDRAM accesses
+                                                         (ie: ENA_P0 and ENA_P1 CAN NEVER BOTH be set).
+                                                         PP-core LLM accesses to the upper-512MB LLM address
+                                                         space are sent to the other 'disabled' DFA port.
+                                                         SW RESTRICTION: If LPP_ENA=1, then only one DFA port
+                                                         may be enabled for RLDRAM accesses (ie: ENA_P0 and
+                                                         ENA_P1 CAN NEVER BOTH be set).
+                                                         NOTE: This bit is used to allow PP-Core LLM accesses to a
+                                                         disabled port, such that each port can be sequentially
+                                                         addressed (ie: disable LW address interleaving).
+                                                         Enabling this bit allows BOTH PORTs to be active and
+                                                         sequentially addressable. The single port that is
+                                                         enabled(ENA_Px) will respond to the low-512MB LLM address
+                                                         space, and the other 'disabled' port will respond to the
+                                                         high-512MB LLM address space.
+                                                         Example usage:
+                                                            - DFA RLD0 pins used for TCAM-FPGA(CP2 accesses)
+                                                            - DFA RLD1 pins used for RLDRAM (DTE/CP2 accesses).
+                                                         USAGE NOTE:
+                                                         If LPP_ENA=1 and SW DOES NOT initialize the disabled port
+                                                         (ie: INIT_Px=0->1), then refreshes and the HW init
+                                                         sequence WILL NOT occur for the disabled port.
+                                                         If LPP_ENA=1 and SW does initialize the disabled port
+                                                         (INIT_Px=0->1 with ENA_Px=0), then refreshes and
+                                                         the HW init sequence WILL occur to the disabled port. */
+	uint64_t bunk_init                    : 2;  /**< Controls the CS_N[1:0] during a) a HW Initialization
+                                                         sequence (triggered by DFA_MEMCFG0[INIT_Px]) or
+                                                         b) during a normal refresh sequence. If
+                                                         the BNK_INIT[x]=1, the corresponding CS_N[x] is driven.
+                                                         NOTE: This is required for DRAM used in a
+                                                         clamshell configuration, since the address lines
+                                                         carry Mode Register write data that is unique
+                                                         per bunk(or clam). In a clamshell configuration,
+                                                         The N3K A[x] pin may be tied into Clam#0's A[x]
+                                                         and also into Clam#1's 'mirrored' address bit A[y]
+                                                         (eg: Clam0 sees A[5] and Clam1 sees A[15]).
+                                                         To support clamshell designs, SW must initiate
+                                                         two separate HW init sequences for the two bunks
+                                                         (or clams) . Before each HW init sequence is triggered,
+                                                         SW must preload the DFA_MEMRLD[22:0] with the data
+                                                         that will be driven onto the A[22:0] wires during
+                                                         an MRS mode register write.
+                                                         NOTE: After the final HW initialization sequence has
+                                                         been triggered, SW must wait 64K eclks before writing
+                                                         the BUNK_INIT[1:0] field = 3'b11 (so that CS_N[1:0] is
+                                                         driven during refresh sequences in normal operation.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For MTYPE=1(FCRAM) Mode, each bunk MUST BE
+                                                         initialized independently. In other words, a HW init
+                                                         must be done for Bunk#0, and then another HW init
+                                                         must be done for Bunk#1 at power-on. */
+	uint64_t init_p0                      : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for Memory Port \#0 is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Enable memory port(s):
+                                                               a) ENA_P1=1 (single port in pass 1) OR
+                                                               b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)
+                                                           2) Wait 100us (to ensure a stable clock
+                                                              to the RLDRAMs) - as per RLDRAM spec.
+                                                           3) Write a '1' to the corresponding INIT_Px which
+                                                              will initiate a hardware initialization
+                                                              sequence.
+                                                         NOTE: After writing a '1', SW must wait 64K eclk
+                                                         cycles to ensure the HW init sequence has completed
+                                                         before writing to ANY of the DFA_MEM* registers.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: DFA Memory Port#0 corresponds to the Octeon
+                                                         RLD0_* pins. */
+	uint64_t init_p1                      : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for Memory Port \#1 is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Enable memory port(s):
+                                                               a) ENA_P1=1 (single port in pass 1) OR
+                                                               b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)
+                                                           2) Wait 100us (to ensure a stable clock
+                                                              to the RLDRAMs) - as per RLDRAM spec.
+                                                           3) Write a '1' to the corresponding INIT_Px which
+                                                              will initiate a hardware initialization
+                                                              sequence.
+                                                         NOTE: After writing a '1', SW must wait 64K eclk
+                                                         cycles to ensure the HW init sequence has completed
+                                                         before writing to ANY of the DFA_MEM* registers.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: DFA Memory Port#1 corresponds to the Octeon
+                                                         RLD1_* pins. */
+	uint64_t r2r_pbunk                    : 1;  /**< When enabled, an additional command bubble is inserted
+                                                         if back to back reads are issued to different physical
+                                                         bunks. This is to avoid DQ data bus collisions when
+                                                         references cross between physical bunks.
+                                                         [NOTE: the physical bunk address boundary is determined
+                                                         by the PBUNK bit].
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         When MTYPE=1(FCRAM)/BLEN=0(2-burst), R2R_PBUNK SHOULD BE
+                                                         ZERO(for optimal performance). However, if electrically,
+                                                         DQ-sharing becomes a power/heat issue, then R2R_PBUNK
+                                                         should be set (but at a cost to performance (1/2 BW). */
+	uint64_t pbunk                        : 3;  /**< Physical Bunk address bit pointer.
+                                                         Specifies which address bit within the Longword
+                                                         Memory address MA[23:0] is used to determine the
+                                                         chip selects.
+                                                         [RLD_CS0_N corresponds to physical bunk \#0, and
+                                                         RLD_CS1_N corresponds to physical bunk \#1].
+                                                           - 000: CS0_N = MA[19]/CS1_N = !MA[19]
+                                                           - 001: CS0_N = MA[20]/CS1_N = !MA[20]
+                                                           - 010: CS0_N = MA[21]/CS1_N = !MA[21]
+                                                           - 011: CS0_N = MA[22]/CS1_N = !MA[22]
+                                                           - 100: CS0_N = MA[23]/CS1_N = !MA[23]
+                                                           - 101-111: CS0_N = 0 /CS1_N = 1
+                                                         Example(s):
+                                                         To build out a 128MB DFA memory, 4x 32Mx9
+                                                         parts could be used to fill out TWO physical
+                                                         bunks (clamshell configuration). Each (of the
+                                                         two) physical bunks contains 2x 32Mx9 = 16Mx36.
+                                                         Each RLDRAM device also contains 8 internal banks,
+                                                         therefore the memory Address is 16M/8banks = 2M
+                                                         addresses/bunk (2^21). In this case, MA[21] would
+                                                         select the physical bunk.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         be used to determine the Chip Select(s).
+                                                         NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), a
+                                                         "Redundant Bunk" scheme is employed to provide the
+                                                         highest overall performance (1 Req/ MCLK cycle).
+                                                         In this mode, it's imperative that SW set the PBUNK
+                                                         field +1 'above' the highest address bit. (such that
+                                                         the PBUNK extracted from the address will always be
+                                                         zero). In this mode, the CS_N[1:0] pins are driven
+                                                         to each redundant bunk based on a TDM scheme:
+                                                         [MCLK-EVEN=Bunk#0/MCLK-ODD=Bunk#1]. */
+	uint64_t blen                         : 1;  /**< Device Burst Length  (0=2-burst/1=4-burst)
+                                                         When BLEN=0(BL2), all QW reads/writes from CP2 are
+                                                         decomposed into 2 separate BL2(LW) requests to the
+                                                         Low-Latency memory.
+                                                         When BLEN=1(BL4), a LW request (from CP2 or NCB) is
+                                                         treated as 1 BL4(QW) request to the low latency memory.
+                                                         NOTE: QW refers to a 64-bit LLM Load/Store (intiated
+                                                         by a processor core). LW refers to a 36-bit load/store.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization before the DFA LLM
+                                                         (low latency memory) is used.
+                                                         NOTE: MTYPE=0(RLDRAM-II) MUST USE BLEN=0(2-burst)
+                                                         NOTE: MTYPE=1(FCRAM)/BLEN=0(BL2) requires a
+                                                         multi-bunk(clam) board design.
+                                                         NOTE: If MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=1(BL4),
+                                                         SW SHOULD use CP2 QW read/write requests (for
+                                                         optimal low-latency bus performance).
+                                                         [LW length read/write requests(in BL4 mode) use 50%
+                                                         of the available bus bandwidth]
+                                                         NOTE: MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=0(BL2) can only
+                                                         be used with FCRAM-II devices which support BL2 mode
+                                                         (see: Toshiba FCRAM-II, where DQ tristate after 2 data
+                                                         transfers).
+                                                         NOTE: MTYPE=1(FCRAM)/FCRAM2P=1(II+) does not support LW
+                                                         write requests (FCRAM-II+ device specification has removed
+                                                         the variable write mask function from the devices).
+                                                         As such, if this mode is used, SW must be careful to
+                                                         issue only PP-CP2 QW write requests. */
+	uint64_t bprch                        : 2;  /**< Tristate Enable (back porch) (\#dclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable back porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t fprch                        : 2;  /**< Tristate Enable (front porch) (\#dclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable front porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t wr_dly                       : 4;  /**< Write->Read CMD Delay (\#mclks):
+                                                         Determines \#mclk cycles to insert when controller
+                                                         switches from write to read. This allows programmer
+                                                         to control the data bus contention.
+                                                         For RLDRAM-II(BL2): (TBL=1)
+                                                         For FCRAM-II (BL4): (TBL=2)
+                                                         For FCRAM-II (BL2 grepl=1x ONLY): (TBL=1)
+                                                         For FCRAM-II (BL2 grepl>=2x): (TBL=3)
+                                                            NOTE: When MTYTPE=1(FCRAM-II) BLEN=0(BL2 Mode),
+                                                            grepl>=2x, writes require redundant bunk writes
+                                                            which require an additional 2 cycles before slotting
+                                                            the next read.
+                                                         WR_DLY = ROUND_UP[((TWL+TBL)*2 - TSKW + FPRCH) / 2] - TRL + 1
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For aggressive(performance optimal) designs,
+                                                         the WR_DLY 'may' be tuned down(-1) if bus fight
+                                                         on W->R transitions is not pronounced. */
+	uint64_t rw_dly                       : 4;  /**< Read->Write CMD Delay (\#mclks):
+                                                         Determines \#mclk cycles to insert when controller
+                                                         switches from read to write. This allows programmer
+                                                         to control the data bus contention.
+                                                         For RLDRAM-II/FCRAM-II (BL2): (TBL=1)
+                                                         For FCRAM-II (BL4): (TBL=2)
+                                                         RW_DLY = ROUND_UP[((TRL+TBL)*2 + TSKW + BPRCH+2)/2] - TWL + 1
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For aggressive(performance optimal) designs,
+                                                         the RW_DLY 'may' be tuned down(-1) if bus fight
+                                                         on R->W transitions is not pronounced. */
+	uint64_t sil_lat                      : 2;  /**< Silo Latency (\#dclks): On reads, determines how many
+                                                         additional dclks to wait (on top of tRL+1) before
+                                                         pulling data out of the padring silos used for time
+                                                         domain boundary crossing.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t mtype                        : 1;  /**< Memory Type (0=RLDRAM-II/1=Network DRAM-II/FCRAM)
+                                                         NOTE: N3K-P1 only supports RLDRAM-II
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), only the
+                                                         "unidirectional DS/QS" mode is supported. (see FCRAM
+                                                         data sheet EMRS[A6:A5]=SS(Strobe Select) register
+                                                         definition. [in FCRAM 2-burst mode, we use FCRAM
+                                                         in a clamshell configuration such that clam0 is
+                                                         addressed independently of clam1, and DQ is shared
+                                                         for optimal performance. As such it's imperative that
+                                                         the QS are conditionally received (and are NOT
+                                                         free-running), as the N3K receive data capture silos
+                                                         OR the clam0/1 QS strobes.
+                                                         NOTE: If this bit is SET, the ASX0/1
+                                                         ASX_RLD_FCRAM_MODE[MODE] bit(s) should also be SET
+                                                         in order for the RLD0/1-PHY(s) to support FCRAM devices. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t ena_p0                       : 1;  /**< Enable DFA RLDRAM Port#0
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for memory port \#0.
+                                                         NOTE: For N3K-P1, to enable Port#0(2nd port),
+                                                         Port#1 MUST ALSO be enabled.
+                                                         NOTE: For N3K-P2, single port mode, a customer is at
+                                                         liberty to enable either Port#0 or Port#1.
+                                                         NOTE: Once a port has been disabled, it MUST NEVER
+                                                         be re-enabled. [the only way to enable a port is
+                                                         through a chip reset].
+                                                         NOTE: DFA Memory Port#0 corresponds to the Octeon
+                                                         RLD0_* pins. */
+	uint64_t ena_p1                       : 1;  /**< Enable DFA RLDRAM Port#1
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for memory port \#1.
+                                                         NOTE: For N3K-P1, If the customer wishes to use a
+                                                         single port, s/he must enable Port#1 (and not Port#0).
+                                                         NOTE: For N3K-P2, single port mode, a customer is at
+                                                         liberty to enable either Port#0 or Port#1.
+                                                         NOTE: Once a port has been disabled, it MUST NEVER
+                                                         be re-enabled. [the only way to enable a port is
+                                                         through a chip reset].
+                                                         NOTE: DFA Memory Port#1 corresponds to the Octeon
+                                                         RLD1_* pins. */
+#else
+	uint64_t ena_p1                       : 1;
+	uint64_t ena_p0                       : 1;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mtype                        : 1;
+	uint64_t sil_lat                      : 2;
+	uint64_t rw_dly                       : 4;
+	uint64_t wr_dly                       : 4;
+	uint64_t fprch                        : 2;
+	uint64_t bprch                        : 2;
+	uint64_t blen                         : 1;
+	uint64_t pbunk                        : 3;
+	uint64_t r2r_pbunk                    : 1;
+	uint64_t init_p1                      : 1;
+	uint64_t init_p0                      : 1;
+	uint64_t bunk_init                    : 2;
+	uint64_t lpp_ena                      : 1;
+	uint64_t reserved_28_63               : 36;
+#endif
+	} cn38xx;
+	struct cvmx_dfa_memcfg0_cn38xxp2 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_27_63               : 37;
+	uint64_t bunk_init                    : 2;  /**< Controls the CS_N[1:0] during a) a HW Initialization
+                                                         sequence (triggered by DFA_MEMCFG0[INIT_Px]) or
+                                                         b) during a normal refresh sequence. If
+                                                         the BNK_INIT[x]=1, the corresponding CS_N[x] is driven.
+                                                         NOTE: This is required for DRAM used in a
+                                                         clamshell configuration, since the address lines
+                                                         carry Mode Register write data that is unique
+                                                         per bunk(or clam). In a clamshell configuration,
+                                                         The N3K A[x] pin may be tied into Clam#0's A[x]
+                                                         and also into Clam#1's 'mirrored' address bit A[y]
+                                                         (eg: Clam0 sees A[5] and Clam1 sees A[15]).
+                                                         To support clamshell designs, SW must initiate
+                                                         two separate HW init sequences for the two bunks
+                                                         (or clams) . Before each HW init sequence is triggered,
+                                                         SW must preload the DFA_MEMRLD[22:0] with the data
+                                                         that will be driven onto the A[22:0] wires during
+                                                         an MRS mode register write.
+                                                         NOTE: After the final HW initialization sequence has
+                                                         been triggered, SW must wait 64K eclks before writing
+                                                         the BUNK_INIT[1:0] field = 3'b11 (so that CS_N[1:0] is
+                                                         driven during refresh sequences in normal operation.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For MTYPE=1(FCRAM) Mode, each bunk MUST BE
+                                                         initialized independently. In other words, a HW init
+                                                         must be done for Bunk#0, and then another HW init
+                                                         must be done for Bunk#1 at power-on. */
+	uint64_t init_p0                      : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for Memory Port \#0 is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Enable memory port(s):
+                                                               a) ENA_P1=1 (single port in pass 1) OR
+                                                               b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)
+                                                           2) Wait 100us (to ensure a stable clock
+                                                              to the RLDRAMs) - as per RLDRAM spec.
+                                                           3) Write a '1' to the corresponding INIT_Px which
+                                                              will initiate a hardware initialization
+                                                              sequence.
+                                                         NOTE: After writing a '1', SW must wait 64K eclk
+                                                         cycles to ensure the HW init sequence has completed
+                                                         before writing to ANY of the DFA_MEM* registers.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: DFA Memory Port#0 corresponds to the Octeon
+                                                         RLD0_* pins. */
+	uint64_t init_p1                      : 1;  /**< When a '1' is written (and the previous value was '0'),
+                                                         the HW init sequence(s) for Memory Port \#1 is
+                                                         initiated.
+                                                         NOTE: To initialize memory, SW must:
+                                                           1) Enable memory port(s):
+                                                               a) ENA_P1=1 (single port in pass 1) OR
+                                                               b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)
+                                                           2) Wait 100us (to ensure a stable clock
+                                                              to the RLDRAMs) - as per RLDRAM spec.
+                                                           3) Write a '1' to the corresponding INIT_Px which
+                                                              will initiate a hardware initialization
+                                                              sequence.
+                                                         NOTE: After writing a '1', SW must wait 64K eclk
+                                                         cycles to ensure the HW init sequence has completed
+                                                         before writing to ANY of the DFA_MEM* registers.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: DFA Memory Port#1 corresponds to the Octeon
+                                                         RLD1_* pins. */
+	uint64_t r2r_pbunk                    : 1;  /**< When enabled, an additional command bubble is inserted
+                                                         if back to back reads are issued to different physical
+                                                         bunks. This is to avoid DQ data bus collisions when
+                                                         references cross between physical bunks.
+                                                         [NOTE: the physical bunk address boundary is determined
+                                                         by the PBUNK bit].
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         When MTYPE=1(FCRAM)/BLEN=0(2-burst), R2R_PBUNK SHOULD BE
+                                                         ZERO(for optimal performance). However, if electrically,
+                                                         DQ-sharing becomes a power/heat issue, then R2R_PBUNK
+                                                         should be set (but at a cost to performance (1/2 BW). */
+	uint64_t pbunk                        : 3;  /**< Physical Bunk address bit pointer.
+                                                         Specifies which address bit within the Longword
+                                                         Memory address MA[23:0] is used to determine the
+                                                         chip selects.
+                                                         [RLD_CS0_N corresponds to physical bunk \#0, and
+                                                         RLD_CS1_N corresponds to physical bunk \#1].
+                                                           - 000: CS0_N = MA[19]/CS1_N = !MA[19]
+                                                           - 001: CS0_N = MA[20]/CS1_N = !MA[20]
+                                                           - 010: CS0_N = MA[21]/CS1_N = !MA[21]
+                                                           - 011: CS0_N = MA[22]/CS1_N = !MA[22]
+                                                           - 100: CS0_N = MA[23]/CS1_N = !MA[23]
+                                                           - 101-111: CS0_N = 0 /CS1_N = 1
+                                                         Example(s):
+                                                         To build out a 128MB DFA memory, 4x 32Mx9
+                                                         parts could be used to fill out TWO physical
+                                                         bunks (clamshell configuration). Each (of the
+                                                         two) physical bunks contains 2x 32Mx9 = 16Mx36.
+                                                         Each RLDRAM device also contains 8 internal banks,
+                                                         therefore the memory Address is 16M/8banks = 2M
+                                                         addresses/bunk (2^21). In this case, MA[21] would
+                                                         select the physical bunk.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         be used to determine the Chip Select(s).
+                                                         NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), a
+                                                         "Redundant Bunk" scheme is employed to provide the
+                                                         highest overall performance (1 Req/ MCLK cycle).
+                                                         In this mode, it's imperative that SW set the PBUNK
+                                                         field +1 'above' the highest address bit. (such that
+                                                         the PBUNK extracted from the address will always be
+                                                         zero). In this mode, the CS_N[1:0] pins are driven
+                                                         to each redundant bunk based on a TDM scheme:
+                                                         [MCLK-EVEN=Bunk#0/MCLK-ODD=Bunk#1]. */
+	uint64_t blen                         : 1;  /**< Device Burst Length  (0=2-burst/1=4-burst)
+                                                         When BLEN=0(BL2), all QW reads/writes from CP2 are
+                                                         decomposed into 2 separate BL2(LW) requests to the
+                                                         Low-Latency memory.
+                                                         When BLEN=1(BL4), a LW request (from CP2 or NCB) is
+                                                         treated as 1 BL4(QW) request to the low latency memory.
+                                                         NOTE: QW refers to a 64-bit LLM Load/Store (intiated
+                                                         by a processor core). LW refers to a 36-bit load/store.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization before the DFA LLM
+                                                         (low latency memory) is used.
+                                                         NOTE: MTYPE=0(RLDRAM-II) MUST USE BLEN=0(2-burst)
+                                                         NOTE: MTYPE=1(FCRAM)/BLEN=0(BL2) requires a
+                                                         multi-bunk(clam) board design.
+                                                         NOTE: If MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=1(BL4),
+                                                         SW SHOULD use CP2 QW read/write requests (for
+                                                         optimal low-latency bus performance).
+                                                         [LW length read/write requests(in BL4 mode) use 50%
+                                                         of the available bus bandwidth]
+                                                         NOTE: MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=0(BL2) can only
+                                                         be used with FCRAM-II devices which support BL2 mode
+                                                         (see: Toshiba FCRAM-II, where DQ tristate after 2 data
+                                                         transfers).
+                                                         NOTE: MTYPE=1(FCRAM)/FCRAM2P=1(II+) does not support LW
+                                                         write requests (FCRAM-II+ device specification has removed
+                                                         the variable write mask function from the devices).
+                                                         As such, if this mode is used, SW must be careful to
+                                                         issue only PP-CP2 QW write requests. */
+	uint64_t bprch                        : 2;  /**< Tristate Enable (back porch) (\#dclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable back porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t fprch                        : 2;  /**< Tristate Enable (front porch) (\#dclks)
+                                                         On reads, allows user to control the shape of the
+                                                         tristate disable front porch for the DQ data bus.
+                                                         This parameter is also very dependent on the
+                                                         RW_DLY and WR_DLY parameters and care must be
+                                                         taken when programming these parameters to avoid
+                                                         data bus contention. Valid range [0..2]
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t wr_dly                       : 4;  /**< Write->Read CMD Delay (\#mclks):
+                                                         Determines \#mclk cycles to insert when controller
+                                                         switches from write to read. This allows programmer
+                                                         to control the data bus contention.
+                                                         For RLDRAM-II(BL2): (TBL=1)
+                                                         For FCRAM-II (BL4): (TBL=2)
+                                                         For FCRAM-II (BL2 grepl=1x ONLY): (TBL=1)
+                                                         For FCRAM-II (BL2 grepl>=2x): (TBL=3)
+                                                            NOTE: When MTYTPE=1(FCRAM-II) BLEN=0(BL2 Mode),
+                                                            grepl>=2x, writes require redundant bunk writes
+                                                            which require an additional 2 cycles before slotting
+                                                            the next read.
+                                                         WR_DLY = ROUND_UP[((TWL+TBL)*2 - TSKW + FPRCH) / 2] - TRL + 1
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For aggressive(performance optimal) designs,
+                                                         the WR_DLY 'may' be tuned down(-1) if bus fight
+                                                         on W->R transitions is not pronounced. */
+	uint64_t rw_dly                       : 4;  /**< Read->Write CMD Delay (\#mclks):
+                                                         Determines \#mclk cycles to insert when controller
+                                                         switches from read to write. This allows programmer
+                                                         to control the data bus contention.
+                                                         For RLDRAM-II/FCRAM-II (BL2): (TBL=1)
+                                                         For FCRAM-II (BL4): (TBL=2)
+                                                         RW_DLY = ROUND_UP[((TRL+TBL)*2 + TSKW + BPRCH+2)/2] - TWL + 1
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: For aggressive(performance optimal) designs,
+                                                         the RW_DLY 'may' be tuned down(-1) if bus fight
+                                                         on R->W transitions is not pronounced. */
+	uint64_t sil_lat                      : 2;  /**< Silo Latency (\#dclks): On reads, determines how many
+                                                         additional dclks to wait (on top of tRL+1) before
+                                                         pulling data out of the padring silos used for time
+                                                         domain boundary crossing.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t mtype                        : 1;  /**< Memory Type (0=RLDRAM-II/1=Network DRAM-II/FCRAM)
+                                                         NOTE: N3K-P1 only supports RLDRAM-II
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), only the
+                                                         "unidirectional DS/QS" mode is supported. (see FCRAM
+                                                         data sheet EMRS[A6:A5]=SS(Strobe Select) register
+                                                         definition. [in FCRAM 2-burst mode, we use FCRAM
+                                                         in a clamshell configuration such that clam0 is
+                                                         addressed independently of clam1, and DQ is shared
+                                                         for optimal performance. As such it's imperative that
+                                                         the QS are conditionally received (and are NOT
+                                                         free-running), as the N3K receive data capture silos
+                                                         OR the clam0/1 QS strobes.
+                                                         NOTE: If this bit is SET, the ASX0/1
+                                                         ASX_RLD_FCRAM_MODE[MODE] bit(s) should also be SET
+                                                         in order for the RLD0/1-PHY(s) to support FCRAM devices. */
+	uint64_t reserved_2_2                 : 1;
+	uint64_t ena_p0                       : 1;  /**< Enable DFA RLDRAM Port#0
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for memory port \#0.
+                                                         NOTE: For N3K-P1, to enable Port#0(2nd port),
+                                                         Port#1 MUST ALSO be enabled.
+                                                         NOTE: For N3K-P2, single port mode, a customer is at
+                                                         liberty to enable either Port#0 or Port#1.
+                                                         NOTE: Once a port has been disabled, it MUST NEVER
+                                                         be re-enabled. [the only way to enable a port is
+                                                         through a chip reset].
+                                                         NOTE: DFA Memory Port#0 corresponds to the Octeon
+                                                         RLD0_* pins. */
+	uint64_t ena_p1                       : 1;  /**< Enable DFA RLDRAM Port#1
+                                                         When enabled, this bit lets N3K be the default
+                                                         driver for memory port \#1.
+                                                         NOTE: For N3K-P1, If the customer wishes to use a
+                                                         single port, s/he must enable Port#1 (and not Port#0).
+                                                         NOTE: For N3K-P2, single port mode, a customer is at
+                                                         liberty to enable either Port#0 or Port#1.
+                                                         NOTE: Once a port has been disabled, it MUST NEVER
+                                                         be re-enabled. [the only way to enable a port is
+                                                         through a chip reset].
+                                                         NOTE: DFA Memory Port#1 corresponds to the Octeon
+                                                         RLD1_* pins. */
+#else
+	uint64_t ena_p1                       : 1;
+	uint64_t ena_p0                       : 1;
+	uint64_t reserved_2_2                 : 1;
+	uint64_t mtype                        : 1;
+	uint64_t sil_lat                      : 2;
+	uint64_t rw_dly                       : 4;
+	uint64_t wr_dly                       : 4;
+	uint64_t fprch                        : 2;
+	uint64_t bprch                        : 2;
+	uint64_t blen                         : 1;
+	uint64_t pbunk                        : 3;
+	uint64_t r2r_pbunk                    : 1;
+	uint64_t init_p1                      : 1;
+	uint64_t init_p0                      : 1;
+	uint64_t bunk_init                    : 2;
+	uint64_t reserved_27_63               : 37;
+#endif
+	} cn38xxp2;
+	struct cvmx_dfa_memcfg0_s             cn58xx;
+	struct cvmx_dfa_memcfg0_s             cn58xxp1;
+};
+typedef union cvmx_dfa_memcfg0 cvmx_dfa_memcfg0_t;
+
+/**
+ * cvmx_dfa_memcfg1
+ *
+ * DFA_MEMCFG1 = RLDRAM Memory Timing Configuration
+ *
+ * Description:
+ */
+union cvmx_dfa_memcfg1 {
+	uint64_t u64;
+	struct cvmx_dfa_memcfg1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_34_63               : 30;
+	uint64_t ref_intlo                    : 9;  /**< Burst Refresh Interval[8:0] (\#dclks)
+                                                         For finer refresh interval granularity control.
+                                                         This field provides an additional level of granularity
+                                                         for the refresh interval. It specifies the additional
+                                                         \#dclks [0...511] to be added to the REF_INT[3:0] field.
+                                                         For RLDRAM-II: For dclk(400MHz=2.5ns):
+                                                         Example: 64K AREF cycles required within tREF=32ms
+                                                             trefint = tREF(ms)/(64K cycles/8banks)
+                                                                         = 32ms/8K = 3.9us = 3900ns
+                                                             REF_INT[3:0] = ROUND_DOWN[(trefint/dclk)/512]
+                                                                          = ROUND_DOWN[(3900/2.5)/512]
+                                                                          = 3
+                                                             REF_INTLO[8:0] = MOD[(trefint/dclk)/512]
+                                                                            = MOD[(3900/2.5)/512]
+                                                                            = 24
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t aref_ena                     : 1;  /**< Auto Refresh Cycle Enable
+                                                         INTERNAL USE ONLY:
+                                                         NOTE: This mode bit is ONLY intended to be used by
+                                                         low-level power-on initialization routines in the
+                                                         event that the hardware initialization routine
+                                                         does not work. It allows SW to create AREF
+                                                         commands on the RLDRAM bus directly.
+                                                         When this bit is set, ALL RLDRAM writes (issued by
+                                                         a PP through the NCB or CP2) are converted to AREF
+                                                         commands on the RLDRAM bus. The write-address is
+                                                         presented on the A[20:0]/BA[2:0] pins (for which
+                                                         the RLDRAM only interprets BA[2:0]).
+                                                         When this bit is set, only writes are allowed
+                                                         and MUST use grepl=0 (1x).
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: MRS_ENA and AREF_ENA are mutually exclusive
+                                                         (SW can set one or the other, but never both!)
+                                                         NOTE: AREF commands generated using this method target
+                                                         the 'addressed' bunk. */
+	uint64_t mrs_ena                      : 1;  /**< Mode Register Set Cycle Enable
+                                                         INTERNAL USE ONLY:
+                                                         NOTE: This mode bit is ONLY intended to be used by
+                                                         low-level power-on initialization routines in the
+                                                         event that the hardware initialization routine
+                                                         does not work. It allows SW to create MRS
+                                                         commands on the RLDRAM bus directly.
+                                                         When this bit is set, ALL RLDRAM writes (issued by
+                                                         a PP through the NCB or CP2) are converted to MRS
+                                                         commands on the RLDRAM bus. The write-address is
+                                                         presented on the A[20:0]/BA[2:0] pins (for which
+                                                         the RLDRAM only interprets A[17:0]).
+                                                         When this bit is set, only writes are allowed
+                                                         and MUST use grepl=0 (1x).
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization.
+                                                         NOTE: MRS_ENA and AREF_ENA are mutually exclusive
+                                                         (SW can set one or the other, but never both!)
+                                                         NOTE: MRS commands generated using this method target
+                                                         the 'addressed' bunk. */
+	uint64_t tmrsc                        : 3;  /**< Mode Register Set Cycle Time (represented in \#mclks)
+                                                              - 000-001: RESERVED
+                                                              - 010: tMRSC = 2 mclks
+                                                              - 011: tMRSC = 3 mclks
+                                                              - ...
+                                                              - 111: tMRSC = 7 mclks
+                                                         NOTE: The device tMRSC parameter is a function of CL
+                                                         (which during HW initialization is not known. Its
+                                                         recommended to load tMRSC(MAX) value to avoid timing
+                                                         violations.
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t trc                          : 4;  /**< Row Cycle Time (represented in \#mclks)
+                                                         see also: DFA_MEMRLD[RLCFG] field which must
+                                                         correspond with tRL/tWL parameter(s).
+                                                              - 0000-0010: RESERVED
+                                                              - 0011: tRC = 3 mclks
+                                                              - 0100: tRC = 4 mclks
+                                                              - 0101: tRC = 5 mclks
+                                                              - 0110: tRC = 6 mclks
+                                                              - 0111: tRC = 7 mclks
+                                                              - 1000: tRC = 8 mclks
+                                                              - 1001: tRC = 9 mclks
+                                                              - 1010-1111: RESERVED
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t twl                          : 4;  /**< Write Latency (represented in \#mclks)
+                                                         see also: DFA_MEMRLD[RLCFG] field which must
+                                                         correspond with tRL/tWL parameter(s).
+                                                              - 0000-0001: RESERVED
+                                                              - 0010: Write Latency (WL=2.0 mclk)
+                                                              - 0011: Write Latency (WL=3.0 mclks)
+                                                              - 0100: Write Latency (WL=4.0 mclks)
+                                                              - 0101: Write Latency (WL=5.0 mclks)
+                                                              - 0110: Write Latency (WL=6.0 mclks)
+                                                              - 0111: Write Latency (WL=7.0 mclks)
+                                                              - 1000: Write Latency (WL=8.0 mclks)
+                                                              - 1001: Write Latency (WL=9.0 mclks)
+                                                              - 1010: Write Latency (WL=10.0 mclks)
+                                                              - 1011-1111: RESERVED
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t trl                          : 4;  /**< Read Latency (represented in \#mclks)
+                                                         see also: DFA_MEMRLD[RLCFG] field which must
+                                                         correspond with tRL/tWL parameter(s).
+                                                              - 0000-0010: RESERVED
+                                                              - 0011: Read Latency = 3 mclks
+                                                              - 0100: Read Latency = 4 mclks
+                                                              - 0101: Read Latency = 5 mclks
+                                                              - 0110: Read Latency = 6 mclks
+                                                              - 0111: Read Latency = 7 mclks
+                                                              - 1000: Read Latency = 8 mclks
+                                                              - 1001: Read Latency = 9 mclks
+                                                              - 1010: Read Latency = 10 mclks
+                                                              - 1011-1111: RESERVED
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t tskw                         : 2;  /**< Board Skew (represented in \#dclks)
+                                                         Represents additional board skew of DQ/DQS.
+                                                             - 00: board-skew = 0 dclk
+                                                             - 01: board-skew = 1 dclk
+                                                             - 10: board-skew = 2 dclk
+                                                             - 11: board-skew = 3 dclk
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t ref_int                      : 4;  /**< Refresh Interval (represented in \#of 512 dclk
+                                                         increments).
+                                                              - 0000: RESERVED
+                                                              - 0001: 1 * 512  = 512 dclks
+                                                              - ...
+                                                              - 1111: 15 * 512 = 7680 dclks
+                                                         NOTE: For finer level of granularity, refer to
+                                                         REF_INTLO[8:0] field.
+                                                         For RLDRAM-II, each refresh interval will
+                                                         generate a burst of 8 AREF commands, one to each of
+                                                         8 explicit banks (referenced using the RLD_BA[2:0]
+                                                         pins.
+                                                         Example: For mclk=200MHz/dclk(400MHz=2.5ns):
+                                                           64K AREF cycles required within tREF=32ms
+                                                             trefint = tREF(ms)/(64K cycles/8banks)
+                                                                     = 32ms/8K = 3.9us = 3900ns
+                                                             REF_INT = ROUND_DOWN[(trefint/dclk)/512]
+                                                                     = ROUND_DOWN[(3900/2.5)/512]
+                                                                     = 3
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t ref_int                      : 4;
+	uint64_t tskw                         : 2;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t trl                          : 4;
+	uint64_t twl                          : 4;
+	uint64_t trc                          : 4;
+	uint64_t tmrsc                        : 3;
+	uint64_t mrs_ena                      : 1;
+	uint64_t aref_ena                     : 1;
+	uint64_t ref_intlo                    : 9;
+	uint64_t reserved_34_63               : 30;
+#endif
+	} s;
+	struct cvmx_dfa_memcfg1_s             cn38xx;
+	struct cvmx_dfa_memcfg1_s             cn38xxp2;
+	struct cvmx_dfa_memcfg1_s             cn58xx;
+	struct cvmx_dfa_memcfg1_s             cn58xxp1;
+};
+typedef union cvmx_dfa_memcfg1 cvmx_dfa_memcfg1_t;
+
+/**
+ * cvmx_dfa_memcfg2
+ *
+ * DFA_MEMCFG2 = DFA Memory Config Register \#2
+ * *** NOTE: Pass2 Addition
+ *
+ * Description: Additional Memory Configuration CSRs to support FCRAM-II/II+ and Network DRAM-II
+ */
+union cvmx_dfa_memcfg2 {
+	uint64_t u64;
+	struct cvmx_dfa_memcfg2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t dteclkdis                    : 1;  /**< DFA DTE Clock Disable
+                                                         When SET, the DFA clocks for DTE(thread engine)
+                                                         operation are disabled.
+                                                         NOTE: When SET, SW MUST NEVER issue ANY operations to
+                                                         the DFA via the NCB Bus. All DFA Operations must be
+                                                         issued solely through the CP2 interface.
+
+                                                         NOTE: When DTECLKDIS=1, if CP2 Errors are encountered
+                                                         (ie: CP2SBE, CP2DBE, CP2PERR), the DFA_MEMFADR CSR
+                                                         does not reflect the failing address/ctl information. */
+	uint64_t silrst                       : 1;  /**< LLM-PHY Silo Reset
+                                                         When a '1' is written (when the previous
+                                                         value was a '0') causes the the LLM-PHY Silo read/write
+                                                         pointers to be reset.
+                                                         NOTE: SW MUST WAIT 400 dclks after the LAST HW Init
+                                                         sequence was launched (ie: INIT_START 0->1 CSR write),
+                                                         before the SILRST can be triggered (0->1). */
+	uint64_t trfc                         : 5;  /**< FCRAM-II Refresh Interval
+                                                         *** CN58XX UNSUPPORTED *** */
+	uint64_t refshort                     : 1;  /**< FCRAM Short Refresh Mode
+                                                         *** CN58XX UNSUPPORTED *** */
+	uint64_t ua_start                     : 2;  /**< FCRAM-II Upper Addres Start
+                                                         *** CN58XX UNSUPPORTED *** */
+	uint64_t maxbnk                       : 1;  /**< Maximum Banks per-device (used by the address mapper
+                                                         when extracting address bits for the memory bank#.
+                                                           - 0: 4 banks/device
+                                                           - 1: 8 banks/device */
+	uint64_t fcram2p                      : 1;  /**< FCRAM-II+ Mode Enable
+                                                         *** CN58XX UNSUPPORTED *** */
+#else
+	uint64_t fcram2p                      : 1;
+	uint64_t maxbnk                       : 1;
+	uint64_t ua_start                     : 2;
+	uint64_t refshort                     : 1;
+	uint64_t trfc                         : 5;
+	uint64_t silrst                       : 1;
+	uint64_t dteclkdis                    : 1;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_dfa_memcfg2_s             cn38xx;
+	struct cvmx_dfa_memcfg2_s             cn38xxp2;
+	struct cvmx_dfa_memcfg2_s             cn58xx;
+	struct cvmx_dfa_memcfg2_s             cn58xxp1;
+};
+typedef union cvmx_dfa_memcfg2 cvmx_dfa_memcfg2_t;
+
+/**
+ * cvmx_dfa_memfadr
+ *
+ * DFA_MEMFADR = RLDRAM Failing Address/Control Register
+ *
+ * Description: DFA Memory Failing Address/Control Error Capture information
+ * This register contains useful information to help in isolating an RLDRAM memory failure.
+ * NOTE: The first detected SEC/DED/PERR failure is captured in DFA_MEMFADR, however, a DED or PERR (which is
+ * more severe) will always overwrite a SEC error. The user can 'infer' the source of the interrupt
+ * via the FSRC field.
+ * NOTE: If DFA_MEMCFG2[DTECLKDIS]=1, the contents of this register are UNDEFINED.
+ */
+union cvmx_dfa_memfadr {
+	uint64_t u64;
+	struct cvmx_dfa_memfadr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t maddr                        : 24; /**< Memory Address */
+#else
+	uint64_t maddr                        : 24;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dfa_memfadr_cn31xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_40_63               : 24;
+	uint64_t fdst                         : 9;  /**< Fill-Destination
+                                                            FSRC[1:0]    | FDST[8:0]
+                                                            -------------+-------------------------------------
+                                                             0(NCB-DTE)  | [fillstart,2'b0,WIDX(1),DMODE(1),DTE(4)]
+                                                             1(NCB-CSR)  | [ncbSRC[8:0]]
+                                                             3(CP2-PP)   | [2'b0,SIZE(1),INDEX(1),PP(4),FID(1)]
+                                                           where:
+                                                               DTE: DFA Thread Engine ID#
+                                                               PP: Packet Processor ID#
+                                                               FID: Fill-ID# (unique per PP)
+                                                               WIDX:  16b SIMPLE Mode (index)
+                                                               DMODE: (0=16b SIMPLE/1=32b SIMPLE)
+                                                               SIZE: (0=LW Mode access/1=QW Mode Access)
+                                                               INDEX: (0=Low LW/1=High LW)
+                                                         NOTE: QW refers to a 56/64-bit LLM Load/Store (intiated
+                                                         by a processor core). LW refers to a 32-bit load/store. */
+	uint64_t fsrc                         : 2;  /**< Fill-Source (0=NCB-DTE/1=NCB-CSR/2=RESERVED/3=PP-CP2) */
+	uint64_t pnum                         : 1;  /**< Memory Port
+                                                         NOTE: For O2P, this bit will always return zero. */
+	uint64_t bnum                         : 3;  /**< Memory Bank
+                                                         When DFA_DDR2_ADDR[RNK_LO]=1, BNUM[2]=RANK[0].
+                                                         (RANK[1] can be inferred from MADDR[24:0]) */
+	uint64_t maddr                        : 25; /**< Memory Address */
+#else
+	uint64_t maddr                        : 25;
+	uint64_t bnum                         : 3;
+	uint64_t pnum                         : 1;
+	uint64_t fsrc                         : 2;
+	uint64_t fdst                         : 9;
+	uint64_t reserved_40_63               : 24;
+#endif
+	} cn31xx;
+	struct cvmx_dfa_memfadr_cn38xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_39_63               : 25;
+	uint64_t fdst                         : 9;  /**< Fill-Destination
+                                                            FSRC[1:0]    | FDST[8:0]
+                                                            -------------+-------------------------------------
+                                                             0(NCB-DTE)  | [fillstart,2'b0,WIDX(1),DMODE(1),DTE(4)]
+                                                             1(NCB-CSR)  | [ncbSRC[8:0]]
+                                                             3(CP2-PP)   | [2'b0,SIZE(1),INDEX(1),PP(4),FID(1)]
+                                                           where:
+                                                               DTE: DFA Thread Engine ID#
+                                                               PP: Packet Processor ID#
+                                                               FID: Fill-ID# (unique per PP)
+                                                               WIDX:  18b SIMPLE Mode (index)
+                                                               DMODE: (0=18b SIMPLE/1=36b SIMPLE)
+                                                               SIZE: (0=LW Mode access/1=QW Mode Access)
+                                                               INDEX: (0=Low LW/1=High LW)
+                                                         NOTE: QW refers to a 64-bit LLM Load/Store (intiated
+                                                         by a processor core). LW refers to a 36-bit load/store. */
+	uint64_t fsrc                         : 2;  /**< Fill-Source (0=NCB-DTE/1=NCB-CSR/2=RESERVED/3=PP-CP2) */
+	uint64_t pnum                         : 1;  /**< Memory Port
+                                                         NOTE: the port id's are reversed
+                                                            PNUM==0 => port#1
+                                                            PNUM==1 => port#0 */
+	uint64_t bnum                         : 3;  /**< Memory Bank */
+	uint64_t maddr                        : 24; /**< Memory Address */
+#else
+	uint64_t maddr                        : 24;
+	uint64_t bnum                         : 3;
+	uint64_t pnum                         : 1;
+	uint64_t fsrc                         : 2;
+	uint64_t fdst                         : 9;
+	uint64_t reserved_39_63               : 25;
+#endif
+	} cn38xx;
+	struct cvmx_dfa_memfadr_cn38xx        cn38xxp2;
+	struct cvmx_dfa_memfadr_cn38xx        cn58xx;
+	struct cvmx_dfa_memfadr_cn38xx        cn58xxp1;
+};
+typedef union cvmx_dfa_memfadr cvmx_dfa_memfadr_t;
+
+/**
+ * cvmx_dfa_memfcr
+ *
+ * DFA_MEMFCR = FCRAM MRS Register(s) EMRS2[14:0], EMRS1[14:0], MRS[14:0]
+ * *** CN58XX UNSUPPORTED ***
+ *
+ * Notes:
+ * For FCRAM-II please consult your device's data sheet for further details:
+ * MRS Definition:
+ *    A[13:8]=0   RESERVED
+ *    A[7]=0      TEST MODE     (N3K requires test mode 0:"disabled")
+ *    A[6:4]      CAS LATENCY   (fully programmable - SW must ensure that the value programmed
+ *                               into DFA_MEM_CFG0[TRL] corresponds with this value).
+ *    A[3]=0      BURST TYPE    (N3K requires 0:"Sequential" Burst Type)
+ *    A[2:0]      BURST LENGTH  Burst Length [1:BL2/2:BL4] (N3K only supports BL=2,4)
+ *
+ *                                  In BL2 mode(for highest performance), only 1/2 the phsyical
+ *                                  memory is unique (ie: each bunk stores the same information).
+ *                                  In BL4 mode(highest capacity), all of the physical memory
+ *                                  is unique (ie: each bunk is uniquely addressable).
+ * EMRS Definition:
+ *    A[13:12]    REFRESH MODE  (N3K Supports only 0:"Conventional" and 1:"Short" auto-refresh modes)
+ *
+ *                              (SW must ensure that the value programmed into DFA_MEMCFG2[REFSHORT]
+ *                              is also reflected in the Refresh Mode encoding).
+ *    A[11:7]=0   RESERVED
+ *    A[6:5]=2    STROBE SELECT (N3K supports only 2:"Unidirectional DS/QS" mode - the read capture
+ *                              silos rely on a conditional QS strobe)
+ *    A[4:3]      DIC(QS)       QS Drive Strength: fully programmable (consult your FCRAM-II data sheet)
+ *                                [0: Normal Output Drive/1: Strong Output Drive/2: Weak output Drive]
+ *    A[2:1]      DIC(DQ)       DQ Drive Strength: fully programmable (consult your FCRAM-II data sheet)
+ *                                [0: Normal Output Drive/1: Strong Output Drive/2: Weak output Drive]
+ *    A[0]        DLL           DLL Enable: Programmable [0:DLL Enable/1: DLL Disable]
+ *
+ * EMRS2 Definition: (for FCRAM-II+)
+ *    A[13:11]=0                RESERVED
+ *    A[10:8]     ODTDS         On Die Termination (DS+/-)
+ *                                 [0: ODT Disable /1: 15ohm termination /(2-7): RESERVED]
+ *    A[7:6]=0    MBW           Multi-Bank Write: (N3K requires use of 0:"single bank" mode only)
+ *    A[5:3]      ODTin         On Die Termination (input pin)
+ *                                 [0: ODT Disable /1: 15ohm termination /(2-7): RESERVED]
+ *    A[2:0]      ODTDQ         On Die Termination (DQ)
+ *                                 [0: ODT Disable /1: 15ohm termination /(2-7): RESERVED]
+ */
+union cvmx_dfa_memfcr {
+	uint64_t u64;
+	struct cvmx_dfa_memfcr_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t emrs2                        : 15; /**< Memory Address[14:0] during EMRS2(for FCRAM-II+)
+                                                         *** CN58XX UNSUPPORTED *** */
+	uint64_t reserved_31_31               : 1;
+	uint64_t emrs                         : 15; /**< Memory Address[14:0] during EMRS
+                                                         *** CN58XX UNSUPPORTED ***
+                                                           A[0]=1: DLL Enabled) */
+	uint64_t reserved_15_15               : 1;
+	uint64_t mrs                          : 15; /**< FCRAM Memory Address[14:0] during MRS
+                                                         *** CN58XX UNSUPPORTED ***
+                                                           A[6:4]=4  CAS LATENCY=4(default)
+                                                           A[3]=0    Burst Type(must be 0:Sequential)
+                                                           A[2:0]=2  Burst Length=4(default) */
+#else
+	uint64_t mrs                          : 15;
+	uint64_t reserved_15_15               : 1;
+	uint64_t emrs                         : 15;
+	uint64_t reserved_31_31               : 1;
+	uint64_t emrs2                        : 15;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfa_memfcr_s              cn38xx;
+	struct cvmx_dfa_memfcr_s              cn38xxp2;
+	struct cvmx_dfa_memfcr_s              cn58xx;
+	struct cvmx_dfa_memfcr_s              cn58xxp1;
+};
+typedef union cvmx_dfa_memfcr cvmx_dfa_memfcr_t;
+
+/**
+ * cvmx_dfa_memhidat
+ *
+ * Description:
+ * DFA supports NCB-Direct CSR acccesses to DFM Memory space for debug purposes. Unfortunately,
+ * NCB-Direct accesses
+ * are limited to QW-size(64bits), whereas the minimum access granularity for DFM Memory space is
+ * OW(128bits). To
+ * support writes to DFM Memory space, the Hi-QW of data is sourced from the DFA_MEMHIDAT
+ * register. Recall, the
+ * OW(128b) in DDR3 memory space is fixed format:
+ * OWDATA[127:118]: OWECC[9:0] 10bits of in-band OWECC SEC/DED codeword
+ * This can be precomputed/written by SW OR
+ * if DFM_FNTCTL[ECC_WENA]=1, DFM hardware will auto-compute the 10b OWECC and place in the
+ * OWDATA[127:118] before being written to memory.
+ * OWDATA[117:0]:   Memory Data (contains fixed MNODE/MONODE arc formats for use by DTEs(thread
+ * engines).
+ * Or, a user may choose to treat DFM Memory Space as 'scratch pad' in which case the
+ * OWDATA[117:0] may contain user-specified information accessible via NCB-Direct CSR mode
+ * accesses to DFA Memory Space.
+ * NOTE: To write to the DFA_MEMHIDAT register, a device would issue an IOBST directed at the DFA
+ * with addr[34:32]=3'b111.
+ * To read the DFA_MEMHIDAT register, a device would issue an IOBLD64 directed at the DFA with
+ * addr[34:32]=3'b111.
+ * NOTE: If DFA_CONFIG[DTECLKDIS]=1 (DFA-DTE clocks disabled), reads/writes to the DFA_MEMHIDAT
+ * register do not take effect.
+ * NOTE: If FUSE[TBD]="DFA DTE disable" is blown, reads/writes to the DFA_MEMHIDAT register do
+ * not take effect.
+ * NOTE: PLEASE REMOVE DEFINITION FROM o68/o61 HRM
+ */
+union cvmx_dfa_memhidat {
+	uint64_t u64;
+	struct cvmx_dfa_memhidat_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t hidat                        : 64; /**< This register is unused and can be treated as spare bits. */
+#else
+	uint64_t hidat                        : 64;
+#endif
+	} s;
+	struct cvmx_dfa_memhidat_s            cn61xx;
+	struct cvmx_dfa_memhidat_s            cn63xx;
+	struct cvmx_dfa_memhidat_s            cn63xxp1;
+	struct cvmx_dfa_memhidat_s            cn66xx;
+	struct cvmx_dfa_memhidat_s            cn68xx;
+	struct cvmx_dfa_memhidat_s            cn68xxp1;
+	struct cvmx_dfa_memhidat_s            cn70xx;
+	struct cvmx_dfa_memhidat_s            cn78xx;
+};
+typedef union cvmx_dfa_memhidat cvmx_dfa_memhidat_t;
+
+/**
+ * cvmx_dfa_memrld
+ *
+ * DFA_MEMRLD = DFA RLDRAM MRS Register Values
+ *
+ * Description:
+ */
+union cvmx_dfa_memrld {
+	uint64_t u64;
+	struct cvmx_dfa_memrld_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_23_63               : 41;
+	uint64_t mrsdat                       : 23; /**< This field represents the data driven onto the
+                                                         A[22:0] address lines during MRS(Mode Register Set)
+                                                         commands (during a HW init sequence). This field
+                                                         corresponds with the Mode Register Bit Map from
+                                                         your RLDRAM-II device specific data sheet.
+                                                            A[17:10]: RESERVED
+                                                            A[9]:     ODT (on die termination)
+                                                            A[8]:     Impedance Matching
+                                                            A[7]:     DLL Reset
+                                                            A[6]:     UNUSED
+                                                            A[5]:     Address Mux  (for N3K: MUST BE ZERO)
+                                                            A[4:3]:   Burst Length (for N3K: MUST BE ZERO)
+                                                            A[2:0]:   Configuration (see data sheet for
+                                                                      specific RLDRAM-II device).
+                                                               - 000-001: CFG=1 [tRC=4/tRL=4/tWL=5]
+                                                               - 010:     CFG=2 [tRC=6/tRL=6/tWL=7]
+                                                               - 011:     CFG=3 [tRC=8/tRL=8/tWL=9]
+                                                               - 100-111: RESERVED
+                                                          NOTE: For additional density, the RLDRAM-II parts
+                                                          can be 'clamshelled' (ie: two devices mounted on
+                                                          different sides of the PCB board), since the BGA
+                                                          pinout supports 'mirroring'.
+                                                          To support a clamshell design, SW must preload
+                                                          the MRSDAT[22:0] with the proper A[22:0] pin mapping
+                                                          which is dependent on the 'selected' bunk/clam
+                                                          (see also: DFA_MEMCFG0[BUNK_INIT] field).
+                                                          NOTE: Care MUST BE TAKEN NOT to write to this register
+                                                          within 64K eclk cycles of a HW INIT (see: INIT_P0/INIT_P1).
+                                                          NOTE: This should only be written to a different value
+                                                          during power-on SW initialization. */
+#else
+	uint64_t mrsdat                       : 23;
+	uint64_t reserved_23_63               : 41;
+#endif
+	} s;
+	struct cvmx_dfa_memrld_s              cn38xx;
+	struct cvmx_dfa_memrld_s              cn38xxp2;
+	struct cvmx_dfa_memrld_s              cn58xx;
+	struct cvmx_dfa_memrld_s              cn58xxp1;
+};
+typedef union cvmx_dfa_memrld cvmx_dfa_memrld_t;
+
+/**
+ * cvmx_dfa_ncbctl
+ *
+ * DFA_NCBCTL = DFA NCB CTL Register
+ *
+ * Description:
+ */
+union cvmx_dfa_ncbctl {
+	uint64_t u64;
+	struct cvmx_dfa_ncbctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_11_63               : 53;
+	uint64_t sbdnum                       : 5;  /**< SBD Debug Entry#
+                                                         For internal use only. (DFA Scoreboard debug)
+                                                         Selects which one of 32 DFA Scoreboard entries is
+                                                         latched into the DFA_SBD_DBG[0-3] registers. */
+	uint64_t sbdlck                       : 1;  /**< DFA Scoreboard LOCK Strobe
+                                                         For internal use only. (DFA Scoreboard debug)
+                                                         When written with a '1', the DFA Scoreboard Debug
+                                                         registers (DFA_SBD_DBG[0-3]) are all locked down.
+                                                         This allows SW to lock down the contents of the entire
+                                                         SBD for a single instant in time. All subsequent reads
+                                                         of the DFA scoreboard registers will return the data
+                                                         from that instant in time. */
+	uint64_t dcmode                       : 1;  /**< DRF-CRQ/DTE Arbiter Mode
+                                                         DTE-DRF Arbiter (0=FP [LP=CRQ/HP=DTE],1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t dtmode                       : 1;  /**< DRF-DTE Arbiter Mode
+                                                         DTE-DRF Arbiter (0=FP [LP=DTE[15],...,HP=DTE[0]],1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t pmode                        : 1;  /**< NCB-NRP Arbiter Mode
+                                                         (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t qmode                        : 1;  /**< NCB-NRQ Arbiter Mode
+                                                         (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t imode                        : 1;  /**< NCB-Inbound Arbiter
+                                                         (0=FP [LP=NRQ,HP=NRP], 1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t imode                        : 1;
+	uint64_t qmode                        : 1;
+	uint64_t pmode                        : 1;
+	uint64_t dtmode                       : 1;
+	uint64_t dcmode                       : 1;
+	uint64_t sbdlck                       : 1;
+	uint64_t sbdnum                       : 5;
+	uint64_t reserved_11_63               : 53;
+#endif
+	} s;
+	struct cvmx_dfa_ncbctl_cn38xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t sbdnum                       : 4;  /**< SBD Debug Entry#
+                                                         For internal use only. (DFA Scoreboard debug)
+                                                         Selects which one of 16 DFA Scoreboard entries is
+                                                         latched into the DFA_SBD_DBG[0-3] registers. */
+	uint64_t sbdlck                       : 1;  /**< DFA Scoreboard LOCK Strobe
+                                                         For internal use only. (DFA Scoreboard debug)
+                                                         When written with a '1', the DFA Scoreboard Debug
+                                                         registers (DFA_SBD_DBG[0-3]) are all locked down.
+                                                         This allows SW to lock down the contents of the entire
+                                                         SBD for a single instant in time. All subsequent reads
+                                                         of the DFA scoreboard registers will return the data
+                                                         from that instant in time. */
+	uint64_t dcmode                       : 1;  /**< DRF-CRQ/DTE Arbiter Mode
+                                                         DTE-DRF Arbiter (0=FP [LP=CRQ/HP=DTE],1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t dtmode                       : 1;  /**< DRF-DTE Arbiter Mode
+                                                         DTE-DRF Arbiter (0=FP [LP=DTE[15],...,HP=DTE[0]],1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t pmode                        : 1;  /**< NCB-NRP Arbiter Mode
+                                                         (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t qmode                        : 1;  /**< NCB-NRQ Arbiter Mode
+                                                         (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+	uint64_t imode                        : 1;  /**< NCB-Inbound Arbiter
+                                                         (0=FP [LP=NRQ,HP=NRP], 1=RR)
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t imode                        : 1;
+	uint64_t qmode                        : 1;
+	uint64_t pmode                        : 1;
+	uint64_t dtmode                       : 1;
+	uint64_t dcmode                       : 1;
+	uint64_t sbdlck                       : 1;
+	uint64_t sbdnum                       : 4;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} cn38xx;
+	struct cvmx_dfa_ncbctl_cn38xx         cn38xxp2;
+	struct cvmx_dfa_ncbctl_s              cn58xx;
+	struct cvmx_dfa_ncbctl_s              cn58xxp1;
+};
+typedef union cvmx_dfa_ncbctl cvmx_dfa_ncbctl_t;
+
+/**
+ * cvmx_dfa_pfc0_cnt
+ */
+union cvmx_dfa_pfc0_cnt {
+	uint64_t u64;
+	struct cvmx_dfa_pfc0_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt0                       : 64; /**< Performance counter 0. When DFA_PFC_GCTL[CNT0ENA] = 1, the event selected by
+                                                         DFA_PFC0_CTL[EVSEL] is counted. See also DFA_PFC_GCTL[CNT0WCLR] and DFA_PFC_GCTL[CNT0RCLR]
+                                                         for special clear count cases available for software data collection. */
+#else
+	uint64_t pfcnt0                       : 64;
+#endif
+	} s;
+	struct cvmx_dfa_pfc0_cnt_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc0_cnt cvmx_dfa_pfc0_cnt_t;
+
+/**
+ * cvmx_dfa_pfc0_ctl
+ */
+union cvmx_dfa_pfc0_ctl {
+	uint64_t u64;
+	struct cvmx_dfa_pfc0_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< "Performance Counter 0 Event Selector.
+                                                          // Events [0-31] are based on PMODE(0:per cluster-DTE 1:per graph)
+                                                         - 0:  \#Total Cycles
+                                                         - 1:  \#LDNODE visits
+                                                         - 2:  \#SDNODE visits
+                                                         - 3:  \#DNODE visits (LD/SD)
+                                                         - 4:  \#LCNODE visits
+                                                         - 5:  \#SCNODE visits
+                                                         - 6:  \#CNODE visits (LC/SC)
+                                                         - 7:  \#LMNODE visits
+                                                         - 8:  \#SMNODE visits
+                                                         - 9:  \#MNODE visits (LM/SM)
+                                                          - 10: \#MONODE visits
+                                                          - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX
+                                                          - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)
+                                                          - 13: \#MEMORY visits (MNODE+MONODE)
+                                                          - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)
+                                                          - 15: \#MPHIDX detected (occur for ->LMNODE transitions)
+                                                          - 16: \#RESCANs detected (occur when HASH collision is detected)
+                                                          - 17: \#GWALK iterations -  stalled--packet data/result buffer
+                                                          - 18: \#GWALK iterations - nonstalled
+                                                          - 19: \#CLOAD iterations
+                                                          - 20: \#MLOAD iterations [NOTE: If PMODE=1 (per-graph) the MLOAD IWORD0.VGID is used to
+                                                          discern graph number].
+                                                          - 21: \#RWORD1+ write operations
+                                                          - 22: \#cycles cluster is busy
+                                                          - 23: \#GWALK instructions
+                                                          - 24: \#CLOAD instructions
+                                                          - 25: \#MLOAD instructions [NOTE: If PMODE = 1 (per-graph) the MLOAD IWORD0.VGID is used to
+                                                          discern graph number].
+                                                          - 26: \#GFREE instructions
+                                                          - 27-30: Reserved
+                                                          - 31: \# node transitions detected (see DFA_PFC_GCTL[SNODE,ENODE, EDNODE] registers
+                                                          Events [32-63] are used only for PMODE = 0 (per-cluster HTE mode).
+                                                          - 32: \#cycles a specific cluster-HTE remains active (valid state)
+                                                          - 33: \#cycles a specific cluster-HTE waits for memory response data
+                                                          - 34: \#cycles a specific cluster-HTE waits in resource stall state (waiting for packet data
+                                                          or result buffer space)
+                                                          - 35: \#cycles a specific cluster-HTE waits in resource pending state
+                                                          - 36-63: Reserved" */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t cldte                        : 4;  /**< Performance counter 0 cluster HTE selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster
+                                                         HTE), this field is used to select/monitor the cluster's HTE number for all events
+                                                         associated with performance counter 0. */
+	uint64_t clnum                        : 2;  /**< Performance counter 0 cluster selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster HTE),
+                                                         this field is used to select/monitor the cluster number for all events associated with
+                                                         performance counter 0. */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t cldte                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_dfa_pfc0_ctl_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc0_ctl cvmx_dfa_pfc0_ctl_t;
+
+/**
+ * cvmx_dfa_pfc1_cnt
+ */
+union cvmx_dfa_pfc1_cnt {
+	uint64_t u64;
+	struct cvmx_dfa_pfc1_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt1                       : 64; /**< Performance counter 1. When DFA_PFC_GCTL[CNT1ENA] = 1, the event selected by
+                                                         DFA_PFC1_CTL[EVSEL] is counted. See also DFA_PFC_GCTL[CNT1WCLR] and DFA_PFC_GCTL[CNT1RCLR]
+                                                         for special clear count cases available for software data collection. */
+#else
+	uint64_t pfcnt1                       : 64;
+#endif
+	} s;
+	struct cvmx_dfa_pfc1_cnt_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc1_cnt cvmx_dfa_pfc1_cnt_t;
+
+/**
+ * cvmx_dfa_pfc1_ctl
+ */
+union cvmx_dfa_pfc1_ctl {
+	uint64_t u64;
+	struct cvmx_dfa_pfc1_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< "Performance Counter 1 Event Selector.
+                                                         - 0:  \#Cycles
+                                                         - 1:  \#LDNODE visits
+                                                         - 2:  \#SDNODE visits
+                                                         - 3:  \#DNODE visits (LD/SD)
+                                                         - 4:  \#LCNODE visits
+                                                         - 5:  \#SCNODE visits
+                                                         - 6:  \#CNODE visits (LC/SC)
+                                                         - 7:  \#LMNODE visits
+                                                         - 8:  \#SMNODE visits
+                                                         - 9:  \#MNODE visits (LM/SM)
+                                                          - 10: \#MONODE visits
+                                                          - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX
+                                                          - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)
+                                                          - 13: \#MEMORY visits (MNODE+MONODE)
+                                                          - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)
+                                                          - 15: \#MPHIDX detected (occur for ->LMNODE transitions)
+                                                          - 16: \#RESCANs detected (occur when HASH collision is detected)
+                                                          - 17: \#GWALK STALLs detected - packet data/result buffer
+                                                          - 18: \#GWALK HTE cycles (all HTE-GNT[3a])
+                                                          - 19: \#CLOAD HTE cycles
+                                                          - 20: \#MLOAD HTE cycles
+                                                          - 21: \#cycles waiting for memory response data
+                                                          - 22: \#cycles waiting in resource stall state (waiting for packet data or result buffer
+                                                          space)
+                                                          - 23: \#cycles waiting in resource pending state
+                                                          - 24: \#RWORD1+ write operations
+                                                          - 25: \#HTE-VLD cycles
+                                                          - 26: \#HTE transitions detected (see DFA_PFC_GCTL[SNODE, ENODE] registers.)
+                                                          - 27: \#GWALK instructions
+                                                          - 28: \#CLOAD instructions
+                                                          - 29: \#MLOAD instructions
+                                                          - 30: \#GFREE instructions (\#GFREE HTE cycles)
+                                                          - 31: Reserved
+                                                          - 32: \#HTE-busy cycles (all HTE-GNT strobes)" */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t cldte                        : 4;  /**< Performance counter 1 cluster HTE selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster
+                                                         HTE), this field is used to select/monitor the cluster's DTE number for all events
+                                                         associated with performance counter 1. */
+	uint64_t clnum                        : 2;  /**< Performance counter 1 cluster selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster HTE),
+                                                         this field is used to select/monitor the cluster number for all events associated with
+                                                         performance counter 1. */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t cldte                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_dfa_pfc1_ctl_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc1_ctl cvmx_dfa_pfc1_ctl_t;
+
+/**
+ * cvmx_dfa_pfc2_cnt
+ */
+union cvmx_dfa_pfc2_cnt {
+	uint64_t u64;
+	struct cvmx_dfa_pfc2_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt2                       : 64; /**< Performance counter 2. When DFA_PFC_GCTL[CNT2ENA] = 1, the event selected by
+                                                         DFA_PFC2_CTL[EVSEL] is counted. See also DFA_PFC_GCTL[CNT2WCLR] and DFA_PFC_GCTL[CNT2RCLR]
+                                                         for special clear count cases available for software data collection. */
+#else
+	uint64_t pfcnt2                       : 64;
+#endif
+	} s;
+	struct cvmx_dfa_pfc2_cnt_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc2_cnt cvmx_dfa_pfc2_cnt_t;
+
+/**
+ * cvmx_dfa_pfc2_ctl
+ */
+union cvmx_dfa_pfc2_ctl {
+	uint64_t u64;
+	struct cvmx_dfa_pfc2_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< "Performance Counter 2 Event Selector.
+                                                         - 0:  \#Cycles
+                                                         - 1:  \#LDNODE visits
+                                                         - 2:  \#SDNODE visits
+                                                         - 3:  \#DNODE visits (LD/SD)
+                                                         - 4:  \#LCNODE visits
+                                                         - 5:  \#SCNODE visits
+                                                         - 6:  \#CNODE visits (LC/SC)
+                                                         - 7:  \#LMNODE visits
+                                                         - 8:  \#SMNODE visits
+                                                         - 9:  \#MNODE visits (LM/SM)
+                                                          - 10: \#MONODE visits
+                                                          - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX
+                                                          - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)
+                                                          - 13: \#MEMORY visits (MNODE+MONODE)
+                                                          - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)
+                                                          - 15: \#MPHIDX detected (occur for ->LMNODE transitions)
+                                                          - 16: \#RESCANs detected (occur when HASH collision is detected)
+                                                          - 17: \#GWALK STALLs detected--packet data/result buffer
+                                                          - 18: \#GWALK HTE cycles (all HTE-GNT[3a])
+                                                          - 19: \#CLOAD HTE cycles
+                                                          - 20: \#MLOAD HTE cycles
+                                                          - 21: \#cycles waiting for memory response data
+                                                          - 22: \#cycles waiting in resource stall state (waiting for packet data or result buffer
+                                                          space)
+                                                          - 23: \#cycles waiting in resource pending state
+                                                          - 24: \#RWORD1+ write operations
+                                                          - 25: \#HTE-VLD cycles
+                                                          - 26: \#HTE transitions detected (see DFA_PFC_GCTL[SNODE, ENODE] registers
+                                                          - 27: \#GWALK instructions
+                                                          - 28: \#CLOAD instructions
+                                                          - 29: \#MLOAD instructions
+                                                          - 30: \#GFREE instructions (\#GFREE HTE cycles)
+                                                          - 31: Reserved
+                                                          - 32: \#HTE-busy cycles (all HTE-GNT strobes)" */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t cldte                        : 4;  /**< Performance counter 2 cluster HTE selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster
+                                                         HTE), this field is used to select/monitor the cluster's HTE number for all events
+                                                         associated with performance counter 2. */
+	uint64_t clnum                        : 2;  /**< Performance counter 2 cluster selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster HTE),
+                                                         this field is used to select/monitor the cluster number for all events associated with
+                                                         performance counter 2. */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t cldte                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_dfa_pfc2_ctl_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc2_ctl cvmx_dfa_pfc2_ctl_t;
+
+/**
+ * cvmx_dfa_pfc3_cnt
+ */
+union cvmx_dfa_pfc3_cnt {
+	uint64_t u64;
+	struct cvmx_dfa_pfc3_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t pfcnt3                       : 64; /**< Performance counter 3. When DFA_PFC_GCTL[CNT3ENA] = 1, the event selected by
+                                                         DFA_PFC3_CTL[EVSEL] is counted. See also DFA_PFC_GCTL[CNT3WCLR] and DFA_PFC_GCTL[CNT3RCLR]
+                                                         for special clear count cases available for software data collection. */
+#else
+	uint64_t pfcnt3                       : 64;
+#endif
+	} s;
+	struct cvmx_dfa_pfc3_cnt_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc3_cnt cvmx_dfa_pfc3_cnt_t;
+
+/**
+ * cvmx_dfa_pfc3_ctl
+ */
+union cvmx_dfa_pfc3_ctl {
+	uint64_t u64;
+	struct cvmx_dfa_pfc3_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t evsel                        : 6;  /**< "Performance Counter 3 Event Selector.
+                                                         - 0:  \#Cycles
+                                                         - 1:  \#LDNODE visits
+                                                         - 2:  \#SDNODE visits
+                                                         - 3:  \#DNODE visits (LD/SD)
+                                                         - 4:  \#LCNODE visits
+                                                         - 5:  \#SCNODE visits
+                                                         - 6:  \#CNODE visits (LC/SC)
+                                                         - 7:  \#LMNODE visits
+                                                         - 8:  \#SMNODE visits
+                                                         - 9:  \#MNODE visits (LM/SM)
+                                                          - 10: \#MONODE visits
+                                                          - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX
+                                                          - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)
+                                                          - 13: \#MEMORY visits (MNODE+MONODE)
+                                                          - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)
+                                                          - 15: \#MPHIDX detected (occur for ->LMNODE transitions)
+                                                          - 16: \#RESCANs detected (occur when HASH collision is detected)
+                                                          - 17: \#GWALK STALLs detected--Packet data/Result Buffer
+                                                          - 18: \#GWALK HTE cycles (all HTE-GNT[3a])
+                                                          - 19: \#CLOAD HTE cycles
+                                                          - 20: \#MLOAD HTE cycles
+                                                          - 21: \#cycles waiting for memory response data
+                                                          - 22: \#cycles waiting in resource stall state (waiting for packet data or result buffer
+                                                          space)
+                                                          - 23: \#cycles waiting in resource pending state
+                                                          - 24: \#RWORD1+ write operations
+                                                          - 25: \#HTE-VLD cycles
+                                                          - 26: \#HTE transitions detected (see DFA_PFC_GCTL[SNODE, ENODE] registers.)
+                                                          - 27: \#GWALK instructions
+                                                          - 28: \#CLOAD instructions
+                                                          - 29: \#MLOAD instructions
+                                                          - 30: \#GFREE instructions (\#GFREE HTE cycles)
+                                                          - 31: Reserved
+                                                          - 32: \#HTE-busy cycles (all HTE-GNT strobes)" */
+	uint64_t reserved_6_7                 : 2;
+	uint64_t cldte                        : 4;  /**< Performance counter 3 cluster HTE selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster
+                                                         HTE), this field is used to select/monitor the cluster's HTE number for all events
+                                                         associated with performance counter 3. */
+	uint64_t clnum                        : 2;  /**< Performance counter 3 cluster selector. When DFA_PFC_GCTL[PMODE] = 0 (per-cluster HTE),
+                                                         this field is used to select/monitor the cluster number for all events associated with
+                                                         performance counter 3. */
+#else
+	uint64_t clnum                        : 2;
+	uint64_t cldte                        : 4;
+	uint64_t reserved_6_7                 : 2;
+	uint64_t evsel                        : 6;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} s;
+	struct cvmx_dfa_pfc3_ctl_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc3_ctl cvmx_dfa_pfc3_ctl_t;
+
+/**
+ * cvmx_dfa_pfc_gctl
+ */
+union cvmx_dfa_pfc_gctl {
+	uint64_t u64;
+	struct cvmx_dfa_pfc_gctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_31_63               : 33;
+	uint64_t vgid                         : 8;  /**< Virtual graph ID. When PMODE = 1 (per-graph selector), this field is used to
+                                                         select/monitor only those events which are associated with this selected VGID (virtual
+                                                         graph ID). This field is used globally across all four performance counters. */
+	uint64_t pmode                        : 1;  /**< Select mode.
+                                                         - 0: Events are selected on a per-cluster HTE number (CLNUM/CLDTE).
+                                                          DFA_PFCx_CTL[CLNUM,CLDTE] specifies the cluster-HTE for each 1 (of 4) performance
+                                                          counters.
+                                                         - 1: Events are selected on a per-graph basis (VGID = virtual graph ID).
+                                                          Only EVSEL = [0...31] can be used in conjunction with
+                                                          PMODE = 1. DFA_PFC_GCTL[VGID] specifies the virtual graph ID used across all four
+                                                          performance counters. */
+	uint64_t ednode                       : 2;  /**< Ending DNODE Selector.
+                                                          When ENODE=0/1(*DNODE), this field is used to further specify the Ending DNODE transition
+                                                          su.b-type:
+                                                         - 0: ALL DNODE sub-types
+                                                         - 1: ->D2e (explicit DNODE transition node-arc alone transitions to DNODE).
+                                                         - 2: ->D2i (implicit DNODE transition:arc-present triggers transition).
+                                                         - 3: ->D1r (rescan DNODE transition). */
+	uint64_t enode                        : 4;  /**< Ending Node Selector
+                                                          When DFA_PFCx_CTL[EVSEL]=Node Transition(31), the ENODE field is used to select Ending
+                                                          Node, and the SNODE field is used to select the Starting Node.
+                                                         - 0: LDNODE
+                                                         - 1: SDNODE
+                                                         - 2: LCNODE
+                                                         - 3: SCNODE
+                                                         - 4: LMNODE
+                                                         - 5: SMNODE
+                                                         - 6: MONODE
+                                                         - 7: RESERVED
+                                                         - 8: LONODE
+                                                         - 9: SONODE */
+	uint64_t snode                        : 4;  /**< Starting Node Selector
+                                                          When DFA_PFCx_CTL[EVSEL]=Node Transition(31), the SNODE field is used to select Starting
+                                                          Node, and the ENODE field is used to select the Ending Node.
+                                                         - 0: LDNODE
+                                                         - 1: SDNODE
+                                                         - 2: LCNODE
+                                                         - 3: SCNODE
+                                                         - 4: LMNODE
+                                                         - 5: SMNODE
+                                                         - 6: MONODE
+                                                         - 7: RESERVED
+                                                         - 8: LONODE
+                                                         - 9: SONODE */
+	uint64_t cnt3rclr                     : 1;  /**< Performance counter 3 read clear. If this bit is set, CSR read operations to DFA_PFC3_CNT
+                                                         clear the count value. This allows software to maintain 'cumulative' counters to avoid
+                                                         hardware wraparound. */
+	uint64_t cnt2rclr                     : 1;  /**< Performance counter 2 read clear. If this bit is set, CSR read operations to DFA_PFC2_CNT
+                                                         clear the count value. This allows software to maintain 'cumulative' counters to avoid
+                                                         hardware wraparound. */
+	uint64_t cnt1rclr                     : 1;  /**< Performance counter 1 read clear. If this bit is set, CSR read operations to DFA_PFC1_CNT
+                                                         clear the count value. This allows software to maintain 'cumulative' counters to avoid
+                                                         hardware wraparound. */
+	uint64_t cnt0rclr                     : 1;  /**< Performance counter 0 read clear. If this bit is set, CSR read operations to DFA_PFC0_CNT
+                                                         clear the count value. This allows software to maintain 'cumulative' counters to avoid
+                                                         hardware wraparound. */
+	uint64_t cnt3wclr                     : 1;  /**< Performance counter 3 write clear. If this bit is set, CSR write operations to
+                                                         DFA_PFC3_CNT clear the count value. If this bit is clear, CSR write operations to
+                                                         DFA_PFC3_CNT continue the count from the written value. */
+	uint64_t cnt2wclr                     : 1;  /**< Performance counter 2 write clear. If this bit is set, CSR write operations to
+                                                         DFA_PFC2_CNT clear the count value. If this bit is clear, CSR write operations to
+                                                         DFA_PFC2_CNT continue the count from the written value. */
+	uint64_t cnt1wclr                     : 1;  /**< Performance counter 1 write clear. If this bit is set, CSR write operations to
+                                                         DFA_PFC1_CNT clear the count value. If this bit is clear, CSR write operations to
+                                                         DFA_PFC1_CNT continue the count from the written value. */
+	uint64_t cnt0wclr                     : 1;  /**< Performance counter 0 write clear. If this bit is set, CSR write operations to
+                                                         DFA_PFC0_CNT clear the count value. If this bit is clear, CSR write operations to
+                                                         DFA_PFC0_CNT continue the count from the written value. */
+	uint64_t cnt3ena                      : 1;  /**< Performance counter 3 enable. When this bit is set, the performance counter 3 is enabled. */
+	uint64_t cnt2ena                      : 1;  /**< Performance counter 2 enable. When this bit is set, the performance counter 2 is enabled. */
+	uint64_t cnt1ena                      : 1;  /**< Performance counter 1 enable. When this bit is set, the performance counter 1 is enabled. */
+	uint64_t cnt0ena                      : 1;  /**< Performance counter 0 enable. When this bit is set, the performance counter 0 is enabled. */
+#else
+	uint64_t cnt0ena                      : 1;
+	uint64_t cnt1ena                      : 1;
+	uint64_t cnt2ena                      : 1;
+	uint64_t cnt3ena                      : 1;
+	uint64_t cnt0wclr                     : 1;
+	uint64_t cnt1wclr                     : 1;
+	uint64_t cnt2wclr                     : 1;
+	uint64_t cnt3wclr                     : 1;
+	uint64_t cnt0rclr                     : 1;
+	uint64_t cnt1rclr                     : 1;
+	uint64_t cnt2rclr                     : 1;
+	uint64_t cnt3rclr                     : 1;
+	uint64_t snode                        : 4;
+	uint64_t enode                        : 4;
+	uint64_t ednode                       : 2;
+	uint64_t pmode                        : 1;
+	uint64_t vgid                         : 8;
+	uint64_t reserved_31_63               : 33;
+#endif
+	} s;
+	struct cvmx_dfa_pfc_gctl_s            cn78xx;
+};
+typedef union cvmx_dfa_pfc_gctl cvmx_dfa_pfc_gctl_t;
+
+/**
+ * cvmx_dfa_rodt_comp_ctl
+ *
+ * DFA_RODT_COMP_CTL = DFA RLD Compensation control (For read "on die termination")
+ *
+ */
+union cvmx_dfa_rodt_comp_ctl {
+	uint64_t u64;
+	struct cvmx_dfa_rodt_comp_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_17_63               : 47;
+	uint64_t enable                       : 1;  /**< Read On Die Termination Enable
+                                                         (0=disable, 1=enable) */
+	uint64_t reserved_12_15               : 4;
+	uint64_t nctl                         : 4;  /**< Compensation control bits */
+	uint64_t reserved_5_7                 : 3;
+	uint64_t pctl                         : 5;  /**< Compensation control bits */
+#else
+	uint64_t pctl                         : 5;
+	uint64_t reserved_5_7                 : 3;
+	uint64_t nctl                         : 4;
+	uint64_t reserved_12_15               : 4;
+	uint64_t enable                       : 1;
+	uint64_t reserved_17_63               : 47;
+#endif
+	} s;
+	struct cvmx_dfa_rodt_comp_ctl_s       cn58xx;
+	struct cvmx_dfa_rodt_comp_ctl_s       cn58xxp1;
+};
+typedef union cvmx_dfa_rodt_comp_ctl cvmx_dfa_rodt_comp_ctl_t;
+
+/**
+ * cvmx_dfa_sbd_dbg0
+ *
+ * DFA_SBD_DBG0 = DFA Scoreboard Debug \#0 Register
+ *
+ * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.
+ * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the
+ * CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)
+ * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an
+ * instruction.
+ */
+union cvmx_dfa_sbd_dbg0 {
+	uint64_t u64;
+	struct cvmx_dfa_sbd_dbg0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd0                         : 64; /**< DFA ScoreBoard \#0 Data
+                                                         For internal use only! (DFA Scoreboard Debug)
+                                                         [63:40] rptr[26:3]: Result Base Pointer
+                                                         [39:24] rwcnt[15:0] Cumulative Result Write Counter
+                                                         [23]    lastgrdrsp: Last Gather-Rd Response
+                                                         [22]    wtgrdrsp: Waiting Gather-Rd Response
+                                                         [21]    wtgrdreq: Waiting for Gather-Rd Issue
+                                                         [20]    glvld: GLPTR/GLCNT Valid
+                                                         [19]    cmpmark: Completion Marked Node Detected
+                                                         [18:17] cmpcode[1:0]: Completion Code
+                                                                       [0=PDGONE/1=PERR/2=RFULL/3=TERM]
+                                                         [16]    cmpdet: Completion Detected
+                                                         [15]    wthdrwrcmtrsp: Waiting for HDR RWrCmtRsp
+                                                         [14]    wtlastwrcmtrsp: Waiting for LAST RESULT
+                                                                       RWrCmtRsp
+                                                         [13]    hdrwrreq: Waiting for HDR RWrReq
+                                                         [12]    wtrwrreq: Waiting for RWrReq
+                                                         [11]    wtwqwrreq: Waiting for WQWrReq issue
+                                                         [10]    lastprdrspeot: Last Packet-Rd Response
+                                                         [9]     lastprdrsp: Last Packet-Rd Response
+                                                         [8]     wtprdrsp:  Waiting for PRdRsp EOT
+                                                         [7]     wtprdreq: Waiting for PRdReq Issue
+                                                         [6]     lastpdvld: PDPTR/PDLEN Valid
+                                                         [5]     pdvld: Packet Data Valid
+                                                         [4]     wqvld: WQVLD
+                                                         [3]     wqdone: WorkQueue Done condition
+                                                                       a) WQWrReq issued(for WQPTR<>0) OR
+                                                                       b) HDR RWrCmtRsp completed)
+                                                         [2]     rwstf: Resultant write STF/P Mode
+                                                         [1]     pdldt: Packet-Data LDT mode
+                                                         [0]     gmode: Gather-Mode */
+#else
+	uint64_t sbd0                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_sbd_dbg0_s            cn31xx;
+	struct cvmx_dfa_sbd_dbg0_s            cn38xx;
+	struct cvmx_dfa_sbd_dbg0_s            cn38xxp2;
+	struct cvmx_dfa_sbd_dbg0_s            cn58xx;
+	struct cvmx_dfa_sbd_dbg0_s            cn58xxp1;
+};
+typedef union cvmx_dfa_sbd_dbg0 cvmx_dfa_sbd_dbg0_t;
+
+/**
+ * cvmx_dfa_sbd_dbg1
+ *
+ * DFA_SBD_DBG1 = DFA Scoreboard Debug \#1 Register
+ *
+ * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.
+ * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the
+ * CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)
+ * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an
+ * instruction.
+ */
+union cvmx_dfa_sbd_dbg1 {
+	uint64_t u64;
+	struct cvmx_dfa_sbd_dbg1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd1                         : 64; /**< DFA ScoreBoard \#1 Data
+                                                         For internal use only! (DFA Scoreboard Debug)
+                                                         [63:61] wqptr[35:33]: Work Queue Pointer
+                                                         [60:52] rptr[35:27]: Result Base Pointer
+                                                         [51:16] pdptr[35:0]: Packet Data Pointer
+                                                         [15:0]  pdcnt[15:0]: Packet Data Counter */
+#else
+	uint64_t sbd1                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_sbd_dbg1_s            cn31xx;
+	struct cvmx_dfa_sbd_dbg1_s            cn38xx;
+	struct cvmx_dfa_sbd_dbg1_s            cn38xxp2;
+	struct cvmx_dfa_sbd_dbg1_s            cn58xx;
+	struct cvmx_dfa_sbd_dbg1_s            cn58xxp1;
+};
+typedef union cvmx_dfa_sbd_dbg1 cvmx_dfa_sbd_dbg1_t;
+
+/**
+ * cvmx_dfa_sbd_dbg2
+ *
+ * DFA_SBD_DBG2 = DFA Scoreboard Debug \#2 Register
+ *
+ * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.
+ * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the
+ * CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)
+ * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an
+ * instruction.
+ */
+union cvmx_dfa_sbd_dbg2 {
+	uint64_t u64;
+	struct cvmx_dfa_sbd_dbg2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd2                         : 64; /**< DFA ScoreBoard \#2 Data
+                                                         [63:49] wqptr[17:3]: Work Queue Pointer
+                                                         [48:16] rwptr[35:3]: Result Write Pointer
+                                                         [15:0]  prwcnt[15:0]: Pending Result Write Counter */
+#else
+	uint64_t sbd2                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_sbd_dbg2_s            cn31xx;
+	struct cvmx_dfa_sbd_dbg2_s            cn38xx;
+	struct cvmx_dfa_sbd_dbg2_s            cn38xxp2;
+	struct cvmx_dfa_sbd_dbg2_s            cn58xx;
+	struct cvmx_dfa_sbd_dbg2_s            cn58xxp1;
+};
+typedef union cvmx_dfa_sbd_dbg2 cvmx_dfa_sbd_dbg2_t;
+
+/**
+ * cvmx_dfa_sbd_dbg3
+ *
+ * DFA_SBD_DBG3 = DFA Scoreboard Debug \#3 Register
+ *
+ * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.
+ * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the
+ * CSR read.
+ * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)
+ * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an
+ * instruction.
+ */
+union cvmx_dfa_sbd_dbg3 {
+	uint64_t u64;
+	struct cvmx_dfa_sbd_dbg3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t sbd3                         : 64; /**< DFA ScoreBoard \#3 Data
+                                                         [63:49] wqptr[32:18]: Work Queue Pointer
+                                                         [48:16] glptr[35:3]: Gather List Pointer
+                                                         [15:0]  glcnt[15:0]: Gather List Counter */
+#else
+	uint64_t sbd3                         : 64;
+#endif
+	} s;
+	struct cvmx_dfa_sbd_dbg3_s            cn31xx;
+	struct cvmx_dfa_sbd_dbg3_s            cn38xx;
+	struct cvmx_dfa_sbd_dbg3_s            cn38xxp2;
+	struct cvmx_dfa_sbd_dbg3_s            cn58xx;
+	struct cvmx_dfa_sbd_dbg3_s            cn58xxp1;
+};
+typedef union cvmx_dfa_sbd_dbg3 cvmx_dfa_sbd_dbg3_t;
+
+#endif
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfm-defs.h OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfm-defs.h
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfm-defs.h	1970-01-01 05:30:00.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-dfm-defs.h	2014-04-04 15:23:01.000000000 +0530
@@ -0,0 +1,3218 @@
+/***********************license start***************
+ * Copyright (c) 2003-2013  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+
+/**
+ * cvmx-dfm-defs.h
+ *
+ * Configuration and status register (CSR) type definitions for
+ * Octeon dfm.
+ *
+ * This file is auto generated. Do not edit.
+ *
+ * <hr>$Revision$<hr>
+ *
+ */
+#ifndef __CVMX_DFM_DEFS_H__
+#define __CVMX_DFM_DEFS_H__
+
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_CHAR_CTL CVMX_DFM_CHAR_CTL_FUNC()
+static inline uint64_t CVMX_DFM_CHAR_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_CHAR_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000220ull);
+}
+#else
+#define CVMX_DFM_CHAR_CTL (CVMX_ADD_IO_SEG(0x00011800D4000220ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_CHAR_MASK0 CVMX_DFM_CHAR_MASK0_FUNC()
+static inline uint64_t CVMX_DFM_CHAR_MASK0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_CHAR_MASK0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000228ull);
+}
+#else
+#define CVMX_DFM_CHAR_MASK0 (CVMX_ADD_IO_SEG(0x00011800D4000228ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_CHAR_MASK2 CVMX_DFM_CHAR_MASK2_FUNC()
+static inline uint64_t CVMX_DFM_CHAR_MASK2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_CHAR_MASK2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000238ull);
+}
+#else
+#define CVMX_DFM_CHAR_MASK2 (CVMX_ADD_IO_SEG(0x00011800D4000238ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_CHAR_MASK4 CVMX_DFM_CHAR_MASK4_FUNC()
+static inline uint64_t CVMX_DFM_CHAR_MASK4_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_CHAR_MASK4 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000318ull);
+}
+#else
+#define CVMX_DFM_CHAR_MASK4 (CVMX_ADD_IO_SEG(0x00011800D4000318ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_COMP_CTL2 CVMX_DFM_COMP_CTL2_FUNC()
+static inline uint64_t CVMX_DFM_COMP_CTL2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_COMP_CTL2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001B8ull);
+}
+#else
+#define CVMX_DFM_COMP_CTL2 (CVMX_ADD_IO_SEG(0x00011800D40001B8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_CONFIG CVMX_DFM_CONFIG_FUNC()
+static inline uint64_t CVMX_DFM_CONFIG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_CONFIG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000188ull);
+}
+#else
+#define CVMX_DFM_CONFIG (CVMX_ADD_IO_SEG(0x00011800D4000188ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_CONTROL CVMX_DFM_CONTROL_FUNC()
+static inline uint64_t CVMX_DFM_CONTROL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_CONTROL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000190ull);
+}
+#else
+#define CVMX_DFM_CONTROL (CVMX_ADD_IO_SEG(0x00011800D4000190ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_DLL_CTL2 CVMX_DFM_DLL_CTL2_FUNC()
+static inline uint64_t CVMX_DFM_DLL_CTL2_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_DLL_CTL2 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001C8ull);
+}
+#else
+#define CVMX_DFM_DLL_CTL2 (CVMX_ADD_IO_SEG(0x00011800D40001C8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_DLL_CTL3 CVMX_DFM_DLL_CTL3_FUNC()
+static inline uint64_t CVMX_DFM_DLL_CTL3_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_DLL_CTL3 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000218ull);
+}
+#else
+#define CVMX_DFM_DLL_CTL3 (CVMX_ADD_IO_SEG(0x00011800D4000218ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_FCLK_CNT CVMX_DFM_FCLK_CNT_FUNC()
+static inline uint64_t CVMX_DFM_FCLK_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_FCLK_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001E0ull);
+}
+#else
+#define CVMX_DFM_FCLK_CNT (CVMX_ADD_IO_SEG(0x00011800D40001E0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_FNT_BIST CVMX_DFM_FNT_BIST_FUNC()
+static inline uint64_t CVMX_DFM_FNT_BIST_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_FNT_BIST not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40007F8ull);
+}
+#else
+#define CVMX_DFM_FNT_BIST (CVMX_ADD_IO_SEG(0x00011800D40007F8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_FNT_CTL CVMX_DFM_FNT_CTL_FUNC()
+static inline uint64_t CVMX_DFM_FNT_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_FNT_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000400ull);
+}
+#else
+#define CVMX_DFM_FNT_CTL (CVMX_ADD_IO_SEG(0x00011800D4000400ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_FNT_IENA CVMX_DFM_FNT_IENA_FUNC()
+static inline uint64_t CVMX_DFM_FNT_IENA_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_FNT_IENA not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000410ull);
+}
+#else
+#define CVMX_DFM_FNT_IENA (CVMX_ADD_IO_SEG(0x00011800D4000410ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_FNT_SCLK CVMX_DFM_FNT_SCLK_FUNC()
+static inline uint64_t CVMX_DFM_FNT_SCLK_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_FNT_SCLK not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000418ull);
+}
+#else
+#define CVMX_DFM_FNT_SCLK (CVMX_ADD_IO_SEG(0x00011800D4000418ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_FNT_STAT CVMX_DFM_FNT_STAT_FUNC()
+static inline uint64_t CVMX_DFM_FNT_STAT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_FNT_STAT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000408ull);
+}
+#else
+#define CVMX_DFM_FNT_STAT (CVMX_ADD_IO_SEG(0x00011800D4000408ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_IFB_CNT CVMX_DFM_IFB_CNT_FUNC()
+static inline uint64_t CVMX_DFM_IFB_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_IFB_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001D0ull);
+}
+#else
+#define CVMX_DFM_IFB_CNT (CVMX_ADD_IO_SEG(0x00011800D40001D0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_MODEREG_PARAMS0 CVMX_DFM_MODEREG_PARAMS0_FUNC()
+static inline uint64_t CVMX_DFM_MODEREG_PARAMS0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_MODEREG_PARAMS0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001A8ull);
+}
+#else
+#define CVMX_DFM_MODEREG_PARAMS0 (CVMX_ADD_IO_SEG(0x00011800D40001A8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_MODEREG_PARAMS1 CVMX_DFM_MODEREG_PARAMS1_FUNC()
+static inline uint64_t CVMX_DFM_MODEREG_PARAMS1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_MODEREG_PARAMS1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000260ull);
+}
+#else
+#define CVMX_DFM_MODEREG_PARAMS1 (CVMX_ADD_IO_SEG(0x00011800D4000260ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_OPS_CNT CVMX_DFM_OPS_CNT_FUNC()
+static inline uint64_t CVMX_DFM_OPS_CNT_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_OPS_CNT not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001D8ull);
+}
+#else
+#define CVMX_DFM_OPS_CNT (CVMX_ADD_IO_SEG(0x00011800D40001D8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_PHY_CTL CVMX_DFM_PHY_CTL_FUNC()
+static inline uint64_t CVMX_DFM_PHY_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_PHY_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000210ull);
+}
+#else
+#define CVMX_DFM_PHY_CTL (CVMX_ADD_IO_SEG(0x00011800D4000210ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_RESET_CTL CVMX_DFM_RESET_CTL_FUNC()
+static inline uint64_t CVMX_DFM_RESET_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_RESET_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000180ull);
+}
+#else
+#define CVMX_DFM_RESET_CTL (CVMX_ADD_IO_SEG(0x00011800D4000180ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_RLEVEL_CTL CVMX_DFM_RLEVEL_CTL_FUNC()
+static inline uint64_t CVMX_DFM_RLEVEL_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_RLEVEL_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40002A0ull);
+}
+#else
+#define CVMX_DFM_RLEVEL_CTL (CVMX_ADD_IO_SEG(0x00011800D40002A0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_RLEVEL_DBG CVMX_DFM_RLEVEL_DBG_FUNC()
+static inline uint64_t CVMX_DFM_RLEVEL_DBG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_RLEVEL_DBG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40002A8ull);
+}
+#else
+#define CVMX_DFM_RLEVEL_DBG (CVMX_ADD_IO_SEG(0x00011800D40002A8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DFM_RLEVEL_RANKX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DFM_RLEVEL_RANKX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800D4000280ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DFM_RLEVEL_RANKX(offset) (CVMX_ADD_IO_SEG(0x00011800D4000280ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_RODT_MASK CVMX_DFM_RODT_MASK_FUNC()
+static inline uint64_t CVMX_DFM_RODT_MASK_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_RODT_MASK not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000268ull);
+}
+#else
+#define CVMX_DFM_RODT_MASK (CVMX_ADD_IO_SEG(0x00011800D4000268ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_SLOT_CTL0 CVMX_DFM_SLOT_CTL0_FUNC()
+static inline uint64_t CVMX_DFM_SLOT_CTL0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_SLOT_CTL0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001F8ull);
+}
+#else
+#define CVMX_DFM_SLOT_CTL0 (CVMX_ADD_IO_SEG(0x00011800D40001F8ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_SLOT_CTL1 CVMX_DFM_SLOT_CTL1_FUNC()
+static inline uint64_t CVMX_DFM_SLOT_CTL1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_SLOT_CTL1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000200ull);
+}
+#else
+#define CVMX_DFM_SLOT_CTL1 (CVMX_ADD_IO_SEG(0x00011800D4000200ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_TIMING_PARAMS0 CVMX_DFM_TIMING_PARAMS0_FUNC()
+static inline uint64_t CVMX_DFM_TIMING_PARAMS0_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_TIMING_PARAMS0 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000198ull);
+}
+#else
+#define CVMX_DFM_TIMING_PARAMS0 (CVMX_ADD_IO_SEG(0x00011800D4000198ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_TIMING_PARAMS1 CVMX_DFM_TIMING_PARAMS1_FUNC()
+static inline uint64_t CVMX_DFM_TIMING_PARAMS1_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_TIMING_PARAMS1 not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001A0ull);
+}
+#else
+#define CVMX_DFM_TIMING_PARAMS1 (CVMX_ADD_IO_SEG(0x00011800D40001A0ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_WLEVEL_CTL CVMX_DFM_WLEVEL_CTL_FUNC()
+static inline uint64_t CVMX_DFM_WLEVEL_CTL_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_WLEVEL_CTL not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000300ull);
+}
+#else
+#define CVMX_DFM_WLEVEL_CTL (CVMX_ADD_IO_SEG(0x00011800D4000300ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_WLEVEL_DBG CVMX_DFM_WLEVEL_DBG_FUNC()
+static inline uint64_t CVMX_DFM_WLEVEL_DBG_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_WLEVEL_DBG not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D4000308ull);
+}
+#else
+#define CVMX_DFM_WLEVEL_DBG (CVMX_ADD_IO_SEG(0x00011800D4000308ull))
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+static inline uint64_t CVMX_DFM_WLEVEL_RANKX(unsigned long offset)
+{
+	if (!(
+	      (OCTEON_IS_MODEL(OCTEON_CN63XX) && ((offset <= 1))) ||
+	      (OCTEON_IS_MODEL(OCTEON_CN66XX) && ((offset <= 1)))))
+		cvmx_warn("CVMX_DFM_WLEVEL_RANKX(%lu) is invalid on this chip\n", offset);
+	return CVMX_ADD_IO_SEG(0x00011800D40002B0ull) + ((offset) & 1) * 8;
+}
+#else
+#define CVMX_DFM_WLEVEL_RANKX(offset) (CVMX_ADD_IO_SEG(0x00011800D40002B0ull) + ((offset) & 1) * 8)
+#endif
+#if CVMX_ENABLE_CSR_ADDRESS_CHECKING
+#define CVMX_DFM_WODT_MASK CVMX_DFM_WODT_MASK_FUNC()
+static inline uint64_t CVMX_DFM_WODT_MASK_FUNC(void)
+{
+	if (!(OCTEON_IS_MODEL(OCTEON_CN63XX) || OCTEON_IS_MODEL(OCTEON_CN66XX)))
+		cvmx_warn("CVMX_DFM_WODT_MASK not supported on this chip\n");
+	return CVMX_ADD_IO_SEG(0x00011800D40001B0ull);
+}
+#else
+#define CVMX_DFM_WODT_MASK (CVMX_ADD_IO_SEG(0x00011800D40001B0ull))
+#endif
+
+/**
+ * cvmx_dfm_char_ctl
+ *
+ * DFM_CHAR_CTL = DFM Characterization Control
+ * This register is an assortment of various control fields needed to charecterize the DDR3 interface
+ *
+ * Notes:
+ * DR bit applies on the DQ port
+ *
+ */
+union cvmx_dfm_char_ctl {
+	uint64_t u64;
+	struct cvmx_dfm_char_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_44_63               : 20;
+	uint64_t dr                           : 1;  /**< Pattern at Data Rate (not Clock Rate) */
+	uint64_t skew_on                      : 1;  /**< Skew adjacent bits */
+	uint64_t en                           : 1;  /**< Enable characterization */
+	uint64_t sel                          : 1;  /**< Pattern select
+                                                         0 = PRBS
+                                                         1 = Programmable pattern */
+	uint64_t prog                         : 8;  /**< Programmable pattern */
+	uint64_t prbs                         : 32; /**< PRBS Polynomial */
+#else
+	uint64_t prbs                         : 32;
+	uint64_t prog                         : 8;
+	uint64_t sel                          : 1;
+	uint64_t en                           : 1;
+	uint64_t skew_on                      : 1;
+	uint64_t dr                           : 1;
+	uint64_t reserved_44_63               : 20;
+#endif
+	} s;
+	struct cvmx_dfm_char_ctl_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t en                           : 1;  /**< Enable characterization */
+	uint64_t sel                          : 1;  /**< Pattern select
+                                                         0 = PRBS
+                                                         1 = Programmable pattern */
+	uint64_t prog                         : 8;  /**< Programmable pattern */
+	uint64_t prbs                         : 32; /**< PRBS Polynomial */
+#else
+	uint64_t prbs                         : 32;
+	uint64_t prog                         : 8;
+	uint64_t sel                          : 1;
+	uint64_t en                           : 1;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} cn63xx;
+	struct cvmx_dfm_char_ctl_cn63xx       cn63xxp1;
+	struct cvmx_dfm_char_ctl_s            cn66xx;
+};
+typedef union cvmx_dfm_char_ctl cvmx_dfm_char_ctl_t;
+
+/**
+ * cvmx_dfm_char_mask0
+ *
+ * DFM_CHAR_MASK0 = DFM Characterization Control Mask0
+ * This register is an assortment of various control fields needed to charecterize the DDR3 interface
+ */
+union cvmx_dfm_char_mask0 {
+	uint64_t u64;
+	struct cvmx_dfm_char_mask0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t mask                         : 16; /**< Mask for DQ0[15:0] */
+#else
+	uint64_t mask                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_dfm_char_mask0_s          cn63xx;
+	struct cvmx_dfm_char_mask0_s          cn63xxp1;
+	struct cvmx_dfm_char_mask0_s          cn66xx;
+};
+typedef union cvmx_dfm_char_mask0 cvmx_dfm_char_mask0_t;
+
+/**
+ * cvmx_dfm_char_mask2
+ *
+ * DFM_CHAR_MASK2 = DFM Characterization Control Mask2
+ * This register is an assortment of various control fields needed to charecterize the DDR3 interface
+ */
+union cvmx_dfm_char_mask2 {
+	uint64_t u64;
+	struct cvmx_dfm_char_mask2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_16_63               : 48;
+	uint64_t mask                         : 16; /**< Mask for DQ1[15:0] */
+#else
+	uint64_t mask                         : 16;
+	uint64_t reserved_16_63               : 48;
+#endif
+	} s;
+	struct cvmx_dfm_char_mask2_s          cn63xx;
+	struct cvmx_dfm_char_mask2_s          cn63xxp1;
+	struct cvmx_dfm_char_mask2_s          cn66xx;
+};
+typedef union cvmx_dfm_char_mask2 cvmx_dfm_char_mask2_t;
+
+/**
+ * cvmx_dfm_char_mask4
+ *
+ * DFM_CHAR_MASK4 = DFM Characterization Mask4
+ * This register is an assortment of various control fields needed to charecterize the DDR3 interface
+ */
+union cvmx_dfm_char_mask4 {
+	uint64_t u64;
+	struct cvmx_dfm_char_mask4_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_33_63               : 31;
+	uint64_t reset_n_mask                 : 1;  /**< Mask for RESET_N */
+	uint64_t a_mask                       : 16; /**< Mask for A[15:0] */
+	uint64_t ba_mask                      : 3;  /**< Mask for BA[2:0] */
+	uint64_t we_n_mask                    : 1;  /**< Mask for WE_N */
+	uint64_t cas_n_mask                   : 1;  /**< Mask for CAS_N */
+	uint64_t ras_n_mask                   : 1;  /**< Mask for RAS_N */
+	uint64_t odt1_mask                    : 2;  /**< Mask for ODT1
+                                                         For DFM, ODT1 is reserved. */
+	uint64_t odt0_mask                    : 2;  /**< Mask for ODT0 */
+	uint64_t cs1_n_mask                   : 2;  /**< Mask for CS1_N
+                                                         For DFM, CS1_N is reserved. */
+	uint64_t cs0_n_mask                   : 2;  /**< Mask for CS0_N */
+	uint64_t cke_mask                     : 2;  /**< Mask for CKE
+                                                         For DFM, CKE_MASK[1] is reserved. */
+#else
+	uint64_t cke_mask                     : 2;
+	uint64_t cs0_n_mask                   : 2;
+	uint64_t cs1_n_mask                   : 2;
+	uint64_t odt0_mask                    : 2;
+	uint64_t odt1_mask                    : 2;
+	uint64_t ras_n_mask                   : 1;
+	uint64_t cas_n_mask                   : 1;
+	uint64_t we_n_mask                    : 1;
+	uint64_t ba_mask                      : 3;
+	uint64_t a_mask                       : 16;
+	uint64_t reset_n_mask                 : 1;
+	uint64_t reserved_33_63               : 31;
+#endif
+	} s;
+	struct cvmx_dfm_char_mask4_s          cn63xx;
+	struct cvmx_dfm_char_mask4_s          cn66xx;
+};
+typedef union cvmx_dfm_char_mask4 cvmx_dfm_char_mask4_t;
+
+/**
+ * cvmx_dfm_comp_ctl2
+ *
+ * DFM_COMP_CTL2 = DFM Compensation control2
+ *
+ */
+union cvmx_dfm_comp_ctl2 {
+	uint64_t u64;
+	struct cvmx_dfm_comp_ctl2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_34_63               : 30;
+	uint64_t ddr__ptune                   : 4;  /**< DDR pctl from compensation circuit
+                                                         The encoded value provides debug information for the
+                                                         compensation impedance on P-pullup */
+	uint64_t ddr__ntune                   : 4;  /**< DDR nctl from compensation circuit
+                                                         The encoded value provides debug information for the
+                                                         compensation impedance on N-pulldown */
+	uint64_t m180                         : 1;  /**< Cap impedance at 180 ohm (instead of 240 ohm) */
+	uint64_t byp                          : 1;  /**< Bypass mode
+                                                         Use compensation setting from PTUNE,NTUNE */
+	uint64_t ptune                        : 4;  /**< PCTL impedance control in bypass mode */
+	uint64_t ntune                        : 4;  /**< NCTL impedance control in bypass mode */
+	uint64_t rodt_ctl                     : 4;  /**< NCTL RODT impedance control bits
+                                                         0000 = No ODT
+                                                         0001 = 20 ohm
+                                                         0010 = 30 ohm
+                                                         0011 = 40 ohm
+                                                         0100 = 60 ohm
+                                                         0101 = 120 ohm
+                                                         0110-1111 = Reserved */
+	uint64_t cmd_ctl                      : 4;  /**< Drive strength control for CMD/A/RESET_N/CKE drivers
+                                                         0001 = 24 ohm
+                                                         0010 = 26.67 ohm
+                                                         0011 = 30 ohm
+                                                         0100 = 34.3 ohm
+                                                         0101 = 40 ohm
+                                                         0110 = 48 ohm
+                                                         0111 = 60 ohm
+                                                         0000,1000-1111 = Reserved */
+	uint64_t ck_ctl                       : 4;  /**< Drive strength control for CK/CS_N/ODT drivers
+                                                         0001 = 24 ohm
+                                                         0010 = 26.67 ohm
+                                                         0011 = 30 ohm
+                                                         0100 = 34.3 ohm
+                                                         0101 = 40 ohm
+                                                         0110 = 48 ohm
+                                                         0111 = 60 ohm
+                                                         0000,1000-1111 = Reserved */
+	uint64_t dqx_ctl                      : 4;  /**< Drive strength control for DQ/DQS drivers
+                                                         0001 = 24 ohm
+                                                         0010 = 26.67 ohm
+                                                         0011 = 30 ohm
+                                                         0100 = 34.3 ohm
+                                                         0101 = 40 ohm
+                                                         0110 = 48 ohm
+                                                         0111 = 60 ohm
+                                                         0000,1000-1111 = Reserved */
+#else
+	uint64_t dqx_ctl                      : 4;
+	uint64_t ck_ctl                       : 4;
+	uint64_t cmd_ctl                      : 4;
+	uint64_t rodt_ctl                     : 4;
+	uint64_t ntune                        : 4;
+	uint64_t ptune                        : 4;
+	uint64_t byp                          : 1;
+	uint64_t m180                         : 1;
+	uint64_t ddr__ntune                   : 4;
+	uint64_t ddr__ptune                   : 4;
+	uint64_t reserved_34_63               : 30;
+#endif
+	} s;
+	struct cvmx_dfm_comp_ctl2_s           cn63xx;
+	struct cvmx_dfm_comp_ctl2_s           cn63xxp1;
+	struct cvmx_dfm_comp_ctl2_s           cn66xx;
+};
+typedef union cvmx_dfm_comp_ctl2 cvmx_dfm_comp_ctl2_t;
+
+/**
+ * cvmx_dfm_config
+ *
+ * DFM_CONFIG = DFM Memory Configuration Register
+ *
+ * This register controls certain parameters of  Memory Configuration
+ *
+ * Notes:
+ * a. The self refresh entry sequence(s) power the DLL up/down (depending on DFM_MODEREG_PARAMS[DLL])
+ * when DFM_CONFIG[SREF_WITH_DLL] is set
+ * b. Prior to the self-refresh exit sequence, DFM_MODEREG_PARAMS should be re-programmed (if needed) to the
+ * appropriate values
+ *
+ * DFM Bringup Sequence:
+ * 1. SW must ensure there are no pending DRAM transactions and that the DDR PLL and the DLL have been initialized.
+ * 2. Write DFM_COMP_CTL2, DFM_CONTROL, DFM_WODT_MASK, DFM_RODT_MASK, DFM_DUAL_MEMCFG, DFM_TIMING_PARAMS0, DFM_TIMING_PARAMS1,
+ *    DFM_MODEREG_PARAMS0, DFM_MODEREG_PARAMS1, DFM_RESET_CTL (with DDR3RST=0), DFM_CONFIG (with INIT_START=0)
+ *    with appropriate values, if necessary.
+ * 3. Wait 200us, then write DFM_RESET_CTL[DDR3RST] = 1.
+ * 4. Initialize all ranks at once by writing DFM_CONFIG[RANKMASK][n] = 1, DFM_CONFIG[INIT_STATUS][n] = 1, and DFM_CONFIG[INIT_START] = 1
+ *    where n is a valid rank index for the specific board configuration.
+ * 5. for each rank n to be write-leveled [
+ *       if auto write-leveling is desired [
+ *           write DFM_CONFIG[RANKMASK][n] = 1, DFM_WLEVEL_CTL appropriately and DFM_CONFIG[INIT_START] = 1
+ *           wait until DFM_WLEVEL_RANKn[STATUS] = 3
+ *       ] else [
+ *           write DFM_WLEVEL_RANKn with appropriate values
+ *       ]
+ *    ]
+ * 6. for each rank n to be read-leveled [
+ *       if auto read-leveling is desired [
+ *           write DFM_CONFIG[RANKMASK][n] = 1, DFM_RLEVEL_CTL appropriately and DFM_CONFIG[INIT_START] = 1
+ *           wait until DFM_RLEVEL_RANKn[STATUS] = 3
+ *       ] else [
+ *           write DFM_RLEVEL_RANKn with appropriate values
+ *       ]
+ *    ]
+ */
+union cvmx_dfm_config {
+	uint64_t u64;
+	struct cvmx_dfm_config_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_59_63               : 5;
+	uint64_t early_unload_d1_r1           : 1;  /**< Reserved */
+	uint64_t early_unload_d1_r0           : 1;  /**< Reserved */
+	uint64_t early_unload_d0_r1           : 1;  /**< When set, unload the PHY silo one cycle early for Rank 1
+                                                         reads.
+                                                         The recommended EARLY_UNLOAD_D0_R1 value can be calculated
+                                                         after the final DFM_RLEVEL_RANK1[BYTE*] values are
+                                                         selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting
+                                                         for rank 1 (i.e. calculate maxset=MAX(DFM_RLEVEL_RANK1[BYTEi])
+                                                         across all i), then set EARLY_UNLOAD_D0_R1
+                                                         when the low two bits of this largest setting is not
+                                                         3 (i.e. EARLY_UNLOAD_D0_R1 = (maxset<1:0>!=3)). */
+	uint64_t early_unload_d0_r0           : 1;  /**< When set, unload the PHY silo one cycle early for Rank 0
+                                                         reads.
+                                                         The recommended EARLY_UNLOAD_D0_R0 value can be calculated
+                                                         after the final DFM_RLEVEL_RANK0[BYTE*] values are
+                                                         selected (as part of read-leveling initialization).
+                                                         Then, determine the largest read-leveling setting
+                                                         for rank 0 (i.e. calculate maxset=MAX(DFM_RLEVEL_RANK0[BYTEi])
+                                                         across all i), then set EARLY_UNLOAD_D0_R0
+                                                         when the low two bits of this largest setting is not
+                                                         3 (i.e. EARLY_UNLOAD_D0_R0 = (maxset<1:0>!=3)). */
+	uint64_t init_status                  : 4;  /**< Indicates status of initialization
+                                                         INIT_STATUS[n] = 1 implies rank n has been initialized
+                                                         SW must set necessary INIT_STATUS bits with the
+                                                         same DFM_CONFIG write that initiates
+                                                         power-up/init and self-refresh exit sequences
+                                                         (if the required INIT_STATUS bits are not already
+                                                         set before DFM initiates the sequence).
+                                                         INIT_STATUS determines the chip-selects that assert
+                                                         during refresh, ZQCS, and precharge power-down and
+                                                         self-refresh entry/exit SEQUENCE's.
+                                                         INIT_STATUS<3:2> must be zero. */
+	uint64_t mirrmask                     : 4;  /**< Mask determining which ranks are address-mirrored.
+                                                         MIRRMASK<n> = 1 means Rank n addresses are mirrored
+                                                         for 0 <= n <= 1
+                                                         A mirrored read/write has these differences:
+                                                          - DDR_BA<1> is swapped with DDR_BA<0>
+                                                          - DDR_A<8> is swapped with DDR_A<7>
+                                                          - DDR_A<6> is swapped with DDR_A<5>
+                                                          - DDR_A<4> is swapped with DDR_A<3>
+                                                         MIRRMASK<3:2> must be zero.
+                                                         When RANK_ENA=0, MIRRMASK<1> MBZ */
+	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized.
+                                                         To write-level/read-level/initialize rank i, set RANKMASK<i>
+                                                                         RANK_ENA=1               RANK_ENA=0
+                                                           RANKMASK<0> =    CS0                  CS0 and CS1
+                                                           RANKMASK<1> =    CS1                      MBZ
+                                                         For read/write leveling, each rank has to be leveled separately,
+                                                         so RANKMASK should only have one bit set.
+                                                         RANKMASK is not used during self-refresh entry/exit and
+                                                         precharge power-down entry/exit instruction sequences.
+                                                         RANKMASK<3:2> must be zero.
+                                                         When RANK_ENA=0, RANKMASK<1> MBZ */
+	uint64_t rank_ena                     : 1;  /**< RANK enable (for use with multiple ranks)
+                                                         The RANK_ENA bit enables
+                                                         the drive of the CS_N[1:0] and ODT_<1:0> pins differently based on the
+                                                         (PBANK_LSB-1) address bit. */
+	uint64_t sref_with_dll                : 1;  /**< Self-refresh entry/exit write MR1 and MR2
+                                                         When set, self-refresh entry and exit instruction sequences
+                                                         write MR1 and MR2 (in all ranks). (The writes occur before
+                                                         self-refresh entry, and after self-refresh exit.)
+                                                         When clear, self-refresh entry and exit instruction sequences
+                                                         do not write any registers in the DDR3 parts. */
+	uint64_t early_dqx                    : 1;  /**< Send DQx signals one CK cycle earlier for the case when
+                                                         the shortest DQx lines have a larger delay than the CK line */
+	uint64_t sequence                     : 3;  /**< Instruction sequence that is run after a 0->1
+                                                         transition on DFM_CONFIG[INIT_START]. Self-refresh entry and
+                                                         precharge power-down entry and exit SEQUENCE's can also
+                                                         be initiated automatically by hardware.
+                                                         0=power-up/init                  (RANKMASK used, MR0, MR1, MR2, and MR3 written)
+                                                         1=read-leveling                  (RANKMASK used, MR3 written)
+                                                         2=self-refresh entry             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)
+                                                         3=self-refresh exit,             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)
+                                                         4=precharge power-down entry     (all ranks participate)
+                                                         5=precharge power-down exit      (all ranks participate)
+                                                         6=write-leveling                 (RANKMASK used, MR1 written)
+                                                         7=illegal
+                                                         Precharge power-down entry and exit SEQUENCE's may
+                                                         be automatically generated by the HW when IDLEPOWER!=0.
+                                                         Self-refresh entry SEQUENCE's may be automatically
+                                                         generated by hardware upon a chip warm or soft reset
+                                                         sequence when DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.
+                                                         DFM writes the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 CSR field values
+                                                         to the Mode registers in the DRAM parts (MR0, MR1, MR2, and MR3) as part of some of these sequences.
+                                                         Refer to the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 descriptions for more details.
+                                                         The DFR_CKE pin gets activated as part of power-up/init,
+                                                         self-refresh exit, and precharge power-down exit sequences.
+                                                         The DFR_CKE pin gets de-activated as part of self-refresh entry,
+                                                         precharge power-down entry, or DRESET assertion.
+                                                         If there are two consecutive power-up/init's without
+                                                         a DRESET assertion between them, DFM asserts DFR_CKE as part of
+                                                         the first power-up/init, and continues to assert DFR_CKE
+                                                         through the remainder of the first and the second power-up/init.
+                                                         If DFR_CKE deactivation and reactivation is needed for
+                                                         a second power-up/init, a DRESET assertion is required
+                                                         between the first and the second. */
+	uint64_t ref_zqcs_int                 : 19; /**< Refresh & ZQCS interval represented in \#of 512 fclk
+                                                         increments. A Refresh sequence is triggered when bits
+                                                         [24:18] are equal to 0, and a ZQCS sequence is triggered
+                                                         when [36:18] are equal to 0.
+                                                         Program [24:18] to RND-DN(tREFI/clkPeriod/512)
+                                                         Program [36:25] to RND-DN(ZQCS_Interval/clkPeriod/(512*64)). Note
+                                                         that this value should always be greater than 32, to account for
+                                                         resistor calibration delays.
+                                                         000_00000000_00000000: RESERVED
+                                                         Max Refresh interval = 127 * 512           = 65024 fclks
+                                                         Max ZQCS interval    = (8*256*256-1) * 512 = 268434944 fclks ~ 335ms for a 1.25 ns clock
+                                                         DFM_CONFIG[INIT_STATUS] determines which ranks receive
+                                                         the REF / ZQCS. DFM does not send any refreshes / ZQCS's
+                                                         when DFM_CONFIG[INIT_STATUS]=0. */
+	uint64_t reset                        : 1;  /**< Reset oneshot pulse for refresh counter,
+                                                         and DFM_OPS_CNT, DFM_IFB_CNT, and DFM_FCLK_CNT
+                                                         CSR's. SW should write this to a one, then re-write
+                                                         it to a zero to cause the reset. */
+	uint64_t ecc_adr                      : 1;  /**< Must be zero. */
+	uint64_t forcewrite                   : 4;  /**< Force the oldest outstanding write to complete after
+                                                         having waited for 2^FORCEWRITE cycles.  0=disabled. */
+	uint64_t idlepower                    : 3;  /**< Enter precharge power-down mode after the memory
+                                                         controller has been idle for 2^(2+IDLEPOWER) cycles.
+                                                         0=disabled.
+                                                         This field should only be programmed after initialization.
+                                                         DFM_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL
+                                                         is disabled during the precharge power-down. */
+	uint64_t pbank_lsb                    : 4;  /**< Physical bank address bit select
+                                                         Encoding used to determine which memory address
+                                                         bit position represents the rank(or bunk) bit used to enable 1(of 2)
+                                                         ranks(via chip enables) supported by the DFM DDR3 interface.
+                                                         Reverting to the explanation for ROW_LSB, PBANK_LSB would be ROW_LSB bit +
+                                                         \#rowbits + \#rankbits.
+                                                         PBANK_LSB
+                                                             - 0: rank = mem_adr[24]
+                                                             - 1: rank = mem_adr[25]
+                                                             - 2: rank = mem_adr[26]
+                                                             - 3: rank = mem_adr[27]
+                                                             - 4: rank = mem_adr[28]
+                                                             - 5: rank = mem_adr[29]
+                                                             - 6: rank = mem_adr[30]
+                                                             - 7: rank = mem_adr[31]
+                                                          - 8-15:  RESERVED
+                                                         DESIGN NOTE: The DFM DDR3 memory bus is 16b wide, therefore DOES NOT
+                                                         support standard 64b/72b DDR3 DIMM modules. The board designer should
+                                                         populate the DFM DDR3 interface using either TWO x8bit DDR3 devices
+                                                         (or a single x16bit device if available) to fully populate the 16b
+                                                         DFM DDR3 data bus.
+                                                         The DFM DDR3 memory controller supports either 1(or 2) rank(s) based
+                                                         on how much total memory is desired for the DFA application. See
+                                                         RANK_ENA CSR bit when enabling for dual-ranks.
+                                                         SW NOTE:
+                                                             1) When RANK_ENA=0, SW must properly configure the PBANK_LSB to
+                                                                reference upper unused memory address bits.
+                                                             2) When RANK_ENA=1 (dual ranks), SW must configure PBANK_LSB to
+                                                                reference the upper most address bit based on the total size
+                                                                of the rank.
+                                                         For example, for a DFM DDR3 memory populated using Samsung's k4b1g0846c-f7
+                                                         1Gb(256MB) (16M x 8 bit x 8 bank) DDR3 parts, the column address width = 10 and
+                                                         the device row address width = 14b.  The single x8bit device contains 128MB, and
+                                                         requires TWO such parts to populate the DFM 16b DDR3 interface. This then yields
+                                                         a total rank size = 256MB = 2^28.
+                                                         For a single-rank configuration (RANK_ENA=0), SW would program PBANK_LSB>=3 to
+                                                         select mem_adr[x] bits above the legal DFM address range for mem_adr[27:0]=256MB.
+                                                         For a dual-rank configuration (RANK_ENA=1), SW would program PBANK_LSB=4 to select
+                                                         rank=mem_adr[28] as the bit used to determine which 256MB rank (of 512MB total) to
+                                                         access (via rank chip enables - see: DFM DDR3 CS0[1:0] pins for connection to
+                                                         upper and lower rank). */
+	uint64_t row_lsb                      : 3;  /**< Row Address bit select
+                                                         Encoding used to determine which memory address
+                                                         bit position represents the low order DDR ROW address.
+                                                         The DFM memory address [31:4] which references octawords
+                                                         needs to be translated to DRAM addresses (bnk,row,col,bunk)
+                                                         mem_adr[31:4]:
+                                                           3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+                                                           1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4
+                                                          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                          |       ROW[m:n]            |     COL[13:3]       | BA
+                                                          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                         See:
+                                                           BA[2:0]:   mem_adr[6:4]
+                                                           COL[13:0]: [mem_adr[17:7],3'd0]
+                                                               NOTE: The extracted COL address is always 14b fixed size width,
+                                                               and upper unused bits are ignored by the DRAM device.
+                                                           ROW[15:0]: Extraction of ROW starting address bit is programmable,
+                                                           and is dependent on the \#column bits supported by the DRAM device.
+                                                           The actual starting bit of the ROW can actually span into the
+                                                           high order bits of the COL[13:3] field described above.
+                                                                  ROW_LSB    ROW[15:0]
+                                                                --------------------------
+                                                                   - 0:      mem_adr[26:11]
+                                                                   - 1:      mem_adr[27:12]
+                                                                   - 2:      mem_adr[28:13]
+                                                                   - 3:      mem_adr[29:14]
+                                                                   - 4:      mem_adr[30:15]
+                                                                   - 5:      mem_adr[31:16]
+                                                                  6,7:     [1'b0, mem_adr[31:17]]  For current DDR3 Jedec spec - UNSUPPORTED
+                                                         For example, for Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)
+                                                         DDR3 parts, the column address width = 10. Therefore,
+                                                              BA[3:0] = mem_adr[6:4] / COL[9:0] = [mem_adr[13:7],3'd0], and
+                                                         we would want the row starting address to be extracted from mem_adr[14].
+                                                         Therefore, a ROW_LSB=3, will extract the row from mem_adr[29:14]. */
+	uint64_t ecc_ena                      : 1;  /**< Must be zero. */
+	uint64_t init_start                   : 1;  /**< A 0->1 transition starts the DDR memory sequence that is
+                                                         selected by DFM_CONFIG[SEQUENCE].  This register is a
+                                                         oneshot and clears itself each time it is set. */
+#else
+	uint64_t init_start                   : 1;
+	uint64_t ecc_ena                      : 1;
+	uint64_t row_lsb                      : 3;
+	uint64_t pbank_lsb                    : 4;
+	uint64_t idlepower                    : 3;
+	uint64_t forcewrite                   : 4;
+	uint64_t ecc_adr                      : 1;
+	uint64_t reset                        : 1;
+	uint64_t ref_zqcs_int                 : 19;
+	uint64_t sequence                     : 3;
+	uint64_t early_dqx                    : 1;
+	uint64_t sref_with_dll                : 1;
+	uint64_t rank_ena                     : 1;
+	uint64_t rankmask                     : 4;
+	uint64_t mirrmask                     : 4;
+	uint64_t init_status                  : 4;
+	uint64_t early_unload_d0_r0           : 1;
+	uint64_t early_unload_d0_r1           : 1;
+	uint64_t early_unload_d1_r0           : 1;
+	uint64_t early_unload_d1_r1           : 1;
+	uint64_t reserved_59_63               : 5;
+#endif
+	} s;
+	struct cvmx_dfm_config_s              cn63xx;
+	struct cvmx_dfm_config_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_55_63               : 9;
+	uint64_t init_status                  : 4;  /**< Indicates status of initialization
+                                                         INIT_STATUS[n] = 1 implies rank n has been initialized
+                                                         SW must set necessary INIT_STATUS bits with the
+                                                         same DFM_CONFIG write that initiates
+                                                         power-up/init and self-refresh exit sequences
+                                                         (if the required INIT_STATUS bits are not already
+                                                         set before DFM initiates the sequence).
+                                                         INIT_STATUS determines the chip-selects that assert
+                                                         during refresh, ZQCS, and precharge power-down and
+                                                         self-refresh entry/exit SEQUENCE's.
+                                                         INIT_STATUS<3:2> must be zero. */
+	uint64_t mirrmask                     : 4;  /**< Mask determining which ranks are address-mirrored.
+                                                         MIRRMASK<n> = 1 means Rank n addresses are mirrored
+                                                         for 0 <= n <= 1
+                                                         A mirrored read/write has these differences:
+                                                          - DDR_BA<1> is swapped with DDR_BA<0>
+                                                          - DDR_A<8> is swapped with DDR_A<7>
+                                                          - DDR_A<6> is swapped with DDR_A<5>
+                                                          - DDR_A<4> is swapped with DDR_A<3>
+                                                         MIRRMASK<3:2> must be zero.
+                                                         When RANK_ENA=0, MIRRMASK<1> MBZ */
+	uint64_t rankmask                     : 4;  /**< Mask to select rank to be leveled/initialized.
+                                                         To write-level/read-level/initialize rank i, set RANKMASK<i>
+                                                                         RANK_ENA=1               RANK_ENA=0
+                                                           RANKMASK<0> =    CS0                  CS0 and CS1
+                                                           RANKMASK<1> =    CS1                      MBZ
+                                                         For read/write leveling, each rank has to be leveled separately,
+                                                         so RANKMASK should only have one bit set.
+                                                         RANKMASK is not used during self-refresh entry/exit and
+                                                         precharge power-down entry/exit instruction sequences.
+                                                         RANKMASK<3:2> must be zero.
+                                                         When RANK_ENA=0, RANKMASK<1> MBZ */
+	uint64_t rank_ena                     : 1;  /**< RANK enable (for use with multiple ranks)
+                                                         The RANK_ENA bit enables
+                                                         the drive of the CS_N[1:0] and ODT_<1:0> pins differently based on the
+                                                         (PBANK_LSB-1) address bit. */
+	uint64_t sref_with_dll                : 1;  /**< Self-refresh entry/exit write MR1 and MR2
+                                                         When set, self-refresh entry and exit instruction sequences
+                                                         write MR1 and MR2 (in all ranks). (The writes occur before
+                                                         self-refresh entry, and after self-refresh exit.)
+                                                         When clear, self-refresh entry and exit instruction sequences
+                                                         do not write any registers in the DDR3 parts. */
+	uint64_t early_dqx                    : 1;  /**< Send DQx signals one CK cycle earlier for the case when
+                                                         the shortest DQx lines have a larger delay than the CK line */
+	uint64_t sequence                     : 3;  /**< Instruction sequence that is run after a 0->1
+                                                         transition on DFM_CONFIG[INIT_START]. Self-refresh entry and
+                                                         precharge power-down entry and exit SEQUENCE's can also
+                                                         be initiated automatically by hardware.
+                                                         0=power-up/init                  (RANKMASK used, MR0, MR1, MR2, and MR3 written)
+                                                         1=read-leveling                  (RANKMASK used, MR3 written)
+                                                         2=self-refresh entry             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)
+                                                         3=self-refresh exit,             (all ranks participate, MR1 and MR2 written if SREF_WITH_DLL=1)
+                                                         4=precharge power-down entry     (all ranks participate)
+                                                         5=precharge power-down exit      (all ranks participate)
+                                                         6=write-leveling                 (RANKMASK used, MR1 written)
+                                                         7=illegal
+                                                         Precharge power-down entry and exit SEQUENCE's may
+                                                         be automatically generated by the HW when IDLEPOWER!=0.
+                                                         Self-refresh entry SEQUENCE's may be automatically
+                                                         generated by hardware upon a chip warm or soft reset
+                                                         sequence when DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT] are set.
+                                                         DFM writes the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 CSR field values
+                                                         to the Mode registers in the DRAM parts (MR0, MR1, MR2, and MR3) as part of some of these sequences.
+                                                         Refer to the DFM_MODEREG_PARAMS0 and DFM_MODEREG_PARAMS1 descriptions for more details.
+                                                         The DFR_CKE pin gets activated as part of power-up/init,
+                                                         self-refresh exit, and precharge power-down exit sequences.
+                                                         The DFR_CKE pin gets de-activated as part of self-refresh entry,
+                                                         precharge power-down entry, or DRESET assertion.
+                                                         If there are two consecutive power-up/init's without
+                                                         a DRESET assertion between them, DFM asserts DFR_CKE as part of
+                                                         the first power-up/init, and continues to assert DFR_CKE
+                                                         through the remainder of the first and the second power-up/init.
+                                                         If DFR_CKE deactivation and reactivation is needed for
+                                                         a second power-up/init, a DRESET assertion is required
+                                                         between the first and the second. */
+	uint64_t ref_zqcs_int                 : 19; /**< Refresh & ZQCS interval represented in \#of 512 fclk
+                                                         increments. A Refresh sequence is triggered when bits
+                                                         [24:18] are equal to 0, and a ZQCS sequence is triggered
+                                                         when [36:18] are equal to 0.
+                                                         Program [24:18] to RND-DN(tREFI/clkPeriod/512)
+                                                         Program [36:25] to RND-DN(ZQCS_Interval/clkPeriod/(512*64)). Note
+                                                         that this value should always be greater than 32, to account for
+                                                         resistor calibration delays.
+                                                         000_00000000_00000000: RESERVED
+                                                         Max Refresh interval = 127 * 512           = 65024 fclks
+                                                         Max ZQCS interval    = (8*256*256-1) * 512 = 268434944 fclks ~ 335ms for a 1.25 ns clock
+                                                         DFM_CONFIG[INIT_STATUS] determines which ranks receive
+                                                         the REF / ZQCS. DFM does not send any refreshes / ZQCS's
+                                                         when DFM_CONFIG[INIT_STATUS]=0. */
+	uint64_t reset                        : 1;  /**< Reset oneshot pulse for refresh counter,
+                                                         and DFM_OPS_CNT, DFM_IFB_CNT, and DFM_FCLK_CNT
+                                                         CSR's. SW should write this to a one, then re-write
+                                                         it to a zero to cause the reset. */
+	uint64_t ecc_adr                      : 1;  /**< Must be zero. */
+	uint64_t forcewrite                   : 4;  /**< Force the oldest outstanding write to complete after
+                                                         having waited for 2^FORCEWRITE cycles.  0=disabled. */
+	uint64_t idlepower                    : 3;  /**< Enter precharge power-down mode after the memory
+                                                         controller has been idle for 2^(2+IDLEPOWER) cycles.
+                                                         0=disabled.
+                                                         This field should only be programmed after initialization.
+                                                         DFM_MODEREG_PARAMS0[PPD] determines whether the DRAM DLL
+                                                         is disabled during the precharge power-down. */
+	uint64_t pbank_lsb                    : 4;  /**< Physical bank address bit select
+                                                         Encoding used to determine which memory address
+                                                         bit position represents the rank(or bunk) bit used to enable 1(of 2)
+                                                         ranks(via chip enables) supported by the DFM DDR3 interface.
+                                                         Reverting to the explanation for ROW_LSB, PBANK_LSB would be ROW_LSB bit +
+                                                         \#rowbits + \#rankbits.
+                                                         PBANK_LSB
+                                                             - 0: rank = mem_adr[24]
+                                                             - 1: rank = mem_adr[25]
+                                                             - 2: rank = mem_adr[26]
+                                                             - 3: rank = mem_adr[27]
+                                                             - 4: rank = mem_adr[28]
+                                                             - 5: rank = mem_adr[29]
+                                                             - 6: rank = mem_adr[30]
+                                                             - 7: rank = mem_adr[31]
+                                                          - 8-15:  RESERVED
+                                                         DESIGN NOTE: The DFM DDR3 memory bus is 16b wide, therefore DOES NOT
+                                                         support standard 64b/72b DDR3 DIMM modules. The board designer should
+                                                         populate the DFM DDR3 interface using either TWO x8bit DDR3 devices
+                                                         (or a single x16bit device if available) to fully populate the 16b
+                                                         DFM DDR3 data bus.
+                                                         The DFM DDR3 memory controller supports either 1(or 2) rank(s) based
+                                                         on how much total memory is desired for the DFA application. See
+                                                         RANK_ENA CSR bit when enabling for dual-ranks.
+                                                         SW NOTE:
+                                                             1) When RANK_ENA=0, SW must properly configure the PBANK_LSB to
+                                                                reference upper unused memory address bits.
+                                                             2) When RANK_ENA=1 (dual ranks), SW must configure PBANK_LSB to
+                                                                reference the upper most address bit based on the total size
+                                                                of the rank.
+                                                         For example, for a DFM DDR3 memory populated using Samsung's k4b1g0846c-f7
+                                                         1Gb(256MB) (16M x 8 bit x 8 bank) DDR3 parts, the column address width = 10 and
+                                                         the device row address width = 14b.  The single x8bit device contains 128MB, and
+                                                         requires TWO such parts to populate the DFM 16b DDR3 interface. This then yields
+                                                         a total rank size = 256MB = 2^28.
+                                                         For a single-rank configuration (RANK_ENA=0), SW would program PBANK_LSB>=3 to
+                                                         select mem_adr[x] bits above the legal DFM address range for mem_adr[27:0]=256MB.
+                                                         For a dual-rank configuration (RANK_ENA=1), SW would program PBANK_LSB=4 to select
+                                                         rank=mem_adr[28] as the bit used to determine which 256MB rank (of 512MB total) to
+                                                         access (via rank chip enables - see: DFM DDR3 CS0[1:0] pins for connection to
+                                                         upper and lower rank). */
+	uint64_t row_lsb                      : 3;  /**< Row Address bit select
+                                                         Encoding used to determine which memory address
+                                                         bit position represents the low order DDR ROW address.
+                                                         The DFM memory address [31:4] which references octawords
+                                                         needs to be translated to DRAM addresses (bnk,row,col,bunk)
+                                                         mem_adr[31:4]:
+                                                           3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
+                                                           1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4
+                                                          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                          |       ROW[m:n]            |     COL[13:3]       | BA
+                                                          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                         See:
+                                                           BA[2:0]:   mem_adr[6:4]
+                                                           COL[13:0]: [mem_adr[17:7],3'd0]
+                                                               NOTE: The extracted COL address is always 14b fixed size width,
+                                                               and upper unused bits are ignored by the DRAM device.
+                                                           ROW[15:0]: Extraction of ROW starting address bit is programmable,
+                                                           and is dependent on the \#column bits supported by the DRAM device.
+                                                           The actual starting bit of the ROW can actually span into the
+                                                           high order bits of the COL[13:3] field described above.
+                                                                  ROW_LSB    ROW[15:0]
+                                                                --------------------------
+                                                                   - 0:      mem_adr[26:11]
+                                                                   - 1:      mem_adr[27:12]
+                                                                   - 2:      mem_adr[28:13]
+                                                                   - 3:      mem_adr[29:14]
+                                                                   - 4:      mem_adr[30:15]
+                                                                   - 5:      mem_adr[31:16]
+                                                                  6,7:     [1'b0, mem_adr[31:17]]  For current DDR3 Jedec spec - UNSUPPORTED
+                                                         For example, for Samsung's k4b1g0846c-f7 1Gb (16M x 8 bit x 8 bank)
+                                                         DDR3 parts, the column address width = 10. Therefore,
+                                                              BA[3:0] = mem_adr[6:4] / COL[9:0] = [mem_adr[13:7],3'd0], and
+                                                         we would want the row starting address to be extracted from mem_adr[14].
+                                                         Therefore, a ROW_LSB=3, will extract the row from mem_adr[29:14]. */
+	uint64_t ecc_ena                      : 1;  /**< Must be zero. */
+	uint64_t init_start                   : 1;  /**< A 0->1 transition starts the DDR memory sequence that is
+                                                         selected by DFM_CONFIG[SEQUENCE].  This register is a
+                                                         oneshot and clears itself each time it is set. */
+#else
+	uint64_t init_start                   : 1;
+	uint64_t ecc_ena                      : 1;
+	uint64_t row_lsb                      : 3;
+	uint64_t pbank_lsb                    : 4;
+	uint64_t idlepower                    : 3;
+	uint64_t forcewrite                   : 4;
+	uint64_t ecc_adr                      : 1;
+	uint64_t reset                        : 1;
+	uint64_t ref_zqcs_int                 : 19;
+	uint64_t sequence                     : 3;
+	uint64_t early_dqx                    : 1;
+	uint64_t sref_with_dll                : 1;
+	uint64_t rank_ena                     : 1;
+	uint64_t rankmask                     : 4;
+	uint64_t mirrmask                     : 4;
+	uint64_t init_status                  : 4;
+	uint64_t reserved_55_63               : 9;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_config_s              cn66xx;
+};
+typedef union cvmx_dfm_config cvmx_dfm_config_t;
+
+/**
+ * cvmx_dfm_control
+ *
+ * DFM_CONTROL = DFM Control
+ * This register is an assortment of various control fields needed by the memory controller
+ */
+union cvmx_dfm_control {
+	uint64_t u64;
+	struct cvmx_dfm_control_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t rodt_bprch                   : 1;  /**< When set, the turn-off time for the ODT pin during a
+                                                         RD cmd is delayed an additional DCLK cycle. */
+	uint64_t wodt_bprch                   : 1;  /**< When set, the turn-off time for the ODT pin during a
+                                                         WR cmd is delayed an additional DCLK cycle. */
+	uint64_t bprch                        : 2;  /**< Back Porch Enable: When set, the turn-on time for
+                                                         the default DDR_DQ/DQS drivers is delayed an additional BPRCH FCLK
+                                                         cycles.
+                                                         00 = 0 fclks
+                                                         01 = 1 fclks
+                                                         10 = 2 fclks
+                                                         11 = 3 fclks */
+	uint64_t ext_zqcs_dis                 : 1;  /**< Disable (external) auto-zqcs calibration
+                                                         When clear, DFM runs external ZQ calibration */
+	uint64_t int_zqcs_dis                 : 1;  /**< Disable (internal) auto-zqcs calibration
+                                                         When counter is re-enabled, ZQCS is run immediately,
+                                                         and then every DFM_CONFIG[REF_ZQCS_INT] fclk cycles. */
+	uint64_t auto_fclkdis                 : 1;  /**< When 1, DFM will automatically shut off its internal
+                                                         clock to conserve power when there is no traffic. Note
+                                                         that this has no effect on the DDR3 PHY and pads clocks. */
+	uint64_t xor_bank                     : 1;  /**< Must be zero. */
+	uint64_t max_write_batch              : 4;  /**< Must be set to value 8 */
+	uint64_t nxm_write_en                 : 1;  /**< Must be zero. */
+	uint64_t elev_prio_dis                : 1;  /**< Must be zero. */
+	uint64_t inorder_wr                   : 1;  /**< Must be zero. */
+	uint64_t inorder_rd                   : 1;  /**< Must be zero. */
+	uint64_t throttle_wr                  : 1;  /**< When set, use at most one IFB for writes
+                                                         THROTTLE_RD and THROTTLE_WR must be the same value. */
+	uint64_t throttle_rd                  : 1;  /**< When set, use at most one IFB for reads
+                                                         THROTTLE_RD and THROTTLE_WR must be the same value. */
+	uint64_t fprch2                       : 2;  /**< Front Porch Enable: When set, the turn-off
+                                                         time for the default DDR_DQ/DQS drivers is FPRCH2 fclks earlier.
+                                                         00 = 0 fclks
+                                                         01 = 1 fclks
+                                                         10 = 2 fclks
+                                                         11 = RESERVED */
+	uint64_t pocas                        : 1;  /**< Enable the Posted CAS feature of DDR3.
+                                                         This bit should be set in conjunction with DFM_MODEREG_PARAMS[AL] */
+	uint64_t ddr2t                        : 1;  /**< Turn on the DDR 2T mode. 2 cycle window for CMD and
+                                                         address. This mode helps relieve setup time pressure
+                                                         on the Address and command bus which nominally have
+                                                         a very large fanout. Please refer to Micron's tech
+                                                         note tn_47_01 titled "DDR2-533 Memory Design Guide
+                                                         for Two Dimm Unbuffered Systems" for physical details. */
+	uint64_t bwcnt                        : 1;  /**< Bus utilization counter Clear.
+                                                         Clears the DFM_OPS_CNT, DFM_IFB_CNT, and
+                                                         DFM_FCLK_CNT registers. SW should first write this
+                                                         field to a one, then write this field to a zero to
+                                                         clear the CSR's. */
+	uint64_t rdimm_ena                    : 1;  /**< Must be zero. */
+#else
+	uint64_t rdimm_ena                    : 1;
+	uint64_t bwcnt                        : 1;
+	uint64_t ddr2t                        : 1;
+	uint64_t pocas                        : 1;
+	uint64_t fprch2                       : 2;
+	uint64_t throttle_rd                  : 1;
+	uint64_t throttle_wr                  : 1;
+	uint64_t inorder_rd                   : 1;
+	uint64_t inorder_wr                   : 1;
+	uint64_t elev_prio_dis                : 1;
+	uint64_t nxm_write_en                 : 1;
+	uint64_t max_write_batch              : 4;
+	uint64_t xor_bank                     : 1;
+	uint64_t auto_fclkdis                 : 1;
+	uint64_t int_zqcs_dis                 : 1;
+	uint64_t ext_zqcs_dis                 : 1;
+	uint64_t bprch                        : 2;
+	uint64_t wodt_bprch                   : 1;
+	uint64_t rodt_bprch                   : 1;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dfm_control_s             cn63xx;
+	struct cvmx_dfm_control_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t bprch                        : 2;  /**< Back Porch Enable: When set, the turn-on time for
+                                                         the default DDR_DQ/DQS drivers is delayed an additional BPRCH FCLK
+                                                         cycles.
+                                                         00 = 0 fclks
+                                                         01 = 1 fclks
+                                                         10 = 2 fclks
+                                                         11 = 3 fclks */
+	uint64_t ext_zqcs_dis                 : 1;  /**< Disable (external) auto-zqcs calibration
+                                                         When clear, DFM runs external ZQ calibration */
+	uint64_t int_zqcs_dis                 : 1;  /**< Disable (internal) auto-zqcs calibration
+                                                         When counter is re-enabled, ZQCS is run immediately,
+                                                         and then every DFM_CONFIG[REF_ZQCS_INT] fclk cycles. */
+	uint64_t auto_fclkdis                 : 1;  /**< When 1, DFM will automatically shut off its internal
+                                                         clock to conserve power when there is no traffic. Note
+                                                         that this has no effect on the DDR3 PHY and pads clocks. */
+	uint64_t xor_bank                     : 1;  /**< Must be zero. */
+	uint64_t max_write_batch              : 4;  /**< Must be set to value 8 */
+	uint64_t nxm_write_en                 : 1;  /**< Must be zero. */
+	uint64_t elev_prio_dis                : 1;  /**< Must be zero. */
+	uint64_t inorder_wr                   : 1;  /**< Must be zero. */
+	uint64_t inorder_rd                   : 1;  /**< Must be zero. */
+	uint64_t throttle_wr                  : 1;  /**< When set, use at most one IFB for writes
+                                                         THROTTLE_RD and THROTTLE_WR must be the same value. */
+	uint64_t throttle_rd                  : 1;  /**< When set, use at most one IFB for reads
+                                                         THROTTLE_RD and THROTTLE_WR must be the same value. */
+	uint64_t fprch2                       : 2;  /**< Front Porch Enable: When set, the turn-off
+                                                         time for the default DDR_DQ/DQS drivers is FPRCH2 fclks earlier.
+                                                         00 = 0 fclks
+                                                         01 = 1 fclks
+                                                         10 = 2 fclks
+                                                         11 = RESERVED */
+	uint64_t pocas                        : 1;  /**< Enable the Posted CAS feature of DDR3.
+                                                         This bit should be set in conjunction with DFM_MODEREG_PARAMS[AL] */
+	uint64_t ddr2t                        : 1;  /**< Turn on the DDR 2T mode. 2 cycle window for CMD and
+                                                         address. This mode helps relieve setup time pressure
+                                                         on the Address and command bus which nominally have
+                                                         a very large fanout. Please refer to Micron's tech
+                                                         note tn_47_01 titled "DDR2-533 Memory Design Guide
+                                                         for Two Dimm Unbuffered Systems" for physical details. */
+	uint64_t bwcnt                        : 1;  /**< Bus utilization counter Clear.
+                                                         Clears the DFM_OPS_CNT, DFM_IFB_CNT, and
+                                                         DFM_FCLK_CNT registers. SW should first write this
+                                                         field to a one, then write this field to a zero to
+                                                         clear the CSR's. */
+	uint64_t rdimm_ena                    : 1;  /**< Must be zero. */
+#else
+	uint64_t rdimm_ena                    : 1;
+	uint64_t bwcnt                        : 1;
+	uint64_t ddr2t                        : 1;
+	uint64_t pocas                        : 1;
+	uint64_t fprch2                       : 2;
+	uint64_t throttle_rd                  : 1;
+	uint64_t throttle_wr                  : 1;
+	uint64_t inorder_rd                   : 1;
+	uint64_t inorder_wr                   : 1;
+	uint64_t elev_prio_dis                : 1;
+	uint64_t nxm_write_en                 : 1;
+	uint64_t max_write_batch              : 4;
+	uint64_t xor_bank                     : 1;
+	uint64_t auto_fclkdis                 : 1;
+	uint64_t int_zqcs_dis                 : 1;
+	uint64_t ext_zqcs_dis                 : 1;
+	uint64_t bprch                        : 2;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_control_s             cn66xx;
+};
+typedef union cvmx_dfm_control cvmx_dfm_control_t;
+
+/**
+ * cvmx_dfm_dll_ctl2
+ *
+ * DFM_DLL_CTL2 = DFM (Octeon) DLL control and FCLK reset
+ *
+ *
+ * Notes:
+ * DLL Bringup sequence:
+ * 1. If not done already, set DFM_DLL_CTL2 = 0, except when DFM_DLL_CTL2[DRESET] = 1.
+ * 2. Write 1 to DFM_DLL_CTL2[DLL_BRINGUP]
+ * 3. Wait for 10 FCLK cycles, then write 1 to DFM_DLL_CTL2[QUAD_DLL_ENA]. It may not be feasible to count 10 FCLK cycles, but the
+ *    idea is to configure the delay line into DLL mode by asserting DLL_BRING_UP earlier than [QUAD_DLL_ENA], even if it is one
+ *    cycle early. DFM_DLL_CTL2[QUAD_DLL_ENA] must not change after this point without restarting the DFM and/or DRESET initialization
+ *    sequence.
+ * 4. Read L2D_BST0 and wait for the result. (L2D_BST0 is subject to change depending on how it called in o63. It is still ok to go
+ *    without step 4, since step 5 has enough time)
+ * 5. Wait 10 us.
+ * 6. Write 0 to DFM_DLL_CTL2[DLL_BRINGUP]. DFM_DLL_CTL2[DLL_BRINGUP] must not change after this point without restarting the DFM
+ *    and/or DRESET initialization sequence.
+ * 7. Read L2D_BST0 and wait for the result. (same as step 4, but the idea here is the wait some time before going to step 8, even it
+ *    is one cycle is fine)
+ * 8. Write 0 to DFM_DLL_CTL2[DRESET].  DFM_DLL_CTL2[DRESET] must not change after this point without restarting the DFM and/or
+ *    DRESET initialization sequence.
+ */
+union cvmx_dfm_dll_ctl2 {
+	uint64_t u64;
+	struct cvmx_dfm_dll_ctl2_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t dll_bringup                  : 1;  /**< DLL Bringup */
+	uint64_t dreset                       : 1;  /**< Fclk domain reset.  The reset signal that is used by the
+                                                         Fclk domain is (DRESET || ECLK_RESET). */
+	uint64_t quad_dll_ena                 : 1;  /**< DLL Enable */
+	uint64_t byp_sel                      : 4;  /**< Bypass select
+                                                         0000 : no byte
+                                                         0001 : byte 0
+                                                         - ...
+                                                         1001 : byte 8
+                                                         1010 : all bytes
+                                                         1011-1111 : Reserved */
+	uint64_t byp_setting                  : 8;  /**< Bypass setting
+                                                         DDR3-1600: 00100010
+                                                         DDR3-1333: 00110010
+                                                         DDR3-1066: 01001011
+                                                         DDR3-800 : 01110101
+                                                         DDR3-667 : 10010110
+                                                         DDR3-600 : 10101100 */
+#else
+	uint64_t byp_setting                  : 8;
+	uint64_t byp_sel                      : 4;
+	uint64_t quad_dll_ena                 : 1;
+	uint64_t dreset                       : 1;
+	uint64_t dll_bringup                  : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_dfm_dll_ctl2_s            cn63xx;
+	struct cvmx_dfm_dll_ctl2_s            cn63xxp1;
+	struct cvmx_dfm_dll_ctl2_s            cn66xx;
+};
+typedef union cvmx_dfm_dll_ctl2 cvmx_dfm_dll_ctl2_t;
+
+/**
+ * cvmx_dfm_dll_ctl3
+ *
+ * DFM_DLL_CTL3 = DFM DLL control and FCLK reset
+ *
+ */
+union cvmx_dfm_dll_ctl3 {
+	uint64_t u64;
+	struct cvmx_dfm_dll_ctl3_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_29_63               : 35;
+	uint64_t dll_fast                     : 1;  /**< DLL lock
+                                                         0 = DLL locked */
+	uint64_t dll90_setting                : 8;  /**< Encoded DLL settings. Works in conjuction with
+                                                         DLL90_BYTE_SEL */
+	uint64_t fine_tune_mode               : 1;  /**< Fine Tune Mode */
+	uint64_t dll_mode                     : 1;  /**< DLL Mode */
+	uint64_t dll90_byte_sel               : 4;  /**< Observe DLL settings for selected byte
+                                                         0001 : byte 0
+                                                         - ...
+                                                         1001 : byte 8
+                                                         0000,1010-1111 : Reserved */
+	uint64_t offset_ena                   : 1;  /**< Offset enable
+                                                         0 = disable
+                                                         1 = enable */
+	uint64_t load_offset                  : 1;  /**< Load offset
+                                                         0 : disable
+                                                         1 : load (generates a 1 cycle pulse to the PHY)
+                                                         This register is oneshot and clears itself each time
+                                                         it is set */
+	uint64_t mode_sel                     : 2;  /**< Mode select
+                                                         00 : reset
+                                                         01 : write
+                                                         10 : read
+                                                         11 : write & read */
+	uint64_t byte_sel                     : 4;  /**< Byte select
+                                                         0000 : no byte
+                                                         0001 : byte 0
+                                                         - ...
+                                                         1001 : byte 8
+                                                         1010 : all bytes
+                                                         1011-1111 : Reserved */
+	uint64_t offset                       : 6;  /**< Write/read offset setting
+                                                         [4:0] : offset
+                                                         [5]   : 0 = increment, 1 = decrement
+                                                         Not a 2's complement value */
+#else
+	uint64_t offset                       : 6;
+	uint64_t byte_sel                     : 4;
+	uint64_t mode_sel                     : 2;
+	uint64_t load_offset                  : 1;
+	uint64_t offset_ena                   : 1;
+	uint64_t dll90_byte_sel               : 4;
+	uint64_t dll_mode                     : 1;
+	uint64_t fine_tune_mode               : 1;
+	uint64_t dll90_setting                : 8;
+	uint64_t dll_fast                     : 1;
+	uint64_t reserved_29_63               : 35;
+#endif
+	} s;
+	struct cvmx_dfm_dll_ctl3_s            cn63xx;
+	struct cvmx_dfm_dll_ctl3_s            cn63xxp1;
+	struct cvmx_dfm_dll_ctl3_s            cn66xx;
+};
+typedef union cvmx_dfm_dll_ctl3 cvmx_dfm_dll_ctl3_t;
+
+/**
+ * cvmx_dfm_fclk_cnt
+ *
+ * DFM_FCLK_CNT  = Performance Counters
+ *
+ */
+union cvmx_dfm_fclk_cnt {
+	uint64_t u64;
+	struct cvmx_dfm_fclk_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t fclkcnt                      : 64; /**< Performance Counter that counts fclks
+                                                         64-bit counter. */
+#else
+	uint64_t fclkcnt                      : 64;
+#endif
+	} s;
+	struct cvmx_dfm_fclk_cnt_s            cn63xx;
+	struct cvmx_dfm_fclk_cnt_s            cn63xxp1;
+	struct cvmx_dfm_fclk_cnt_s            cn66xx;
+};
+typedef union cvmx_dfm_fclk_cnt cvmx_dfm_fclk_cnt_t;
+
+/**
+ * cvmx_dfm_fnt_bist
+ *
+ * DFM_FNT_BIST = DFM Front BIST Status
+ *
+ * This register contains Bist Status for DFM Front
+ */
+union cvmx_dfm_fnt_bist {
+	uint64_t u64;
+	struct cvmx_dfm_fnt_bist_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_5_63                : 59;
+	uint64_t cab                          : 1;  /**< Bist Results for CAB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t mrq                          : 1;  /**< Bist Results for MRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t mff                          : 1;  /**< Bist Results for MFF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t rpb                          : 1;  /**< Bist Results for RPB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t mwb                          : 1;  /**< Bist Results for MWB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t mwb                          : 1;
+	uint64_t rpb                          : 1;
+	uint64_t mff                          : 1;
+	uint64_t mrq                          : 1;
+	uint64_t cab                          : 1;
+	uint64_t reserved_5_63                : 59;
+#endif
+	} s;
+	struct cvmx_dfm_fnt_bist_s            cn63xx;
+	struct cvmx_dfm_fnt_bist_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t mrq                          : 1;  /**< Bist Results for MRQ RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t mff                          : 1;  /**< Bist Results for MFF RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t rpb                          : 1;  /**< Bist Results for RPB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+	uint64_t mwb                          : 1;  /**< Bist Results for MWB RAM
+                                                         - 0: GOOD (or bist in progress/never run)
+                                                         - 1: BAD */
+#else
+	uint64_t mwb                          : 1;
+	uint64_t rpb                          : 1;
+	uint64_t mff                          : 1;
+	uint64_t mrq                          : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_fnt_bist_s            cn66xx;
+};
+typedef union cvmx_dfm_fnt_bist cvmx_dfm_fnt_bist_t;
+
+/**
+ * cvmx_dfm_fnt_ctl
+ *
+ * Specify the RSL base addresses for the block
+ *
+ *                  DFM_FNT_CTL = DFM Front Control Register
+ *
+ * This register contains control registers for the DFM Front Section of Logic.
+ */
+union cvmx_dfm_fnt_ctl {
+	uint64_t u64;
+	struct cvmx_dfm_fnt_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t sbe_ena                      : 1;  /**< If SBE_ENA=1 & RECC_ENA=1 then all single bit errors
+                                                         which have been detected/corrected during GWALK reads,
+                                                         will be reported through RWORD0[REA]=ERR code in system
+                                                         memory at the conclusion of the DFA instruction.
+                                                         SWNOTE: The application user may wish to report single
+                                                         bit errors that were corrected through the
+                                                         RWORD0[REA]=ERR codeword.
+                                                         NOTE: This DOES NOT effect the reporting of SBEs in
+                                                         DFM_FNT_STAT[SBE] (which were corrected if RECC_ENA=1).
+                                                         This bit is only here for applications which 'MAY' want
+                                                         to be alerted with an ERR completion code if there were
+                                                         SBEs that were auto-corrected during GWALK instructions.
+                                                         Recap: If there is a SBE and SBE_ENA==1, the "err" field
+                                                         in the data returned to DFA will be set.  If SBE_ENA==0,
+                                                         the "err" is always 0 when there is a SBE; however,
+                                                         regardless of SBE_ENA, DBE will cause "err" to be 1. */
+	uint64_t wecc_ena                     : 1;  /**< If WECC_ENA=1, HW will auto-generate(overwrite) the 10b
+                                                         OWECC codeword during Memory Writes sourced by
+                                                         1) DFA MLOAD instructions, or by 2) NCB-Direct CSR
+                                                         mode writes to DFA memory space. The HW will insert
+                                                         the 10b OWECC inband into OW-DATA[127:118].
+                                                         If WECC_ENA=0, SW is responsible for generating the
+                                                         10b OWECC codeword inband in the upper OW-data[127:118]
+                                                         during Memory writes (to provide SEC/DED coverage for
+                                                         the data during subsequent Memory reads-see RECC_ENA). */
+	uint64_t recc_ena                     : 1;  /**< If RECC_ENA=1, all DFA memory reads sourced by 1) DFA
+                                                         GWALK instructions or by 2) NCB-Direct CSR mode reads
+                                                         to DFA memory space, will be protected by an inband 10b
+                                                         OWECC SEC/DED codeword. The inband OW-DATA[127:118]
+                                                         represents the inband OWECC codeword which offers single
+                                                         bit error correction(SEC)/double bit error detection(DED).
+                                                         [see also DFM_FNT_STAT[SBE,DBE,FADR,FSYN] status fields].
+                                                         The FSYN field contains an encoded value which determines
+                                                         which bit was corrected(for SBE) or detected(for DBE) to
+                                                         help in bit isolation of the error.
+                                                         SW NOTE: If RECC_ENA=1: An NCB-Direct CSR mode read of the
+                                                         upper QW in memory will return ZEROES in the upper 10b of the
+                                                         data word.
+                                                         If RECC_ENA=0: An NCB-Direct CSR mode read of the upper QW in
+                                                         memory will return the RAW 64bits from memory. During memory
+                                                         debug, writing RECC_ENA=0 provides visibility into the raw ECC
+                                                         stored in memory at that time. */
+	uint64_t dfr_ena                      : 1;  /**< DFM Memory Interface Enable
+                                                         The DFM powers up with the DDR3 interface disabled.
+                                                         If the DFA function is required, then after poweron
+                                                         software configures a stable DFM DDR3 memory clock
+                                                         (see: LMCx_DDR_PLL_CTL[DFM_PS_EN, DFM_DIV_RESET]),
+                                                         the DFM DDR3 memory interface can be enabled.
+                                                         When disabled (DFR_ENA=0), all DFM DDR3 memory
+                                                         output and bidirectional pins will be tristated.
+                                                         SW NOTE: The DFR_ENA=1 write MUST occur sometime after
+                                                         the DFM is brought out of reset (ie: after the
+                                                         DFM_DLL_CTL2[DRESET]=0 write). */
+#else
+	uint64_t dfr_ena                      : 1;
+	uint64_t recc_ena                     : 1;
+	uint64_t wecc_ena                     : 1;
+	uint64_t sbe_ena                      : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_dfm_fnt_ctl_s             cn63xx;
+	struct cvmx_dfm_fnt_ctl_s             cn63xxp1;
+	struct cvmx_dfm_fnt_ctl_s             cn66xx;
+};
+typedef union cvmx_dfm_fnt_ctl cvmx_dfm_fnt_ctl_t;
+
+/**
+ * cvmx_dfm_fnt_iena
+ *
+ * DFM_FNT_IENA = DFM Front Interrupt Enable Mask
+ *
+ * This register contains error interrupt enable information for the DFM Front Section of Logic.
+ */
+union cvmx_dfm_fnt_iena {
+	uint64_t u64;
+	struct cvmx_dfm_fnt_iena_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_2_63                : 62;
+	uint64_t dbe_intena                   : 1;  /**< OWECC Double Error Detected(DED) Interrupt Enable
+                                                         When set, the memory controller raises a processor
+                                                         interrupt on detecting an uncorrectable double bit
+                                                         OWECC during a memory read. */
+	uint64_t sbe_intena                   : 1;  /**< OWECC Single Error Corrected(SEC) Interrupt Enable
+                                                         When set, the memory controller raises a processor
+                                                         interrupt on detecting a correctable single bit
+                                                         OWECC error which was corrected during a memory
+                                                         read. */
+#else
+	uint64_t sbe_intena                   : 1;
+	uint64_t dbe_intena                   : 1;
+	uint64_t reserved_2_63                : 62;
+#endif
+	} s;
+	struct cvmx_dfm_fnt_iena_s            cn63xx;
+	struct cvmx_dfm_fnt_iena_s            cn63xxp1;
+	struct cvmx_dfm_fnt_iena_s            cn66xx;
+};
+typedef union cvmx_dfm_fnt_iena cvmx_dfm_fnt_iena_t;
+
+/**
+ * cvmx_dfm_fnt_sclk
+ *
+ * DFM_FNT_SCLK = DFM Front SCLK Control Register
+ *
+ * This register contains control registers for the DFM Front Section of Logic.
+ * NOTE: This register is in USCLK domain and is ised to enable the conditional SCLK grid, as well as
+ * to start a software BiST sequence for the DFM sub-block. (note: the DFM has conditional clocks which
+ * prevent BiST to run under reset automatically).
+ */
+union cvmx_dfm_fnt_sclk {
+	uint64_t u64;
+	struct cvmx_dfm_fnt_sclk_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_3_63                : 61;
+	uint64_t clear_bist                   : 1;  /**< When START_BIST is written 0->1, if CLEAR_BIST=1, all
+                                                         previous BiST state is cleared.
+                                                         NOTES:
+                                                         1) CLEAR_BIST must be written to 1 before START_BIST
+                                                         is written to 1 using a separate CSR write.
+                                                         2) CLEAR_BIST must not be changed after writing START_BIST
+                                                         0->1 until the BIST operation completes. */
+	uint64_t bist_start                   : 1;  /**< When software writes BIST_START=0->1, a BiST is executed
+                                                         for the DFM sub-block.
+                                                         NOTES:
+                                                         1) This bit should only be written after BOTH sclk
+                                                         and fclk have been enabled by software and are stable
+                                                         (see: DFM_FNT_SCLK[SCLKDIS] and instructions on how to
+                                                         enable the DFM DDR3 memory (fclk) - which requires LMC
+                                                         PLL init, DFM clock divider and proper DFM DLL
+                                                         initialization sequence). */
+	uint64_t sclkdis                      : 1;  /**< DFM sclk disable Source
+                                                         When SET, the DFM sclk are disabled (to conserve overall
+                                                         chip clocking power when the DFM function is not used).
+                                                         NOTE: This should only be written to a different value
+                                                         during power-on SW initialization. */
+#else
+	uint64_t sclkdis                      : 1;
+	uint64_t bist_start                   : 1;
+	uint64_t clear_bist                   : 1;
+	uint64_t reserved_3_63                : 61;
+#endif
+	} s;
+	struct cvmx_dfm_fnt_sclk_s            cn63xx;
+	struct cvmx_dfm_fnt_sclk_s            cn63xxp1;
+	struct cvmx_dfm_fnt_sclk_s            cn66xx;
+};
+typedef union cvmx_dfm_fnt_sclk cvmx_dfm_fnt_sclk_t;
+
+/**
+ * cvmx_dfm_fnt_stat
+ *
+ * DFM_FNT_STAT = DFM Front Status Register
+ *
+ * This register contains error status information for the DFM Front Section of Logic.
+ */
+union cvmx_dfm_fnt_stat {
+	uint64_t u64;
+	struct cvmx_dfm_fnt_stat_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_42_63               : 22;
+	uint64_t fsyn                         : 10; /**< Failing Syndrome
+                                                         If SBE_ERR=1, the FSYN code determines which bit was
+                                                         corrected during the OWECC check/correct.
+                                                         NOTE: If both DBE_ERR/SBE_ERR are set, the DBE_ERR has
+                                                         higher priority and FSYN captured will always be for the
+                                                         DBE_ERR detected.
+                                                         The FSYN is "locked down" when either DBE_ERR/SBE_ERR
+                                                         are detected (until these bits are cleared (W1C)).
+                                                         However, if an SBE_ERR occurs first, followed by a
+                                                         DBE_ERR, the higher priority DBE_ERR will re-capture
+                                                         the FSYN for the higher priority error case. */
+	uint64_t fadr                         : 28; /**< Failing Memory octaword address
+                                                         If either SBE_ERR or DBE_ERR are set, the FADR
+                                                         represents the failing octaword address.
+                                                         NOTE: If both DBE_ERR/SBE_ERR are set, the DBE_ERR has
+                                                         higher priority and the FADR captured will always be
+                                                         with the DBE_ERR detected.
+                                                         The FADR is "locked down" when either DBE_ERR/SBE_ERR
+                                                         are detected (until these bits are cleared (W1C)).
+                                                         However, if an SBE_ERR occurs first, followed by a
+                                                         DBE_ERR, the higher priority DBE_ERR will re-capture
+                                                         the FADR for the higher priority error case. */
+	uint64_t reserved_2_3                 : 2;
+	uint64_t dbe_err                      : 1;  /**< Double bit error detected(uncorrectable) during
+                                                         Memory Read.
+                                                         Write of 1 will clear the corresponding error bit */
+	uint64_t sbe_err                      : 1;  /**< Single bit error detected(corrected) during
+                                                         Memory Read.
+                                                         Write of 1 will clear the corresponding error bit */
+#else
+	uint64_t sbe_err                      : 1;
+	uint64_t dbe_err                      : 1;
+	uint64_t reserved_2_3                 : 2;
+	uint64_t fadr                         : 28;
+	uint64_t fsyn                         : 10;
+	uint64_t reserved_42_63               : 22;
+#endif
+	} s;
+	struct cvmx_dfm_fnt_stat_s            cn63xx;
+	struct cvmx_dfm_fnt_stat_s            cn63xxp1;
+	struct cvmx_dfm_fnt_stat_s            cn66xx;
+};
+typedef union cvmx_dfm_fnt_stat cvmx_dfm_fnt_stat_t;
+
+/**
+ * cvmx_dfm_ifb_cnt
+ *
+ * DFM_IFB_CNT  = Performance Counters
+ *
+ */
+union cvmx_dfm_ifb_cnt {
+	uint64_t u64;
+	struct cvmx_dfm_ifb_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t ifbcnt                       : 64; /**< Performance Counter
+                                                         64-bit counter that increments every
+                                                         cycle there is something in the in-flight buffer.
+                                                         Before using, clear counter via DFM_CONTROL.BWCNT. */
+#else
+	uint64_t ifbcnt                       : 64;
+#endif
+	} s;
+	struct cvmx_dfm_ifb_cnt_s             cn63xx;
+	struct cvmx_dfm_ifb_cnt_s             cn63xxp1;
+	struct cvmx_dfm_ifb_cnt_s             cn66xx;
+};
+typedef union cvmx_dfm_ifb_cnt cvmx_dfm_ifb_cnt_t;
+
+/**
+ * cvmx_dfm_modereg_params0
+ *
+ * Notes:
+ * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
+ *
+ */
+union cvmx_dfm_modereg_params0 {
+	uint64_t u64;
+	struct cvmx_dfm_modereg_params0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_25_63               : 39;
+	uint64_t ppd                          : 1;  /**< DLL Control for precharge powerdown
+                                                         0 = Slow exit (DLL off)
+                                                         1 = Fast exit (DLL on)
+                                                         DFM writes this value to MR0[PPD] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[PPD] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t wrp                          : 3;  /**< Write recovery for auto precharge
+                                                         Should be programmed to be equal to or greater than
+                                                         RNDUP[tWR(ns)/tCYC(ns)]
+                                                         000 = 5
+                                                         001 = 5
+                                                         010 = 6
+                                                         011 = 7
+                                                         100 = 8
+                                                         101 = 10
+                                                         110 = 12
+                                                         111 = 14
+                                                         DFM writes this value to MR0[WR] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[WR] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t dllr                         : 1;  /**< DLL Reset
+                                                         DFM writes this value to MR0[DLL] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[DLL] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t tm                           : 1;  /**< Test Mode
+                                                         DFM writes this value to MR0[TM] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[TM] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t rbt                          : 1;  /**< Read Burst Type
+                                                         1 = interleaved (fixed)
+                                                         DFM writes this value to MR0[RBT] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[RBT] value must be 1 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t cl                           : 4;  /**< CAS Latency
+                                                         0010 = 5
+                                                         0100 = 6
+                                                         0110 = 7
+                                                         1000 = 8
+                                                         1010 = 9
+                                                         1100 = 10
+                                                         1110 = 11
+                                                         0001 = 12
+                                                         0011 = 13
+                                                         0101 = 14
+                                                         0111 = 15
+                                                         1001 = 16
+                                                         0000, 1011, 1101, 1111 = Reserved
+                                                         DFM writes this value to MR0[CAS Latency / CL] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         This value must equal the MR0[CAS Latency / CL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t bl                           : 2;  /**< Burst Length
+                                                         0 = 8 (fixed)
+                                                         DFM writes this value to MR0[BL] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR0[BL] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t qoff                         : 1;  /**< Qoff Enable
+                                                         0 = enable
+                                                         DFM writes this value to MR1[Qoff] in the selected DDR3 parts
+                                                         during power-up/init and write-leveling instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[Qoff] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh
+                                                         entry and exit instruction sequences.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         The MR1[Qoff] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t tdqs                         : 1;  /**< TDQS Enable
+                                                         0 = disable
+                                                         DFM writes this value to MR1[TDQS] in the selected DDR3 parts
+                                                         during power-up/init and write-leveling instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[TDQS] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh
+                                                         entry and exit instruction sequences.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t wlev                         : 1;  /**< Write Leveling Enable
+                                                         0 = disable
+                                                         DFM writes MR1[Level]=0 in the selected DDR3 parts
+                                                         during power-up/init and write-leveling instruction sequencing.
+                                                         (DFM also writes MR1[Level]=1 at the beginning of a
+                                                         write-leveling instruction sequence. Write-leveling can only be initiated via the
+                                                         write-leveling instruction sequence.)
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         MR1[Level]=0 in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh
+                                                         entry and exit instruction sequences.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t al                           : 2;  /**< Additive Latency
+                                                         00 = 0
+                                                         01 = CL-1
+                                                         10 = CL-2
+                                                         11 = Reserved
+                                                         DFM writes this value to MR1[AL] in the selected DDR3 parts
+                                                         during power-up/init and write-leveling instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[AL] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh
+                                                         entry and exit instruction sequences.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR1[AL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation.
+                                                         See also DFM_CONTROL[POCAS]. */
+	uint64_t dll                          : 1;  /**< DLL Enable
+                                                         0 = enable
+                                                         1 = disable
+                                                         DFM writes this value to MR1[DLL] in the selected DDR3 parts
+                                                         during power-up/init and write-leveling instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[DLL] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh
+                                                         entry and exit instruction sequences.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR1[DLL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation.
+                                                         In dll-off mode, CL/CWL must be programmed
+                                                         equal to 6/6, respectively, as per the DDR3 specifications. */
+	uint64_t mpr                          : 1;  /**< MPR
+                                                         DFM writes this value to MR3[MPR] in the selected DDR3 parts
+                                                         during power-up/init and read-leveling instruction sequencing.
+                                                         (DFM also writes MR3[MPR]=1 at the beginning of a
+                                                         read-leveling instruction sequence. Read-leveling can only be initiated via the
+                                                         read-leveling instruction sequence.)
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR3[MPR] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t mprloc                       : 2;  /**< MPR Location
+                                                         DFM writes this value to MR3[MPRLoc] in the selected DDR3 parts
+                                                         during power-up/init and read-leveling instruction sequencing.
+                                                         (DFM also writes MR3[MPRLoc]=0 at the beginning of the
+                                                         read-leveling instruction sequence.)
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK].
+                                                         The MR3[MPRLoc] value must be 0 in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+	uint64_t cwl                          : 3;  /**< CAS Write Latency
+                                                         - 000: 5
+                                                         - 001: 6
+                                                         - 010: 7
+                                                         - 011: 8
+                                                         - 100: 9
+                                                         - 101: 10
+                                                         - 110: 11
+                                                         - 111: 12
+                                                         DFM writes this value to MR2[CWL] in the selected DDR3 parts
+                                                         during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[CWL] in all DRAM parts in DFM_CONFIG[INIT_STATUS] ranks during self-refresh
+                                                         entry and exit instruction sequences.
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT].
+                                                         This value must equal the MR2[CWL] value in all the DDR3
+                                                         parts attached to all ranks during normal operation. */
+#else
+	uint64_t cwl                          : 3;
+	uint64_t mprloc                       : 2;
+	uint64_t mpr                          : 1;
+	uint64_t dll                          : 1;
+	uint64_t al                           : 2;
+	uint64_t wlev                         : 1;
+	uint64_t tdqs                         : 1;
+	uint64_t qoff                         : 1;
+	uint64_t bl                           : 2;
+	uint64_t cl                           : 4;
+	uint64_t rbt                          : 1;
+	uint64_t tm                           : 1;
+	uint64_t dllr                         : 1;
+	uint64_t wrp                          : 3;
+	uint64_t ppd                          : 1;
+	uint64_t reserved_25_63               : 39;
+#endif
+	} s;
+	struct cvmx_dfm_modereg_params0_s     cn63xx;
+	struct cvmx_dfm_modereg_params0_s     cn63xxp1;
+	struct cvmx_dfm_modereg_params0_s     cn66xx;
+};
+typedef union cvmx_dfm_modereg_params0 cvmx_dfm_modereg_params0_t;
+
+/**
+ * cvmx_dfm_modereg_params1
+ *
+ * Notes:
+ * These parameters are written into the DDR3 MR0, MR1, MR2 and MR3 registers.
+ *
+ */
+union cvmx_dfm_modereg_params1 {
+	uint64_t u64;
+	struct cvmx_dfm_modereg_params1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_48_63               : 16;
+	uint64_t rtt_nom_11                   : 3;  /**< Must be zero */
+	uint64_t dic_11                       : 2;  /**< Must be zero */
+	uint64_t rtt_wr_11                    : 2;  /**< Must be zero */
+	uint64_t srt_11                       : 1;  /**< Must be zero */
+	uint64_t asr_11                       : 1;  /**< Must be zero */
+	uint64_t pasr_11                      : 3;  /**< Must be zero */
+	uint64_t rtt_nom_10                   : 3;  /**< Must be zero */
+	uint64_t dic_10                       : 2;  /**< Must be zero */
+	uint64_t rtt_wr_10                    : 2;  /**< Must be zero */
+	uint64_t srt_10                       : 1;  /**< Must be zero */
+	uint64_t asr_10                       : 1;  /**< Must be zero */
+	uint64_t pasr_10                      : 3;  /**< Must be zero */
+	uint64_t rtt_nom_01                   : 3;  /**< RTT_NOM Rank 1
+                                                         DFM writes this value to MR1[Rtt_Nom] in the rank 1 (i.e. CS1) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[Rtt_Nom] in all DRAM parts in rank 1 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t dic_01                       : 2;  /**< Output Driver Impedance Control Rank 1
+                                                         DFM writes this value to MR1[D.I.C.] in the rank 1 (i.e. CS1) DDR3 parts
+                                                         when selected during power-up/init and write-leveling instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[D.I.C.] in all DRAM parts in rank 1 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_01                    : 2;  /**< RTT_WR Rank 1
+                                                         DFM writes this value to MR2[Rtt_WR] in the rank 1 (i.e. CS1) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[Rtt_WR] in all DRAM parts in rank 1 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_01                       : 1;  /**< Self-refresh temperature range Rank 1
+                                                         DFM writes this value to MR2[SRT] in the rank 1 (i.e. CS1) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[SRT] in all DRAM parts in rank 1 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_01                       : 1;  /**< Auto self-refresh Rank 1
+                                                         DFM writes this value to MR2[ASR] in the rank 1 (i.e. CS1) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[ASR] in all DRAM parts in rank 1 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_01                      : 3;  /**< Partial array self-refresh Rank 1
+                                                         DFM writes this value to MR2[PASR] in the rank 1 (i.e. CS1) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[PASR] in all DRAM parts in rank 1 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<1>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_nom_00                   : 3;  /**< RTT_NOM Rank 0
+                                                         DFM writes this value to MR1[Rtt_Nom] in the rank 0 (i.e. CS0) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[Rtt_Nom] in all DRAM parts in rank 0 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t dic_00                       : 2;  /**< Output Driver Impedance Control Rank 0
+                                                         DFM writes this value to MR1[D.I.C.] in the rank 0 (i.e. CS0) DDR3 parts
+                                                         when selected during power-up/init and write-leveling instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR1[D.I.C.] in all DRAM parts in rank 0 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t rtt_wr_00                    : 2;  /**< RTT_WR Rank 0
+                                                         DFM writes this value to MR2[Rtt_WR] in the rank 0 (i.e. CS0) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[Rtt_WR] in all DRAM parts in rank 0 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t srt_00                       : 1;  /**< Self-refresh temperature range Rank 0
+                                                         DFM writes this value to MR2[SRT] in the rank 0 (i.e. CS0) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[SRT] in all DRAM parts in rank 0 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t asr_00                       : 1;  /**< Auto self-refresh Rank 0
+                                                         DFM writes this value to MR2[ASR] in the rank 0 (i.e. CS0) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[ASR] in all DRAM parts in rank 0 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+	uint64_t pasr_00                      : 3;  /**< Partial array self-refresh Rank 0
+                                                         DFM writes this value to MR2[PASR] in the rank 0 (i.e. CS0) DDR3 parts
+                                                         when selected during power-up/init instruction sequencing.
+                                                         If DFM_CONFIG[SREF_WITH_DLL] is set, DFM also writes
+                                                         this value to MR2[PASR] in all DRAM parts in rank 0 during self-refresh
+                                                         entry and exit instruction sequences (when DFM_CONFIG[INIT_STATUS<0>]=1).
+                                                         See DFM_CONFIG[SEQUENCE,INIT_START,RANKMASK] and
+                                                         DFM_RESET_CTL[DDR3PWARM,DDR3PSOFT]. */
+#else
+	uint64_t pasr_00                      : 3;
+	uint64_t asr_00                       : 1;
+	uint64_t srt_00                       : 1;
+	uint64_t rtt_wr_00                    : 2;
+	uint64_t dic_00                       : 2;
+	uint64_t rtt_nom_00                   : 3;
+	uint64_t pasr_01                      : 3;
+	uint64_t asr_01                       : 1;
+	uint64_t srt_01                       : 1;
+	uint64_t rtt_wr_01                    : 2;
+	uint64_t dic_01                       : 2;
+	uint64_t rtt_nom_01                   : 3;
+	uint64_t pasr_10                      : 3;
+	uint64_t asr_10                       : 1;
+	uint64_t srt_10                       : 1;
+	uint64_t rtt_wr_10                    : 2;
+	uint64_t dic_10                       : 2;
+	uint64_t rtt_nom_10                   : 3;
+	uint64_t pasr_11                      : 3;
+	uint64_t asr_11                       : 1;
+	uint64_t srt_11                       : 1;
+	uint64_t rtt_wr_11                    : 2;
+	uint64_t dic_11                       : 2;
+	uint64_t rtt_nom_11                   : 3;
+	uint64_t reserved_48_63               : 16;
+#endif
+	} s;
+	struct cvmx_dfm_modereg_params1_s     cn63xx;
+	struct cvmx_dfm_modereg_params1_s     cn63xxp1;
+	struct cvmx_dfm_modereg_params1_s     cn66xx;
+};
+typedef union cvmx_dfm_modereg_params1 cvmx_dfm_modereg_params1_t;
+
+/**
+ * cvmx_dfm_ops_cnt
+ *
+ * DFM_OPS_CNT  = Performance Counters
+ *
+ */
+union cvmx_dfm_ops_cnt {
+	uint64_t u64;
+	struct cvmx_dfm_ops_cnt_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t opscnt                       : 64; /**< Performance Counter
+                                                         64-bit counter that increments when the DDR3 data bus
+                                                         is being used.  Before using, clear counter via
+                                                         DFM_CONTROL.BWCNT
+                                                           DRAM bus utilization = DFM_OPS_CNT/DFM_FCLK_CNT */
+#else
+	uint64_t opscnt                       : 64;
+#endif
+	} s;
+	struct cvmx_dfm_ops_cnt_s             cn63xx;
+	struct cvmx_dfm_ops_cnt_s             cn63xxp1;
+	struct cvmx_dfm_ops_cnt_s             cn66xx;
+};
+typedef union cvmx_dfm_ops_cnt cvmx_dfm_ops_cnt_t;
+
+/**
+ * cvmx_dfm_phy_ctl
+ *
+ * DFM_PHY_CTL = DFM PHY Control
+ *
+ */
+union cvmx_dfm_phy_ctl {
+	uint64_t u64;
+	struct cvmx_dfm_phy_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_15_63               : 49;
+	uint64_t rx_always_on                 : 1;  /**< Disable dynamic DDR3 IO Rx power gating */
+	uint64_t lv_mode                      : 1;  /**< Low Voltage Mode (1.35V) */
+	uint64_t ck_tune1                     : 1;  /**< Clock Tune
+
+                                                         NOTE: DFM UNUSED */
+	uint64_t ck_dlyout1                   : 4;  /**< Clock delay out setting
+
+                                                         NOTE: DFM UNUSED */
+	uint64_t ck_tune0                     : 1;  /**< Clock Tune */
+	uint64_t ck_dlyout0                   : 4;  /**< Clock delay out setting */
+	uint64_t loopback                     : 1;  /**< Loopback enable */
+	uint64_t loopback_pos                 : 1;  /**< Loopback pos mode */
+	uint64_t ts_stagger                   : 1;  /**< TS Staggermode
+                                                         This mode configures output drivers with 2-stage drive
+                                                         strength to avoid undershoot issues on the bus when strong
+                                                         drivers are suddenly turned on. When this mode is asserted,
+                                                         Octeon will configure output drivers to be weak drivers
+                                                         (60 ohm output impedance) at the first FCLK cycle, and
+                                                         change drivers to the designated drive strengths specified
+                                                         in DFM_COMP_CTL2 [CMD_CTL/CK_CTL/DQX_CTL] starting
+                                                         at the following cycle */
+#else
+	uint64_t ts_stagger                   : 1;
+	uint64_t loopback_pos                 : 1;
+	uint64_t loopback                     : 1;
+	uint64_t ck_dlyout0                   : 4;
+	uint64_t ck_tune0                     : 1;
+	uint64_t ck_dlyout1                   : 4;
+	uint64_t ck_tune1                     : 1;
+	uint64_t lv_mode                      : 1;
+	uint64_t rx_always_on                 : 1;
+	uint64_t reserved_15_63               : 49;
+#endif
+	} s;
+	struct cvmx_dfm_phy_ctl_s             cn63xx;
+	struct cvmx_dfm_phy_ctl_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_14_63               : 50;
+	uint64_t lv_mode                      : 1;  /**< Low Voltage Mode (1.35V) */
+	uint64_t ck_tune1                     : 1;  /**< Clock Tune
+
+                                                         NOTE: DFM UNUSED */
+	uint64_t ck_dlyout1                   : 4;  /**< Clock delay out setting
+
+                                                         NOTE: DFM UNUSED */
+	uint64_t ck_tune0                     : 1;  /**< Clock Tune */
+	uint64_t ck_dlyout0                   : 4;  /**< Clock delay out setting */
+	uint64_t loopback                     : 1;  /**< Loopback enable */
+	uint64_t loopback_pos                 : 1;  /**< Loopback pos mode */
+	uint64_t ts_stagger                   : 1;  /**< TS Staggermode
+                                                         This mode configures output drivers with 2-stage drive
+                                                         strength to avoid undershoot issues on the bus when strong
+                                                         drivers are suddenly turned on. When this mode is asserted,
+                                                         Octeon will configure output drivers to be weak drivers
+                                                         (60 ohm output impedance) at the first FCLK cycle, and
+                                                         change drivers to the designated drive strengths specified
+                                                         in DFM_COMP_CTL2 [CMD_CTL/CK_CTL/DQX_CTL] starting
+                                                         at the following cycle */
+#else
+	uint64_t ts_stagger                   : 1;
+	uint64_t loopback_pos                 : 1;
+	uint64_t loopback                     : 1;
+	uint64_t ck_dlyout0                   : 4;
+	uint64_t ck_tune0                     : 1;
+	uint64_t ck_dlyout1                   : 4;
+	uint64_t ck_tune1                     : 1;
+	uint64_t lv_mode                      : 1;
+	uint64_t reserved_14_63               : 50;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_phy_ctl_s             cn66xx;
+};
+typedef union cvmx_dfm_phy_ctl cvmx_dfm_phy_ctl_t;
+
+/**
+ * cvmx_dfm_reset_ctl
+ *
+ * Specify the RSL base addresses for the block
+ *
+ *
+ * Notes:
+ * DDR3RST - DDR3 DRAM parts have a new RESET#
+ * pin that wasn't present in DDR2 parts. The
+ * DDR3RST CSR field controls the assertion of
+ * the new 6xxx pin that attaches to RESET#.
+ * When DDR3RST is set, 6xxx asserts RESET#.
+ * When DDR3RST is clear, 6xxx de-asserts
+ * RESET#.
+ *
+ * DDR3RST is set on a cold reset. Warm and
+ * soft chip resets do not affect the DDR3RST
+ * value. Outside of cold reset, only software
+ * CSR writes change the DDR3RST value.
+ */
+union cvmx_dfm_reset_ctl {
+	uint64_t u64;
+	struct cvmx_dfm_reset_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_4_63                : 60;
+	uint64_t ddr3psv                      : 1;  /**< Must be zero */
+	uint64_t ddr3psoft                    : 1;  /**< Must be zero */
+	uint64_t ddr3pwarm                    : 1;  /**< Must be zero */
+	uint64_t ddr3rst                      : 1;  /**< Memory Reset
+                                                         0 = Reset asserted
+                                                         1 = Reset de-asserted */
+#else
+	uint64_t ddr3rst                      : 1;
+	uint64_t ddr3pwarm                    : 1;
+	uint64_t ddr3psoft                    : 1;
+	uint64_t ddr3psv                      : 1;
+	uint64_t reserved_4_63                : 60;
+#endif
+	} s;
+	struct cvmx_dfm_reset_ctl_s           cn63xx;
+	struct cvmx_dfm_reset_ctl_s           cn63xxp1;
+	struct cvmx_dfm_reset_ctl_s           cn66xx;
+};
+typedef union cvmx_dfm_reset_ctl cvmx_dfm_reset_ctl_t;
+
+/**
+ * cvmx_dfm_rlevel_ctl
+ */
+union cvmx_dfm_rlevel_ctl {
+	uint64_t u64;
+	struct cvmx_dfm_rlevel_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t delay_unload_3               : 1;  /**< When set, unload the PHY silo one cycle later
+                                                         during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 3
+                                                         DELAY_UNLOAD_3 should normally be set, particularly at higher speeds. */
+	uint64_t delay_unload_2               : 1;  /**< When set, unload the PHY silo one cycle later
+                                                         during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 2
+                                                         DELAY_UNLOAD_2 should normally not be set. */
+	uint64_t delay_unload_1               : 1;  /**< When set, unload the PHY silo one cycle later
+                                                         during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 1
+                                                         DELAY_UNLOAD_1 should normally not be set. */
+	uint64_t delay_unload_0               : 1;  /**< When set, unload the PHY silo one cycle later
+                                                         during read-leveling if DFM_RLEVEL_RANKi[BYTE*<1:0>] = 0
+                                                         DELAY_UNLOAD_0 should normally not be set. */
+	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which read-leveling
+                                                         feedback is returned when OR_DIS is set to 1 */
+	uint64_t or_dis                       : 1;  /**< Disable or'ing of bits in a byte lane when computing
+                                                         the read-leveling bitmask
+                                                         OR_DIS should normally not be set. */
+	uint64_t offset_en                    : 1;  /**< Use DFM_RLEVEL_CTL[OFFSET] to calibrate read
+                                                         level dskew settings */
+	uint64_t offset                       : 4;  /**< Pick final_setting-offset (if set) for the read level
+                                                         deskew setting instead of the middle of the largest
+                                                         contiguous sequence of 1's in the bitmask */
+	uint64_t byte                         : 4;  /**< 0 <= BYTE <= 1
+                                                         Byte index for which bitmask results are saved
+                                                         in DFM_RLEVEL_DBG */
+#else
+	uint64_t byte                         : 4;
+	uint64_t offset                       : 4;
+	uint64_t offset_en                    : 1;
+	uint64_t or_dis                       : 1;
+	uint64_t bitmask                      : 8;
+	uint64_t delay_unload_0               : 1;
+	uint64_t delay_unload_1               : 1;
+	uint64_t delay_unload_2               : 1;
+	uint64_t delay_unload_3               : 1;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} s;
+	struct cvmx_dfm_rlevel_ctl_s          cn63xx;
+	struct cvmx_dfm_rlevel_ctl_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_9_63                : 55;
+	uint64_t offset_en                    : 1;  /**< Use DFM_RLEVEL_CTL[OFFSET] to calibrate read
+                                                         level dskew settings */
+	uint64_t offset                       : 4;  /**< Pick final_setting-offset (if set) for the read level
+                                                         deskew setting instead of the middle of the largest
+                                                         contiguous sequence of 1's in the bitmask */
+	uint64_t byte                         : 4;  /**< 0 <= BYTE <= 1
+                                                         Byte index for which bitmask results are saved
+                                                         in DFM_RLEVEL_DBG */
+#else
+	uint64_t byte                         : 4;
+	uint64_t offset                       : 4;
+	uint64_t offset_en                    : 1;
+	uint64_t reserved_9_63                : 55;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_rlevel_ctl_s          cn66xx;
+};
+typedef union cvmx_dfm_rlevel_ctl cvmx_dfm_rlevel_ctl_t;
+
+/**
+ * cvmx_dfm_rlevel_dbg
+ *
+ * Notes:
+ * A given read of DFM_RLEVEL_DBG returns the read-leveling pass/fail results for all possible
+ * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW read-leveled.
+ * DFM_RLEVEL_CTL[BYTE] selects the particular byte.
+ * To get these pass/fail results for another different rank, you must run the hardware read-leveling
+ * again. For example, it is possible to get the BITMASK results for every byte of every rank
+ * if you run read-leveling separately for each rank, probing DFM_RLEVEL_DBG between each
+ * read-leveling.
+ */
+union cvmx_dfm_rlevel_dbg {
+	uint64_t u64;
+	struct cvmx_dfm_rlevel_dbg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t bitmask                      : 64; /**< Bitmask generated during deskew settings sweep
+                                                         BITMASK[n]=0 means deskew setting n failed
+                                                         BITMASK[n]=1 means deskew setting n passed
+                                                         for 0 <= n <= 63 */
+#else
+	uint64_t bitmask                      : 64;
+#endif
+	} s;
+	struct cvmx_dfm_rlevel_dbg_s          cn63xx;
+	struct cvmx_dfm_rlevel_dbg_s          cn63xxp1;
+	struct cvmx_dfm_rlevel_dbg_s          cn66xx;
+};
+typedef union cvmx_dfm_rlevel_dbg cvmx_dfm_rlevel_dbg_t;
+
+/**
+ * cvmx_dfm_rlevel_rank#
+ *
+ * Notes:
+ * This is TWO CSRs per DFM, one per each rank.
+ *
+ * Deskew setting is measured in units of 1/4 FCLK, so the above BYTE* values can range over 16 FCLKs.
+ *
+ * Each CSR is written by HW during a read-leveling sequence for the rank. (HW sets STATUS==3 after HW read-leveling completes for the rank.)
+ * If HW is unable to find a match per DFM_RLEVEL_CTL[OFFSET_EN] and DFM_RLEVEL_CTL[OFFSET], then HW will set DFM_RLEVEL_RANKn[BYTE*<5:0>]
+ * to 0.
+ *
+ * Each CSR may also be written by SW, but not while a read-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)
+ *
+ * SW initiates a HW read-leveling sequence by programming DFM_RLEVEL_CTL and writing INIT_START=1 with SEQUENCE=1 in DFM_CONFIG.
+ * See DFM_RLEVEL_CTL.
+ */
+union cvmx_dfm_rlevel_rankx {
+	uint64_t u64;
+	struct cvmx_dfm_rlevel_rankx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_56_63               : 8;
+	uint64_t status                       : 2;  /**< Indicates status of the read-levelling and where
+                                                         the BYTE* programmings in <35:0> came from:
+                                                         0 = BYTE* values are their reset value
+                                                         1 = BYTE* values were set via a CSR write to this register
+                                                         2 = read-leveling sequence currently in progress (BYTE* values are unpredictable)
+                                                         3 = BYTE* values came from a complete read-leveling sequence */
+	uint64_t reserved_12_53               : 42;
+	uint64_t byte1                        : 6;  /**< Deskew setting */
+	uint64_t byte0                        : 6;  /**< Deskew setting */
+#else
+	uint64_t byte0                        : 6;
+	uint64_t byte1                        : 6;
+	uint64_t reserved_12_53               : 42;
+	uint64_t status                       : 2;
+	uint64_t reserved_56_63               : 8;
+#endif
+	} s;
+	struct cvmx_dfm_rlevel_rankx_s        cn63xx;
+	struct cvmx_dfm_rlevel_rankx_s        cn63xxp1;
+	struct cvmx_dfm_rlevel_rankx_s        cn66xx;
+};
+typedef union cvmx_dfm_rlevel_rankx cvmx_dfm_rlevel_rankx_t;
+
+/**
+ * cvmx_dfm_rodt_mask
+ *
+ * DFM_RODT_MASK = DFM Read OnDieTermination mask
+ * System designers may desire to terminate DQ/DQS/DM lines for higher frequency DDR operations
+ * especially on a multi-rank system. DDR3 DQ/DM/DQS I/O's have built in
+ * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF
+ * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts
+ * in that rank. System designers may prefer different combinations of ODT ON's for reads
+ * into different ranks. Octeon supports full programmability by way of the mask register below.
+ * Each Rank position has its own 8-bit programmable field.
+ * When the controller does a read to that rank, it sets the 4 ODT pins to the MASK pins below.
+ * For eg., When doing a read into Rank0, a system designer may desire to terminate the lines
+ * with the resistor on Dimm0/Rank1. The mask RODT_D0_R0 would then be [00000010].
+ * Octeon drives the appropriate mask values on the ODT pins by default. If this feature is not
+ * required, write 0 in this register. Note that, as per the DDR3 specifications, the ODT pin
+ * for the rank that is being read should always be 0.
+ *
+ * Notes:
+ * - Notice that when there is only one rank, all valid fields must be zero.  This is because there is no
+ * "other" rank to terminate lines for.  Read ODT is meant for multirank systems.
+ * - For a two rank system and a read op to rank0: use RODT_D0_R0<1> to terminate lines on rank1.
+ * - For a two rank system and a read op to rank1: use RODT_D0_R1<0> to terminate lines on rank0.
+ * - Therefore, when a given RANK is selected, the RODT mask for that RANK is used.
+ *
+ * DFM always reads 128-bit words independently via one read CAS operation per word.
+ * When a RODT mask bit is set, DFM asserts the OCTEON ODT output
+ * pin(s) starting (CL - CWL) CK's after the read CAS operation. Then, OCTEON
+ * normally continues to assert the ODT output pin(s) for 5+DFM_CONTROL[RODT_BPRCH] more CK's
+ * - for a total of 6+DFM_CONTROL[RODT_BPRCH] CK's for the entire 128-bit read -
+ * satisfying the 6 CK DDR3 ODTH8 requirements.
+ *
+ * But it is possible for OCTEON to issue two 128-bit reads separated by as few as
+ * RtR = 4 or 5 (6 if DFM_CONTROL[RODT_BPRCH]=1) CK's. In that case, OCTEON asserts the ODT output pin(s)
+ * for the RODT mask of the first 128-bit read for RtR CK's, then asserts
+ * the ODT output pin(s) for the RODT mask of the second 128-bit read for 6+DFM_CONTROL[RODT_BPRCH] CK's
+ * (or less if a third 128-bit read follows within 4 or 5 (or 6) CK's of this second 128-bit read).
+ * Note that it may be necessary to force DFM to space back-to-back 128-bit reads
+ * to different ranks apart by at least 6+DFM_CONTROL[RODT_BPRCH] CK's to prevent DDR3 ODTH8 violations.
+ */
+union cvmx_dfm_rodt_mask {
+	uint64_t u64;
+	struct cvmx_dfm_rodt_mask_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t rodt_d3_r1                   : 8;  /**< Must be zero. */
+	uint64_t rodt_d3_r0                   : 8;  /**< Must be zero. */
+	uint64_t rodt_d2_r1                   : 8;  /**< Must be zero. */
+	uint64_t rodt_d2_r0                   : 8;  /**< Must be zero. */
+	uint64_t rodt_d1_r1                   : 8;  /**< Must be zero. */
+	uint64_t rodt_d1_r0                   : 8;  /**< Must be zero. */
+	uint64_t rodt_d0_r1                   : 8;  /**< Read ODT mask RANK1
+                                                         RODT_D0_R1<7:1> must be zero in all cases.
+                                                         RODT_D0_R1<0> must also be zero if RANK_ENA is not set. */
+	uint64_t rodt_d0_r0                   : 8;  /**< Read ODT mask RANK0
+                                                         RODT_D0_R0<7:2,0> must be zero in all cases.
+                                                         RODT_D0_R0<1> must also be zero if RANK_ENA is not set. */
+#else
+	uint64_t rodt_d0_r0                   : 8;
+	uint64_t rodt_d0_r1                   : 8;
+	uint64_t rodt_d1_r0                   : 8;
+	uint64_t rodt_d1_r1                   : 8;
+	uint64_t rodt_d2_r0                   : 8;
+	uint64_t rodt_d2_r1                   : 8;
+	uint64_t rodt_d3_r0                   : 8;
+	uint64_t rodt_d3_r1                   : 8;
+#endif
+	} s;
+	struct cvmx_dfm_rodt_mask_s           cn63xx;
+	struct cvmx_dfm_rodt_mask_s           cn63xxp1;
+	struct cvmx_dfm_rodt_mask_s           cn66xx;
+};
+typedef union cvmx_dfm_rodt_mask cvmx_dfm_rodt_mask_t;
+
+/**
+ * cvmx_dfm_slot_ctl0
+ *
+ * DFM_SLOT_CTL0 = DFM Slot Control0
+ * This register is an assortment of various control fields needed by the memory controller
+ *
+ * Notes:
+ * HW will update this register if SW has not previously written to it and when any of DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn, DFM_CONTROL and
+ * DFM_MODEREG_PARAMS0 change.Ideally, this register should only be read after DFM has been initialized and DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn
+ * have valid data.
+ * R2W_INIT has 1 extra CK cycle built in for odt settling/channel turnaround time.
+ */
+union cvmx_dfm_slot_ctl0 {
+	uint64_t u64;
+	struct cvmx_dfm_slot_ctl0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t w2w_init                     : 6;  /**< Write-to-write spacing control
+                                                         for back to back accesses to the same rank and dimm */
+	uint64_t w2r_init                     : 6;  /**< Write-to-read spacing control
+                                                         for back to back accesses to the same rank and dimm */
+	uint64_t r2w_init                     : 6;  /**< Read-to-write spacing control
+                                                         for back to back accesses to the same rank and dimm */
+	uint64_t r2r_init                     : 6;  /**< Read-to-read spacing control
+                                                         for back to back accesses to the same rank and dimm */
+#else
+	uint64_t r2r_init                     : 6;
+	uint64_t r2w_init                     : 6;
+	uint64_t w2r_init                     : 6;
+	uint64_t w2w_init                     : 6;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dfm_slot_ctl0_s           cn63xx;
+	struct cvmx_dfm_slot_ctl0_s           cn63xxp1;
+	struct cvmx_dfm_slot_ctl0_s           cn66xx;
+};
+typedef union cvmx_dfm_slot_ctl0 cvmx_dfm_slot_ctl0_t;
+
+/**
+ * cvmx_dfm_slot_ctl1
+ *
+ * DFM_SLOT_CTL1 = DFM Slot Control1
+ * This register is an assortment of various control fields needed by the memory controller
+ *
+ * Notes:
+ * HW will update this register if SW has not previously written to it and when any of DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn, DFM_CONTROL and
+ * DFM_MODEREG_PARAMS0 change.Ideally, this register should only be read after DFM has been initialized and DFM_RLEVEL_RANKn, DFM_WLEVEL_RANKn
+ * have valid data.
+ * R2W_XRANK_INIT, W2R_XRANK_INIT have 1 extra CK cycle built in for odt settling/channel turnaround time.
+ */
+union cvmx_dfm_slot_ctl1 {
+	uint64_t u64;
+	struct cvmx_dfm_slot_ctl1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_24_63               : 40;
+	uint64_t w2w_xrank_init               : 6;  /**< Write-to-write spacing control
+                                                         for back to back accesses across ranks of the same dimm */
+	uint64_t w2r_xrank_init               : 6;  /**< Write-to-read spacing control
+                                                         for back to back accesses across ranks of the same dimm */
+	uint64_t r2w_xrank_init               : 6;  /**< Read-to-write spacing control
+                                                         for back to back accesses across ranks of the same dimm */
+	uint64_t r2r_xrank_init               : 6;  /**< Read-to-read spacing control
+                                                         for back to back accesses across ranks of the same dimm */
+#else
+	uint64_t r2r_xrank_init               : 6;
+	uint64_t r2w_xrank_init               : 6;
+	uint64_t w2r_xrank_init               : 6;
+	uint64_t w2w_xrank_init               : 6;
+	uint64_t reserved_24_63               : 40;
+#endif
+	} s;
+	struct cvmx_dfm_slot_ctl1_s           cn63xx;
+	struct cvmx_dfm_slot_ctl1_s           cn63xxp1;
+	struct cvmx_dfm_slot_ctl1_s           cn66xx;
+};
+typedef union cvmx_dfm_slot_ctl1 cvmx_dfm_slot_ctl1_t;
+
+/**
+ * cvmx_dfm_timing_params0
+ */
+union cvmx_dfm_timing_params0 {
+	uint64_t u64;
+	struct cvmx_dfm_timing_params0_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t trp_ext                      : 1;  /**< Indicates tRP constraints.
+                                                         Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]
+                                                         + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,
+                                                         where tRP, tRTP are from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP tRP=10-15ns
+                                                         TYP tRTP=max(4nCK, 7.5ns) */
+	uint64_t tcksre                       : 4;  /**< Indicates tCKSRE constraints.
+                                                         Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,
+                                                         where tCKSRE is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(5nCK, 10ns) */
+	uint64_t trp                          : 4;  /**< Indicates tRP constraints.
+                                                         Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]
+                                                         + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,
+                                                         where tRP, tRTP are from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP tRP=10-15ns
+                                                         TYP tRTP=max(4nCK, 7.5ns) */
+	uint64_t tzqinit                      : 4;  /**< Indicates tZQINIT constraints.
+                                                         Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],
+                                                         where tZQINIT is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=2 (equivalent to 512) */
+	uint64_t tdllk                        : 4;  /**< Indicates tDLLk constraints.
+                                                         Set TDLLK (CSR field) = RNDUP[tDLLk(ns)/(256*tCYC(ns))],
+                                                         where tDLLk is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=2 (equivalent to 512)
+                                                         This parameter is used in self-refresh exit
+                                                         and assumed to be greater than tRFC */
+	uint64_t tmod                         : 4;  /**< Indicates tMOD constraints.
+                                                         Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,
+                                                         where tMOD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(12nCK, 15ns) */
+	uint64_t tmrd                         : 4;  /**< Indicates tMRD constraints.
+                                                         Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,
+                                                         where tMRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=4nCK */
+	uint64_t txpr                         : 4;  /**< Indicates tXPR constraints.
+                                                         Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],
+                                                         where tXPR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(5nCK, tRFC+10ns) */
+	uint64_t tcke                         : 4;  /**< Indicates tCKE constraints.
+                                                         Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,
+                                                         where tCKE is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
+	uint64_t tzqcs                        : 4;  /**< Indicates tZQCS constraints.
+                                                         Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],
+                                                         where tZQCS is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=4 (equivalent to 64) */
+	uint64_t tckeon                       : 10; /**< Reserved. Should be written to zero. */
+#else
+	uint64_t tckeon                       : 10;
+	uint64_t tzqcs                        : 4;
+	uint64_t tcke                         : 4;
+	uint64_t txpr                         : 4;
+	uint64_t tmrd                         : 4;
+	uint64_t tmod                         : 4;
+	uint64_t tdllk                        : 4;
+	uint64_t tzqinit                      : 4;
+	uint64_t trp                          : 4;
+	uint64_t tcksre                       : 4;
+	uint64_t trp_ext                      : 1;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfm_timing_params0_cn63xx {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t trp_ext                      : 1;  /**< Indicates tRP constraints.
+                                                         Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]
+                                                         + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,
+                                                         where tRP, tRTP are from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP tRP=10-15ns
+                                                         TYP tRTP=max(4nCK, 7.5ns) */
+	uint64_t tcksre                       : 4;  /**< Indicates tCKSRE constraints.
+                                                         Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,
+                                                         where tCKSRE is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(5nCK, 10ns) */
+	uint64_t trp                          : 4;  /**< Indicates tRP constraints.
+                                                         Set [TRP_EXT[0:0], TRP[3:0]] (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]
+                                                         + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,
+                                                         where tRP, tRTP are from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP tRP=10-15ns
+                                                         TYP tRTP=max(4nCK, 7.5ns) */
+	uint64_t tzqinit                      : 4;  /**< Indicates tZQINIT constraints.
+                                                         Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],
+                                                         where tZQINIT is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=2 (equivalent to 512) */
+	uint64_t tdllk                        : 4;  /**< Indicates tDLLk constraints.
+                                                         Set TDLLK (CSR field) = RNDUP[tDLLk(ns)/(256*tCYC(ns))],
+                                                         where tDLLk is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=2 (equivalent to 512)
+                                                         This parameter is used in self-refresh exit
+                                                         and assumed to be greater than tRFC */
+	uint64_t tmod                         : 4;  /**< Indicates tMOD constraints.
+                                                         Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,
+                                                         where tMOD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(12nCK, 15ns) */
+	uint64_t tmrd                         : 4;  /**< Indicates tMRD constraints.
+                                                         Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,
+                                                         where tMRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=4nCK */
+	uint64_t txpr                         : 4;  /**< Indicates tXPR constraints.
+                                                         Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],
+                                                         where tXPR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(5nCK, tRFC+10ns) */
+	uint64_t tcke                         : 4;  /**< Indicates tCKE constraints.
+                                                         Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,
+                                                         where tCKE is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
+	uint64_t tzqcs                        : 4;  /**< Indicates tZQCS constraints.
+                                                         Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],
+                                                         where tZQCS is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=4 (equivalent to 64) */
+	uint64_t reserved_0_9                 : 10;
+#else
+	uint64_t reserved_0_9                 : 10;
+	uint64_t tzqcs                        : 4;
+	uint64_t tcke                         : 4;
+	uint64_t txpr                         : 4;
+	uint64_t tmrd                         : 4;
+	uint64_t tmod                         : 4;
+	uint64_t tdllk                        : 4;
+	uint64_t tzqinit                      : 4;
+	uint64_t trp                          : 4;
+	uint64_t tcksre                       : 4;
+	uint64_t trp_ext                      : 1;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} cn63xx;
+	struct cvmx_dfm_timing_params0_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_46_63               : 18;
+	uint64_t tcksre                       : 4;  /**< Indicates tCKSRE constraints.
+                                                         Set TCKSRE (CSR field) = RNDUP[tCKSRE(ns)/tCYC(ns)]-1,
+                                                         where tCKSRE is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(5nCK, 10ns) */
+	uint64_t trp                          : 4;  /**< Indicates tRP constraints.
+                                                         Set TRP (CSR field) = RNDUP[tRP(ns)/tCYC(ns)]
+                                                         + (RNDUP[tRTP(ns)/tCYC(ns)])-4)-1,
+                                                         where tRP, tRTP are from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP tRP=10-15ns
+                                                         TYP tRTP=max(4nCK, 7.5ns) */
+	uint64_t tzqinit                      : 4;  /**< Indicates tZQINIT constraints.
+                                                         Set TZQINIT (CSR field) = RNDUP[tZQINIT(ns)/(256*tCYC(ns))],
+                                                         where tZQINIT is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=2 (equivalent to 512) */
+	uint64_t tdllk                        : 4;  /**< Indicates tDLLk constraints.
+                                                         Set TDLLK (CSR field) = RNDUP[tDLLk(ns)/(256*tCYC(ns))],
+                                                         where tDLLk is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=2 (equivalent to 512)
+                                                         This parameter is used in self-refresh exit
+                                                         and assumed to be greater than tRFC */
+	uint64_t tmod                         : 4;  /**< Indicates tMOD constraints.
+                                                         Set TMOD (CSR field) = RNDUP[tMOD(ns)/tCYC(ns)]-1,
+                                                         where tMOD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(12nCK, 15ns) */
+	uint64_t tmrd                         : 4;  /**< Indicates tMRD constraints.
+                                                         Set TMRD (CSR field) = RNDUP[tMRD(ns)/tCYC(ns)]-1,
+                                                         where tMRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=4nCK */
+	uint64_t txpr                         : 4;  /**< Indicates tXPR constraints.
+                                                         Set TXPR (CSR field) = RNDUP[tXPR(ns)/(16*tCYC(ns))],
+                                                         where tXPR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(5nCK, tRFC+10ns) */
+	uint64_t tcke                         : 4;  /**< Indicates tCKE constraints.
+                                                         Set TCKE (CSR field) = RNDUP[tCKE(ns)/tCYC(ns)]-1,
+                                                         where tCKE is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5/5.625/5.625/5ns) */
+	uint64_t tzqcs                        : 4;  /**< Indicates tZQCS constraints.
+                                                         Set TZQCS (CSR field) = RNDUP[tZQCS(ns)/(16*tCYC(ns))],
+                                                         where tZQCS is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=4 (equivalent to 64) */
+	uint64_t tckeon                       : 10; /**< Reserved. Should be written to zero. */
+#else
+	uint64_t tckeon                       : 10;
+	uint64_t tzqcs                        : 4;
+	uint64_t tcke                         : 4;
+	uint64_t txpr                         : 4;
+	uint64_t tmrd                         : 4;
+	uint64_t tmod                         : 4;
+	uint64_t tdllk                        : 4;
+	uint64_t tzqinit                      : 4;
+	uint64_t trp                          : 4;
+	uint64_t tcksre                       : 4;
+	uint64_t reserved_46_63               : 18;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_timing_params0_cn63xx cn66xx;
+};
+typedef union cvmx_dfm_timing_params0 cvmx_dfm_timing_params0_t;
+
+/**
+ * cvmx_dfm_timing_params1
+ */
+union cvmx_dfm_timing_params1 {
+	uint64_t u64;
+	struct cvmx_dfm_timing_params1_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t tras_ext                     : 1;  /**< Indicates tRAS constraints.
+                                                         Set [TRAS_EXT[0:0], TRAS[4:0]] (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,
+                                                         where tRAS is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=35ns-9*tREFI
+                                                             - 000000: RESERVED
+                                                             - 000001: 2 tCYC
+                                                             - 000010: 3 tCYC
+                                                             - ...
+                                                             - 111111: 64 tCYC */
+	uint64_t txpdll                       : 5;  /**< Indicates tXPDLL constraints.
+                                                         Set TXPDLL (CSR field) = RNDUP[tXPDLL(ns)/tCYC(ns)]-1,
+                                                         where tXPDLL is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(10nCK, 24ns) */
+	uint64_t tfaw                         : 5;  /**< Indicates tFAW constraints.
+                                                         Set TFAW (CSR field) = RNDUP[tFAW(ns)/(4*tCYC(ns))],
+                                                         where tFAW is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=30-40ns */
+	uint64_t twldqsen                     : 4;  /**< Indicates tWLDQSEN constraints.
+                                                         Set TWLDQSEN (CSR field) = RNDUP[tWLDQSEN(ns)/(4*tCYC(ns))],
+                                                         where tWLDQSEN is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(25nCK) */
+	uint64_t twlmrd                       : 4;  /**< Indicates tWLMRD constraints.
+                                                         Set TWLMRD (CSR field) = RNDUP[tWLMRD(ns)/(4*tCYC(ns))],
+                                                         where tWLMRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(40nCK) */
+	uint64_t txp                          : 3;  /**< Indicates tXP constraints.
+                                                         Set TXP (CSR field) = RNDUP[tXP(ns)/tCYC(ns)]-1,
+                                                         where tXP is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5ns) */
+	uint64_t trrd                         : 3;  /**< Indicates tRRD constraints.
+                                                         Set TRRD (CSR field) = RNDUP[tRRD(ns)/tCYC(ns)]-2,
+                                                         where tRRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(4nCK, 10ns)
+                                                            - 000: RESERVED
+                                                            - 001: 3 tCYC
+                                                            - ...
+                                                            - 110: 8 tCYC
+                                                            - 111: 9 tCYC */
+	uint64_t trfc                         : 5;  /**< Indicates tRFC constraints.
+                                                         Set TRFC (CSR field) = RNDUP[tRFC(ns)/(8*tCYC(ns))],
+                                                         where tRFC is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=90-350ns
+                                                              - 00000: RESERVED
+                                                              - 00001: 8 tCYC
+                                                              - 00010: 16 tCYC
+                                                              - 00011: 24 tCYC
+                                                              - 00100: 32 tCYC
+                                                              - ...
+                                                              - 11110: 240 tCYC
+                                                              - 11111: 248 tCYC */
+	uint64_t twtr                         : 4;  /**< Indicates tWTR constraints.
+                                                         Set TWTR (CSR field) = RNDUP[tWTR(ns)/tCYC(ns)]-1,
+                                                         where tWTR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(4nCK, 7.5ns)
+                                                             - 0000: RESERVED
+                                                             - 0001: 2
+                                                             - ...
+                                                             - 0111: 8
+                                                             - 1000-1111: RESERVED */
+	uint64_t trcd                         : 4;  /**< Indicates tRCD constraints.
+                                                         Set TRCD (CSR field) = RNDUP[tRCD(ns)/tCYC(ns)],
+                                                         where tRCD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=10-15ns
+                                                             - 0000: RESERVED
+                                                             - 0001: 2 (2 is the smallest value allowed)
+                                                             - 0002: 2
+                                                             - ...
+                                                             - 1001: 9
+                                                             - 1010-1111: RESERVED
+                                                         In 2T mode, make this register TRCD-1, not going
+                                                         below 2. */
+	uint64_t tras                         : 5;  /**< Indicates tRAS constraints.
+                                                         Set [TRAS_EXT[0:0], TRAS[4:0]] (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,
+                                                         where tRAS is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=35ns-9*tREFI
+                                                             - 000000: RESERVED
+                                                             - 000001: 2 tCYC
+                                                             - 000010: 3 tCYC
+                                                             - ...
+                                                             - 111111: 64 tCYC */
+	uint64_t tmprr                        : 4;  /**< Indicates tMPRR constraints.
+                                                         Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,
+                                                         where tMPRR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=1nCK */
+#else
+	uint64_t tmprr                        : 4;
+	uint64_t tras                         : 5;
+	uint64_t trcd                         : 4;
+	uint64_t twtr                         : 4;
+	uint64_t trfc                         : 5;
+	uint64_t trrd                         : 3;
+	uint64_t txp                          : 3;
+	uint64_t twlmrd                       : 4;
+	uint64_t twldqsen                     : 4;
+	uint64_t tfaw                         : 5;
+	uint64_t txpdll                       : 5;
+	uint64_t tras_ext                     : 1;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfm_timing_params1_s      cn63xx;
+	struct cvmx_dfm_timing_params1_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_46_63               : 18;
+	uint64_t txpdll                       : 5;  /**< Indicates tXPDLL constraints.
+                                                         Set TXPDLL (CSR field) = RNDUP[tXPDLL(ns)/tCYC(ns)]-1,
+                                                         where tXPDLL is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(10nCK, 24ns) */
+	uint64_t tfaw                         : 5;  /**< Indicates tFAW constraints.
+                                                         Set TFAW (CSR field) = RNDUP[tFAW(ns)/(4*tCYC(ns))],
+                                                         where tFAW is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=30-40ns */
+	uint64_t twldqsen                     : 4;  /**< Indicates tWLDQSEN constraints.
+                                                         Set TWLDQSEN (CSR field) = RNDUP[tWLDQSEN(ns)/(4*tCYC(ns))],
+                                                         where tWLDQSEN is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(25nCK) */
+	uint64_t twlmrd                       : 4;  /**< Indicates tWLMRD constraints.
+                                                         Set TWLMRD (CSR field) = RNDUP[tWLMRD(ns)/(4*tCYC(ns))],
+                                                         where tWLMRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(40nCK) */
+	uint64_t txp                          : 3;  /**< Indicates tXP constraints.
+                                                         Set TXP (CSR field) = RNDUP[tXP(ns)/tCYC(ns)]-1,
+                                                         where tXP is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(3nCK, 7.5ns) */
+	uint64_t trrd                         : 3;  /**< Indicates tRRD constraints.
+                                                         Set TRRD (CSR field) = RNDUP[tRRD(ns)/tCYC(ns)]-2,
+                                                         where tRRD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(4nCK, 10ns)
+                                                            - 000: RESERVED
+                                                            - 001: 3 tCYC
+                                                            - ...
+                                                            - 110: 8 tCYC
+                                                            - 111: 9 tCYC */
+	uint64_t trfc                         : 5;  /**< Indicates tRFC constraints.
+                                                         Set TRFC (CSR field) = RNDUP[tRFC(ns)/(8*tCYC(ns))],
+                                                         where tRFC is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=90-350ns
+                                                              - 00000: RESERVED
+                                                              - 00001: 8 tCYC
+                                                              - 00010: 16 tCYC
+                                                              - 00011: 24 tCYC
+                                                              - 00100: 32 tCYC
+                                                              - ...
+                                                              - 11110: 240 tCYC
+                                                              - 11111: 248 tCYC */
+	uint64_t twtr                         : 4;  /**< Indicates tWTR constraints.
+                                                         Set TWTR (CSR field) = RNDUP[tWTR(ns)/tCYC(ns)]-1,
+                                                         where tWTR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=max(4nCK, 7.5ns)
+                                                             - 0000: RESERVED
+                                                             - 0001: 2
+                                                             - ...
+                                                             - 0111: 8
+                                                             - 1000-1111: RESERVED */
+	uint64_t trcd                         : 4;  /**< Indicates tRCD constraints.
+                                                         Set TRCD (CSR field) = RNDUP[tRCD(ns)/tCYC(ns)],
+                                                         where tRCD is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=10-15ns
+                                                             - 0000: RESERVED
+                                                             - 0001: 2 (2 is the smallest value allowed)
+                                                             - 0002: 2
+                                                             - ...
+                                                             - 1001: 9
+                                                             - 1010-1111: RESERVED
+                                                         In 2T mode, make this register TRCD-1, not going
+                                                         below 2. */
+	uint64_t tras                         : 5;  /**< Indicates tRAS constraints.
+                                                         Set TRAS (CSR field) = RNDUP[tRAS(ns)/tCYC(ns)]-1,
+                                                         where tRAS is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=35ns-9*tREFI
+                                                             - 00000: RESERVED
+                                                             - 00001: 2 tCYC
+                                                             - 00010: 3 tCYC
+                                                             - ...
+                                                             - 11111: 32 tCYC */
+	uint64_t tmprr                        : 4;  /**< Indicates tMPRR constraints.
+                                                         Set TMPRR (CSR field) = RNDUP[tMPRR(ns)/tCYC(ns)]-1,
+                                                         where tMPRR is from the DDR3 spec, and tCYC(ns)
+                                                         is the DDR clock frequency (not data rate).
+                                                         TYP=1nCK */
+#else
+	uint64_t tmprr                        : 4;
+	uint64_t tras                         : 5;
+	uint64_t trcd                         : 4;
+	uint64_t twtr                         : 4;
+	uint64_t trfc                         : 5;
+	uint64_t trrd                         : 3;
+	uint64_t txp                          : 3;
+	uint64_t twlmrd                       : 4;
+	uint64_t twldqsen                     : 4;
+	uint64_t tfaw                         : 5;
+	uint64_t txpdll                       : 5;
+	uint64_t reserved_46_63               : 18;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_timing_params1_s      cn66xx;
+};
+typedef union cvmx_dfm_timing_params1 cvmx_dfm_timing_params1_t;
+
+/**
+ * cvmx_dfm_wlevel_ctl
+ */
+union cvmx_dfm_wlevel_ctl {
+	uint64_t u64;
+	struct cvmx_dfm_wlevel_ctl_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_22_63               : 42;
+	uint64_t rtt_nom                      : 3;  /**< RTT_NOM
+                                                         DFM writes a decoded value to MR1[Rtt_Nom] of the rank during
+                                                         write leveling. Per JEDEC DDR3 specifications,
+                                                         only values MR1[Rtt_Nom] = 1 (RQZ/4), 2 (RQZ/2), or 3 (RQZ/6)
+                                                         are allowed during write leveling with output buffer enabled.
+                                                         000 : DFM writes 001 (RZQ/4)   to MR1[Rtt_Nom]
+                                                         001 : DFM writes 010 (RZQ/2)   to MR1[Rtt_Nom]
+                                                         010 : DFM writes 011 (RZQ/6)   to MR1[Rtt_Nom]
+                                                         011 : DFM writes 100 (RZQ/12)  to MR1[Rtt_Nom]
+                                                         100 : DFM writes 101 (RZQ/8)   to MR1[Rtt_Nom]
+                                                         101 : DFM writes 110 (Rsvd)    to MR1[Rtt_Nom]
+                                                         110 : DFM writes 111 (Rsvd)    to  MR1[Rtt_Nom]
+                                                         111 : DFM writes 000 (Disabled) to MR1[Rtt_Nom] */
+	uint64_t bitmask                      : 8;  /**< Mask to select bit lanes on which write-leveling
+                                                         feedback is returned when OR_DIS is set to 1 */
+	uint64_t or_dis                       : 1;  /**< Disable or'ing of bits in a byte lane when computing
+                                                         the write-leveling bitmask */
+	uint64_t sset                         : 1;  /**< Run write-leveling on the current setting only. */
+	uint64_t lanemask                     : 9;  /**< One-hot mask to select byte lane to be leveled by
+                                                         the write-leveling sequence
+                                                         Used with x16 parts where the upper and lower byte
+                                                         lanes need to be leveled independently
+                                                         LANEMASK<8:2> must be zero. */
+#else
+	uint64_t lanemask                     : 9;
+	uint64_t sset                         : 1;
+	uint64_t or_dis                       : 1;
+	uint64_t bitmask                      : 8;
+	uint64_t rtt_nom                      : 3;
+	uint64_t reserved_22_63               : 42;
+#endif
+	} s;
+	struct cvmx_dfm_wlevel_ctl_s          cn63xx;
+	struct cvmx_dfm_wlevel_ctl_cn63xxp1 {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_10_63               : 54;
+	uint64_t sset                         : 1;  /**< Run write-leveling on the current setting only. */
+	uint64_t lanemask                     : 9;  /**< One-hot mask to select byte lane to be leveled by
+                                                         the write-leveling sequence
+                                                         Used with x16 parts where the upper and lower byte
+                                                         lanes need to be leveled independently
+                                                         LANEMASK<8:2> must be zero. */
+#else
+	uint64_t lanemask                     : 9;
+	uint64_t sset                         : 1;
+	uint64_t reserved_10_63               : 54;
+#endif
+	} cn63xxp1;
+	struct cvmx_dfm_wlevel_ctl_s          cn66xx;
+};
+typedef union cvmx_dfm_wlevel_ctl cvmx_dfm_wlevel_ctl_t;
+
+/**
+ * cvmx_dfm_wlevel_dbg
+ *
+ * Notes:
+ * A given write of DFM_WLEVEL_DBG returns the write-leveling pass/fail results for all possible
+ * delay settings (i.e. the BITMASK) for only one byte in the last rank that the HW write-leveled.
+ * DFM_WLEVEL_DBG[BYTE] selects the particular byte.
+ * To get these pass/fail results for another different rank, you must run the hardware write-leveling
+ * again. For example, it is possible to get the BITMASK results for every byte of every rank
+ * if you run write-leveling separately for each rank, probing DFM_WLEVEL_DBG between each
+ * write-leveling.
+ */
+union cvmx_dfm_wlevel_dbg {
+	uint64_t u64;
+	struct cvmx_dfm_wlevel_dbg_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_12_63               : 52;
+	uint64_t bitmask                      : 8;  /**< Bitmask generated during deskew settings sweep
+                                                         if DFM_WLEVEL_CTL[SSET]=0
+                                                           BITMASK[n]=0 means deskew setting n failed
+                                                           BITMASK[n]=1 means deskew setting n passed
+                                                           for 0 <= n <= 7
+                                                           BITMASK contains the first 8 results of the total 16
+                                                           collected by DFM during the write-leveling sequence
+                                                         else if DFM_WLEVEL_CTL[SSET]=1
+                                                           BITMASK[0]=0 means curr deskew setting failed
+                                                           BITMASK[0]=1 means curr deskew setting passed */
+	uint64_t byte                         : 4;  /**< 0 <= BYTE <= 8 */
+#else
+	uint64_t byte                         : 4;
+	uint64_t bitmask                      : 8;
+	uint64_t reserved_12_63               : 52;
+#endif
+	} s;
+	struct cvmx_dfm_wlevel_dbg_s          cn63xx;
+	struct cvmx_dfm_wlevel_dbg_s          cn63xxp1;
+	struct cvmx_dfm_wlevel_dbg_s          cn66xx;
+};
+typedef union cvmx_dfm_wlevel_dbg cvmx_dfm_wlevel_dbg_t;
+
+/**
+ * cvmx_dfm_wlevel_rank#
+ *
+ * Notes:
+ * This is TWO CSRs per DFM, one per each rank. (front bunk/back bunk)
+ *
+ * Deskew setting is measured in units of 1/8 FCLK, so the above BYTE* values can range over 4 FCLKs.
+ *
+ * Assuming DFM_WLEVEL_CTL[SSET]=0, the BYTE*<2:0> values are not used during write-leveling, and
+ * they are over-written by the hardware as part of the write-leveling sequence. (HW sets STATUS==3
+ * after HW write-leveling completes for the rank). SW needs to set BYTE*<4:3> bits.
+ *
+ * Each CSR may also be written by SW, but not while a write-leveling sequence is in progress. (HW sets STATUS==1 after a CSR write.)
+ *
+ * SW initiates a HW write-leveling sequence by programming DFM_WLEVEL_CTL and writing RANKMASK and INIT_START=1 with SEQUENCE=6 in DFM_CONFIG.
+ * DFM will then step through and accumulate write leveling results for 8 unique delay settings (twice), starting at a delay of
+ * DFM_WLEVEL_RANKn[BYTE*<4:3>]*8 CK increasing by 1/8 CK each setting. HW will then set DFM_WLEVEL_RANKn[BYTE*<2:0>] to indicate the
+ * first write leveling result of '1' that followed a reslt of '0' during the sequence by searching for a '1100' pattern in the generated
+ * bitmask, except that DFM will always write DFM_WLEVEL_RANKn[BYTE*<0>]=0. If HW is unable to find a match for a '1100' pattern, then HW will
+ * set DFM_WLEVEL_RANKn[BYTE*<2:0>] to 4.
+ * See DFM_WLEVEL_CTL.
+ */
+union cvmx_dfm_wlevel_rankx {
+	uint64_t u64;
+	struct cvmx_dfm_wlevel_rankx_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t reserved_47_63               : 17;
+	uint64_t status                       : 2;  /**< Indicates status of the write-leveling and where
+                                                         the BYTE* programmings in <44:0> came from:
+                                                         0 = BYTE* values are their reset value
+                                                         1 = BYTE* values were set via a CSR write to this register
+                                                         2 = write-leveling sequence currently in progress (BYTE* values are unpredictable)
+                                                         3 = BYTE* values came from a complete write-leveling sequence, irrespective of
+                                                             which lanes are masked via DFM_WLEVEL_CTL[LANEMASK] */
+	uint64_t reserved_10_44               : 35;
+	uint64_t byte1                        : 5;  /**< Deskew setting
+                                                         Bit 0 of BYTE1 must be zero during normal operation */
+	uint64_t byte0                        : 5;  /**< Deskew setting
+                                                         Bit 0 of BYTE0 must be zero during normal operation */
+#else
+	uint64_t byte0                        : 5;
+	uint64_t byte1                        : 5;
+	uint64_t reserved_10_44               : 35;
+	uint64_t status                       : 2;
+	uint64_t reserved_47_63               : 17;
+#endif
+	} s;
+	struct cvmx_dfm_wlevel_rankx_s        cn63xx;
+	struct cvmx_dfm_wlevel_rankx_s        cn63xxp1;
+	struct cvmx_dfm_wlevel_rankx_s        cn66xx;
+};
+typedef union cvmx_dfm_wlevel_rankx cvmx_dfm_wlevel_rankx_t;
+
+/**
+ * cvmx_dfm_wodt_mask
+ *
+ * DFM_WODT_MASK = DFM Write OnDieTermination mask
+ * System designers may desire to terminate DQ/DQS/DM lines for higher frequency DDR operations
+ * especially on a multi-rank system. DDR3 DQ/DM/DQS I/O's have built in
+ * Termination resistor that can be turned on or off by the controller, after meeting tAOND and tAOF
+ * timing requirements. Each Rank has its own ODT pin that fans out to all the memory parts
+ * in that rank. System designers may prefer different combinations of ODT ON's for writes
+ * into different ranks. Octeon supports full programmability by way of the mask register below.
+ * Each Rank position has its own 8-bit programmable field.
+ * When the controller does a write to that rank, it sets the 4 ODT pins to the MASK pins below.
+ * For eg., When doing a write into Rank0, a system designer may desire to terminate the lines
+ * with the resistor on Dimm0/Rank1. The mask WODT_D0_R0 would then be [00000010].
+ * Octeon drives the appropriate mask values on the ODT pins by default. If this feature is not
+ * required, write 0 in this register.
+ *
+ * Notes:
+ * - DFM_WODT_MASK functions a little differently than DFM_RODT_MASK.  While, in DFM_RODT_MASK, the other
+ * rank(s) are ODT-ed, in DFM_WODT_MASK, the rank in which the write CAS is issued can be ODT-ed as well.
+ * - For a two rank system and a write op to rank0: use RODT_D0_R0<1:0> to terminate lines on rank1 and/or rank0.
+ * - For a two rank system and a write op to rank1: use RODT_D0_R1<1:0> to terminate lines on rank1 and/or rank0.
+ * - When a given RANK is selected, the WODT mask for that RANK is used.
+ *
+ * DFM always writes 128-bit words independently via one write CAS operation per word.
+ * When a WODT mask bit is set, DFM asserts the OCTEON ODT output pin(s) starting the same cycle
+ * as the write CAS operation. Then, OCTEON normally continues to assert the ODT output pin(s) for five
+ * more cycles - for a total of 6 cycles for the entire word write - satisfying the 6 cycle DDR3
+ * ODTH8 requirements. But it is possible for DFM to issue two word writes  separated by as few
+ * as WtW = 4 or 5 cycles. In that case, DFM asserts the ODT output pin(s) for the WODT mask of the
+ * first word write for WtW cycles, then asserts the ODT output pin(s) for the WODT mask of the
+ * second write for 6 cycles (or less if a third word write follows within 4 or 5
+ * cycles of this second word write). Note that it may be necessary to force DFM to space back-to-back
+ * word writes to different ranks apart by at least 6 cycles to prevent DDR3 ODTH8 violations.
+ */
+union cvmx_dfm_wodt_mask {
+	uint64_t u64;
+	struct cvmx_dfm_wodt_mask_s {
+#ifdef __BIG_ENDIAN_BITFIELD
+	uint64_t wodt_d3_r1                   : 8;  /**< Not used by DFM. */
+	uint64_t wodt_d3_r0                   : 8;  /**< Not used by DFM. */
+	uint64_t wodt_d2_r1                   : 8;  /**< Not used by DFM. */
+	uint64_t wodt_d2_r0                   : 8;  /**< Not used by DFM. */
+	uint64_t wodt_d1_r1                   : 8;  /**< Not used by DFM. */
+	uint64_t wodt_d1_r0                   : 8;  /**< Not used by DFM. */
+	uint64_t wodt_d0_r1                   : 8;  /**< Write ODT mask RANK1
+                                                         WODT_D0_R1<7:2> not used by DFM.
+                                                         WODT_D0_R1<1:0> is also not used by DFM when RANK_ENA is not set. */
+	uint64_t wodt_d0_r0                   : 8;  /**< Write ODT mask RANK0
+                                                         WODT_D0_R0<7:2> not used by DFM. */
+#else
+	uint64_t wodt_d0_r0                   : 8;
+	uint64_t wodt_d0_r1                   : 8;
+	uint64_t wodt_d1_r0                   : 8;
+	uint64_t wodt_d1_r1                   : 8;
+	uint64_t wodt_d2_r0                   : 8;
+	uint64_t wodt_d2_r1                   : 8;
+	uint64_t wodt_d3_r0                   : 8;
+	uint64_t wodt_d3_r1                   : 8;
+#endif
+	} s;
+	struct cvmx_dfm_wodt_mask_s           cn63xx;
+	struct cvmx_dfm_wodt_mask_s           cn63xxp1;
+	struct cvmx_dfm_wodt_mask_s           cn66xx;
+};
+typedef union cvmx_dfm_wodt_mask cvmx_dfm_wodt_mask_t;
+
+#endif
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx.h OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx.h
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx.h	2014-04-04 15:14:12.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx.h	2014-04-04 15:23:01.000000000 +0530
@@ -113,7 +113,7 @@ static inline unsigned int cvmx_get_node
 #ifndef CVMX_ENABLE_DEBUG_PRINTS
 #define CVMX_ENABLE_DEBUG_PRINTS 1
 #endif
-
+#define CVMX_ENABLE_DFA_FUNCTIONS 1
 #if CVMX_ENABLE_DEBUG_PRINTS
 #define cvmx_dprintf        printk
 #define cvmx_dvprintf       vprintk
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-hfa.h OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-hfa.h
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-hfa.h	1970-01-01 05:30:00.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-hfa.h	2014-04-04 15:23:01.000000000 +0530
@@ -0,0 +1,529 @@
+/***********************license start***************
+ * Copyright (c) 2011  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * Interface to the CN6XXX and CN70/71XX hardware HFA engine.
+ *
+ * <hr>$Revision: 49448 $<hr>
+ */
+
+#ifndef __CVMX_HFA_H__
+#define __CVMX_HFA_H__
+
+#ifdef CVMX_BUILD_FOR_LINUX_KERNEL
+#include <asm/octeon/cvmx-wqe.h>
+#include <asm/octeon/cvmx-fpa.h>
+#include <asm/octeon/cvmx-bootmem.h>
+#include <asm/octeon/cvmx.h>
+#include <asm/octeon/cvmx-config.h>
+
+#ifdef CVMX_ENABLE_DFA_FUNCTIONS
+/* DFA queue cmd buffers */
+
+#define CVMX_FPA_DFA_POOL                   (4)             /**< DFA command buffers */
+#define CVMX_FPA_DFA_POOL_SIZE              (2 * CVMX_CACHE_LINE_SIZE)
+#endif
+
+#else 
+#include "cvmx-wqe.h"
+#include "cvmx-fpa.h"
+#include "cvmx-bootmem.h"
+#endif
+#define HFA_MIPS_CAVIUM_L2C_FLUSH 2002
+
+#define ENABLE_DEPRECATED	/* Set to enable the old 18/36 bit names */
+#define CHECK_SIZE     128
+
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+extern "C" {
+/* *INDENT-ON* */
+#endif
+
+typedef union {
+	uint64_t u64;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t varies0:34;
+        uint64_t store_full:1;
+        uint64_t varies1:2;
+        uint64_t itype:3;
+        uint64_t varies2:24;
+#else
+        uint64_t varies2:24;
+        uint64_t itype:3;
+        uint64_t varies1:2;
+        uint64_t store_full:1;
+        uint64_t varies0:34;
+#endif
+    };
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t f1:3;
+        uint64_t unused1:2;
+        uint64_t snode:27;
+        uint64_t gather_mode:1;
+        uint64_t little_endian:1;
+        uint64_t store_full:1;
+        uint64_t load_through:1;
+        uint64_t small:1;
+        uint64_t itype:3;
+        uint64_t unused0:2;
+        uint64_t mbase:22;
+#else
+        uint64_t mbase:22;
+        uint64_t unused0:2;
+        uint64_t itype:3;
+        uint64_t small:1;
+        uint64_t load_through:1;
+        uint64_t store_full:1;
+        uint64_t little_endian:1;
+        uint64_t gather_mode:1;
+        uint64_t snode:27;
+        uint64_t unused1:2;
+        uint64_t f1:3;
+#endif
+    } walk;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t unused4:7;
+        uint64_t dbase:9;
+        uint64_t unused3:2;
+        uint64_t cbase:14;
+        uint64_t gather_mode:1;
+        uint64_t little_endian:1;
+        uint64_t store_full:1;
+        uint64_t load_through:1;
+        uint64_t unused2:1;
+        uint64_t itype:3;
+        uint64_t unused1:6;
+        uint64_t dsize:10;
+        uint64_t unused0:2;
+        uint64_t pgid:6;
+#else
+        uint64_t pgid:6;
+        uint64_t unused0:2;
+        uint64_t dsize:10;
+        uint64_t unused1:6;
+        uint64_t itype:3;
+        uint64_t unused2:1;
+        uint64_t load_through:1;
+        uint64_t store_full:1;
+        uint64_t little_endian:1;
+        uint64_t gather_mode:1;
+        uint64_t cbase:14;
+        uint64_t unused3:2;
+        uint64_t dbase:9;
+        uint64_t unused4:7;
+#endif
+    } cload;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t unused2:32;
+        uint64_t gather_mode:1;
+        uint64_t little_endian:1;
+        uint64_t store_full:1;
+        uint64_t load_through:1;
+        uint64_t unused1:1;
+        uint64_t itype:3;
+        uint64_t unused0:2;
+        uint64_t mbase:22;
+#else
+        uint64_t mbase:22;
+        uint64_t unused0:2;
+        uint64_t itype:3;
+        uint64_t unused1:1;
+        uint64_t load_through:1;
+        uint64_t store_full:1;
+        uint64_t little_endian:1;
+        uint64_t gather_mode:1;
+        uint64_t unused2:32;
+#endif
+    } mload;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t unused2:34;
+        uint64_t store_full:1;
+        uint64_t unused1:2;
+        uint64_t itype:3;
+        uint64_t unused0:24;
+#else
+        uint64_t unused0:24;
+        uint64_t itype:3;
+        uint64_t unused1:2;
+        uint64_t store_full:1;
+        uint64_t unused2:34;
+#endif
+    } free;
+} cvmx_hfa_word0_t;
+
+typedef union {
+    uint64_t u64;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t varies0:24;
+        uint64_t rptr:40;
+#else
+        uint64_t rptr:40;
+        uint64_t varies0:24;
+#endif
+    };
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t rmax:16;
+		uint64_t f2:8;
+		uint64_t rptr:40;
+#else
+		uint64_t rptr:40;
+		uint64_t f2:8;
+		uint64_t rmax:16;
+#endif
+	} walk;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:13;
+		uint64_t rmax:3;
+		uint64_t unused0:8;
+		uint64_t rptr:40;
+#else
+		uint64_t rptr:40;
+		uint64_t unused0:8;
+		uint64_t rmax:3;
+		uint64_t unused1:13;
+#endif
+	} cload;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:4;
+		uint64_t rmax:12;
+		uint64_t unused0:8;
+		uint64_t rptr:40;
+#else
+		uint64_t rptr:40;
+		uint64_t unused0:8;
+		uint64_t rmax:12;
+		uint64_t unused1:4;
+#endif
+	} mload;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused:24;
+		uint64_t rptr:40;
+#else
+		uint64_t rptr:40;
+		uint64_t unused:24;
+#endif
+	} free;
+} cvmx_hfa_word1_t;
+
+typedef union {
+    uint64_t u64;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t varies0:20;
+        uint64_t clmsk:4;
+        uint64_t varies1:40;
+#else
+        uint64_t varies1:40;
+        uint64_t clmsk:4;
+        uint64_t varies0:20;
+#endif
+    };
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t dlen:16;
+	    uint64_t f5:2;
+		uint64_t unused:2;
+		uint64_t clmsk:4;
+		uint64_t dptr:40;
+#else
+		uint64_t dptr:40;
+		uint64_t clmsk:4;
+		uint64_t unused:2;
+	    uint64_t f5:2;
+		uint64_t dlen:16;
+#endif
+	} walk;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t dlen:16;
+		uint64_t unused:4;
+		uint64_t clmsk:4;
+		uint64_t dptr:40;
+#else
+		uint64_t dptr:40;
+		uint64_t clmsk:4;
+		uint64_t unused:4;
+		uint64_t dlen:16;
+#endif
+	} cload;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t dlen:16;
+        uint64_t f5:2;
+		uint64_t unused:2;
+		uint64_t clmsk:4;
+		uint64_t dptr:40;
+#else
+		uint64_t dptr:40;
+		uint64_t clmsk:4;
+		uint64_t unused:2;
+        uint64_t f5:2;
+		uint64_t dlen:16;
+#endif
+	} mload;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:20;
+		uint64_t clmsk:4;
+		uint64_t unused0:40;
+#else
+		uint64_t unused0:40;
+		uint64_t clmsk:4;
+		uint64_t unused1:20;
+#endif
+	} free;
+} cvmx_hfa_word2_t;
+
+typedef union {
+    uint64_t u64;
+    struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+        uint64_t varies0:24;
+        uint64_t wqptr:40;
+#else
+        uint64_t wqptr:40;
+        uint64_t varies0:24;
+#endif
+    };
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:2;
+		uint64_t vgid:8;
+		uint64_t unused0:5;
+		uint64_t f3:9;
+		uint64_t wqptr:40;
+#else
+		uint64_t wqptr:40;
+		uint64_t f3:9;
+		uint64_t unused0:5;
+		uint64_t vgid:8;
+		uint64_t unused1:2;
+#endif
+	} walk;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:2;
+		uint64_t vgid:8;
+		uint64_t unused0:7;
+		uint64_t f4:7;
+		uint64_t wqptr:40;
+#else
+		uint64_t wqptr:40;
+		uint64_t f4:7;
+		uint64_t unused0:7;
+		uint64_t vgid:8;
+		uint64_t unused1:2;
+#endif
+	} cload;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:2;
+		uint64_t vgid:8;
+		uint64_t unused0:7;
+		uint64_t f4:7;
+		uint64_t wqptr:40;
+#else
+		uint64_t wqptr:40;
+		uint64_t f4:7;
+		uint64_t unused0:7;
+		uint64_t vgid:8;
+		uint64_t unused1:2;
+#endif
+	} mload;
+	struct {
+#ifdef __BIG_ENDIAN_BITFIELD
+		uint64_t unused1:2;
+		uint64_t vgid:8;
+		uint64_t unused0:14;
+		uint64_t wqptr:40;
+#else
+		uint64_t wqptr:40;
+		uint64_t unused0:14;
+		uint64_t vgid:8;
+		uint64_t unused1:2;
+#endif
+	} free;
+} cvmx_hfa_word3_t;
+
+typedef union {
+	uint64_t u64[4];
+	struct {
+		cvmx_hfa_word0_t word0;
+		cvmx_hfa_word1_t word1;
+		cvmx_hfa_word2_t word2;
+		cvmx_hfa_word3_t word3;
+	};
+} cvmx_hfa_command_t;
+
+typedef struct
+{
+	cvmx_fpa_pool_config_t dfa_pool;
+}cvmx_dfa_app_config_t;
+
+extern CVMX_SHARED cvmx_dfa_app_config_t dfa_config;
+
+static inline int64_t cvmx_fpa_get_dfa_pool(void)
+{
+	return (dfa_config.dfa_pool.pool_num);	
+} 
+
+static inline uint64_t cvmx_fpa_get_dfa_pool_block_size(void)
+{
+	return (dfa_config.dfa_pool.buffer_size);	
+}
+
+
+/**
+ * Initialize the DFA/HFA hardware before use
+ * Returns 0 on success, -1 on failure
+ */
+int cvmx_hfa_initialize(void);
+
+/**
+ * Shutdown and cleanup resources used by the DFA/HFA
+ */
+int cvmx_hfa_shutdown(void);
+
+/**
+ * Submit a command to the HFA block
+ *
+ * @param command HFA command to submit
+ *
+ * @return Zero on success, negative on failure
+ */
+int cvmx_hfa_submit(cvmx_hfa_command_t * command);
+
+/**
+ * Allocate a block of memory from the free list that was passed
+ * to the application by the bootloader.
+ * 
+ * @param size      Size in bytes of block to allocate
+ * @param alignment Alignment required - must be power of 2
+ *
+ *  @return pointer to block of memory, NULL on error 
+ */
+
+void *hfa_bootmem_alloc(unsigned long int size, uint64_t alignment);
+
+/**
+ * Frees a block to the bootmem allocator list.  
+ *
+ * @param ptr  	   address of block  (memory pointer (void*))
+ * @param size     size of block in bytes.
+ *
+ * @return 1 on success,
+ *         0 on failure
+ *
+ */
+
+int hfa_bootmem_free(void *ptr, unsigned long int size);
+/**
+ * Finds a named bootmem block by name.
+ *
+ * @param name   name of block to free
+ *
+ * @return pointer to named block descriptor on success
+ *         0 on failure
+ */
+
+const cvmx_bootmem_named_block_desc_t *hfa_bootmem_find_named_block(const char *name);
+
+/**
+ * Create a named bootmem block by name.
+ *
+ * @param name   create named block with this name
+ *
+ * @return pointer to named block on success
+ *         NULL on failure
+ */
+
+void *hfa_bootmem_alloc_named( uint64_t size, uint64_t alignment, const char *name);
+
+/**
+ * Frees a named bootmem block by name.
+ *
+ * @param name   name of block to free
+ *
+ * @return 1 on success
+ *         0 on failure
+ */
+int  hfa_bootmem_free_named(const char *name);
+
+
+/**
+ * Flushes (and unlocks) the entire L2 cache.
+ * IMPORTANT: Must only be run by one core at a time due to use
+ * of L2C debug features.
+ */
+void hfa_l2c_flush(void);
+
+/**
+ * Given the chip processor ID from COP0, this function returns a
+ * string representing the chip model number. The string is of the
+ * form CNXXXXpX.X-FREQ-SUFFIX.
+ * - XXXX = The chip model number
+ * - X.X = Chip pass number
+ * - FREQ = Current frequency in Mhz
+ * - SUFFIX = NSP, EXP, SCP, SSP, or CP
+ *
+ * @param   chip_id     Chip ID
+ *
+ * @return Model string
+ */
+const char *hfa_octeon_model_get_string(uint32_t);
+
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+}
+/* *INDENT-ON* */
+#endif
+#endif /* __CVMX_HFA_H__ */
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-rwlock.h OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-rwlock.h
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-rwlock.h	1970-01-01 05:30:00.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/include/asm/octeon/cvmx-rwlock.h	2014-04-04 15:23:01.000000000 +0530
@@ -0,0 +1,162 @@
+/***********************license start***************
+ * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights
+ * reserved.
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+
+ *   * Neither the name of Cavium Inc. nor the names of
+ *     its contributors may be used to endorse or promote products
+ *     derived from this software without specific prior written
+ *     permission.
+
+ * This Software, including technical data, may be subject to U.S. export  control
+ * laws, including the U.S. Export Administration Act and its  associated
+ * regulations, and may be subject to export or import  regulations in other
+ * countries.
+
+ * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+ * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR
+ * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
+ * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
+ * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
+ * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
+ * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
+ * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
+ * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
+ * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
+ ***********************license end**************************************/
+
+/**
+ * @file
+ *
+ * This file provides reader/writer locks.
+ *
+ * <hr>$Revision: 73845 $<hr>
+ *
+ *
+ */
+
+#ifndef __CVMX_RWLOCK_H__
+#define __CVMX_RWLOCK_H__
+
+/* include to get atomic compare and store */
+#include "cvmx-atomic.h"
+
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+extern "C" {
+/* *INDENT-ON* */
+#endif
+
+/* Flags for lock value in rw lock structure */
+#define CVMX_RWLOCK_WRITE_FLAG     0x1
+#define CVMX_RWLOCK_READ_INC       0x2
+
+/* Writer preference locks (wp).  Can be starved by writers.  When a writer
+ * is waiting, no readers are given the lock until all writers are done.
+ */
+typedef struct {
+	volatile uint32_t lock;
+	volatile uint32_t write_req;
+	volatile uint32_t write_comp;
+} cvmx_rwlock_wp_lock_t;
+
+/**
+ * Initialize a reader/writer lock.  This must be done
+ * by a single core before used.
+ *
+ * @param lock   pointer to rwlock structure
+ */
+static inline void cvmx_rwlock_wp_init(cvmx_rwlock_wp_lock_t * lock)
+{
+	lock->lock = 0;
+	lock->write_req = 0;
+	lock->write_comp = 0;
+}
+
+/**
+ * Perform a reader lock.  If a writer is pending, this
+ * will wait for that writer to complete before locking.
+ *
+ * NOTE: Each thread/process must only lock any rwlock
+ * once, or else a deadlock may result.
+ *
+ * @param lock   pointer to rwlock structure
+ */ static inline void cvmx_rwlock_wp_read_lock(cvmx_rwlock_wp_lock_t * lock)
+{
+
+	/* Wait for outstanding write requests to be serviced */
+	while (lock->write_req != lock->write_comp) ;
+	/* Add ourselves to interested reader count */
+	cvmx_atomic_add32_nosync((int32_t *) & (lock->lock), CVMX_RWLOCK_READ_INC);
+	/* Wait for writer to finish.  No writer will start again
+	 ** until after we are done since we have already incremented
+	 ** the reader count
+	 */
+	while (lock->lock & CVMX_RWLOCK_WRITE_FLAG) ;
+
+}
+
+/**
+ * Perform a reader unlock.
+ *
+ * @param lock   pointer to rwlock structure
+ */
+static inline void cvmx_rwlock_wp_read_unlock(cvmx_rwlock_wp_lock_t * lock)
+{
+	/* Remove ourselves to reader count */
+	cvmx_atomic_add32_nosync((int32_t *) & (lock->lock), -CVMX_RWLOCK_READ_INC);
+}
+
+/**
+ * Perform a writer lock.  Any readers that attempt
+ * to get a lock while there are any pending write locks
+ * will wait until all writers have completed.  Starvation
+ * of readers by writers is possible and must be avoided
+ * by the application.
+ *
+ * @param lock   pointer to rwlock structure
+ */
+static inline void cvmx_rwlock_wp_write_lock(cvmx_rwlock_wp_lock_t * lock)
+{
+	/* Get previous value of write requests */
+	uint32_t prev_writers = ((uint32_t) cvmx_atomic_fetch_and_add32((int32_t *) & (lock->write_req), 1));
+	/* Spin until our turn */
+	while (prev_writers != lock->write_comp) ;
+	/* Spin until no other readers or writers, then set write flag */
+	while (!cvmx_atomic_compare_and_store32((uint32_t *) & (lock->lock), 0, CVMX_RWLOCK_WRITE_FLAG)) ;
+
+}
+
+/**
+ * Perform a writer unlock.
+ *
+ * @param lock   pointer to rwlock structure
+ */
+static inline void cvmx_rwlock_wp_write_unlock(cvmx_rwlock_wp_lock_t * lock)
+{
+	/* Remove our writer flag */
+	CVMX_SYNCWS;		/* Make sure all writes in protected region are visible before unlock */
+	cvmx_atomic_add32_nosync((int32_t *) & (lock->lock), -CVMX_RWLOCK_WRITE_FLAG);
+	cvmx_atomic_add32_nosync((int32_t *) & (lock->write_comp), 1);
+	CVMX_SYNCWS;		/* push unlock writes out, but don't stall */
+}
+
+#ifdef	__cplusplus
+/* *INDENT-OFF* */
+}
+/* *INDENT-ON* */
+#endif
+
+#endif /* __CVMX_RWLOCK_H__ */
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/uapi/asm/sysmips.h OCTEON-SDK/linux/kernel/linux/arch/mips/include/uapi/asm/sysmips.h
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/include/uapi/asm/sysmips.h	2014-04-04 15:14:12.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/include/uapi/asm/sysmips.h	2014-04-04 15:23:01.000000000 +0530
@@ -21,6 +21,7 @@
 #define MIPS_FIXADE		   7	/* control address error fixing	 */
 #define MIPS_RDNVRAM		  10	/* read NVRAM */
 #define MIPS_ATOMIC_SET		2001	/* atomically set variable	 */
+#define MIPS_CAVIUM_L2C_FLUSH    2002  /* flush L2C    */
 #define MIPS_CAVIUM_XKPHYS_READ  2010	/* XKPHYS */
 #define MIPS_CAVIUM_XKPHYS_WRITE 2011	/* XKPHYS */
 
diff -purN OCTEON-SDK-org/linux/kernel/linux/arch/mips/kernel/syscall.c OCTEON-SDK/linux/kernel/linux/arch/mips/kernel/syscall.c
--- OCTEON-SDK-org/linux/kernel/linux/arch/mips/kernel/syscall.c	2014-04-04 15:14:12.000000000 +0530
+++ OCTEON-SDK/linux/kernel/linux/arch/mips/kernel/syscall.c	2014-04-04 15:23:01.000000000 +0530
@@ -43,6 +43,7 @@
 extern int xkphys_usermem_read(long);
 extern int xkphys_usermem_write(long, int);
 #endif
+extern void cvmx_l2c_flush(void);
 
 /*
  * For historic reasons the pipe(2) syscall on MIPS has an unusual calling
@@ -226,9 +227,13 @@ SYSCALL_DEFINE3(sysmips, long, cmd, long
 
 		return 0;
 
-	case FLUSH_CACHE:
-		__flush_cache_all();
-		return 0;
+    case FLUSH_CACHE:
+        __flush_cache_all();
+        return 0;
+
+    case MIPS_CAVIUM_L2C_FLUSH:
+        cvmx_l2c_flush();
+        return 0;
 
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 	case MIPS_CAVIUM_XKPHYS_READ:

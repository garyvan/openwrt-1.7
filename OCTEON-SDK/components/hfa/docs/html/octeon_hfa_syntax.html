<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OCTEON HFA SDK 3.1.0: OCTEON HFA COMPILER PATTERN SYNTAX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OCTEON HFA SDK 3.1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('octeon_hfa_syntax.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">OCTEON HFA COMPILER PATTERN SYNTAX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="hfac_patterns"></a>
Patterns Accepted By HFA RegEx Compiler</h1>
<p>The HFA complier can interpret patterns as regular expressions with a syntax that is close to but not fully-compatible with PCRE (Perl Compatible Regular Expressions). The compiler can compile the patterns in one of several modes that may be optimal for certain kinds of patterns. The mode selected affects the patterns that are eligible to use as well as the contents of the compiled graph.</p>
<p><a class="anchor" id="strings_mode"></a></p>
<ul>
<li><b>Strings</b> mode is a simple string-matching mode. The compiler interprets patterns as strings and not as regular expressions. The grammar is much simpler and the patterns are composed of string literals <a class="anchor" id="regex_mode"></a></li>
<li><b> Regular Expressions (RegEx)</b> mode causes the HFA complier to interpret patterns as regular expressions with a syntax that is close to but not fully-compatible with PCRE (Perl Compatible Regular Expressions). Features of PCRE which are not relevant to Deep Packet Inspection (DPI) have not been implemented. <a class="anchor" id="sc_mode"></a></li>
<li><b> Strings Composite (SC)</b> mode is optimized for higher performance. A pattern may incorporate PCRE compatible regular expressions but must contain a string literal of at least <b>minlen</b> bytes. SC mode is recommended for situations where a majority of patterns are of the form <b>string1.*string2</b>. Using SC mode in such situations will cause more relevant nodes to be allocated in the DFA portion of the graph and thus improve performance of graph-walk operations. <a class="anchor" id="rc_mode"></a></li>
<li><b>Regular Expressions Composite (RC)</b> mode allows patterns with more flexibility than SC mode. A pattern may incorporate PCRE compatible regular expressions but must contain a sub-expression with determinable length at least <b>minlen</b>. RC mode is recommended for situations where a majority of the patterns are of the form <b>regex1.*regex2</b>. Using RC mode in such situations will cause more relevant nodes to be allocated in the DFA portion of the graph and thus improve performance of graph-walk operations.</li>
</ul>
<h2><a class="anchor" id="patterns_strings"></a>
1.1 Patterns that constitute String literals</h2>
<h3><a class="anchor" id="strings_printable"></a>
1.1.1 Printable characters</h3>
<p>All ASCII printable characters <b>[a-zA-Z0-9]</b> are permitted.</p>
<h3><a class="anchor" id="strings_special"></a>
1.1.2 Special characters</h3>
<p>These character sequences may be used within a pattern to represent characters that are non-printable or to escape the interpretation of metacharacters. The backslash character "\" signals the pattern compiler that the subsequent character sequence has a special meaning.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Pattern</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\a</td><td id="MiddleColumn">Alarm. The BEL character (hex 07)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\cx</td><td id="MiddleColumn">Control-x, where x is any character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\e</td><td id="MiddleColumn">Escape (hex 1B)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\f</td><td id="MiddleColumn">Form feed (hex 0C)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\n</td><td id="MiddleColumn">Newline (hex 0A)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\r</td><td id="MiddleColumn">Carriage return (hex 0D)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\t</td><td id="MiddleColumn">Tab (hex 09)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\v</td><td id="MiddleColumn">Vertical whitespace character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\ddd</td><td id="MiddleColumn">Character with octal code ddd</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\xhh</td><td id="MiddleColumn">Character with hex code hh</td><td id="LastColumn">"\x0a\x0d\x12" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">Note: two hexadecimal digits must</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">always follow the <b>\x</b> </td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\x</td><td id="MiddleColumn">Treat <b>x</b> as a literal when <b>\x</b> is</td><td id="LastColumn">The pattern <b>\#</b> matches </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">none of the patterns defined above</td><td id="LastColumn">the <b>#</b> in "a#b" i.e. </td></tr>
<tr id="LastRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn"><b>\#</b> == <b>#</b>  </td></tr>
</table>
<h3><a class="anchor" id="strings_options"></a>
1.1.3 Option settings</h3>
<p>The options for a string can be specified between braces "{" and "}" at the beginning of a string.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Option</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">@0</td><td id="MiddleColumn">Anchored. Match at start of input</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">!</td><td id="MiddleColumn">Terminal. HFA skips processing the</td><td id="LastColumn">This is supported only in </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">rest of the buffer if a pattern</td><td id="LastColumn">-dfa mode. This flag is </td></tr>
<tr id="LastRow">
<td id="FirstColumn"></td><td id="MiddleColumn">with the terminal flag is found.</td><td id="LastColumn">ignored otherwise. </td></tr>
</table>
<h3><a class="anchor" id="strings_comment"></a>
1.1.4 Comment</h3>
<p>A line is treated as a comment if it starts with a <b>#</b>. If a <b>#</b> is found within a string, it is treated as part of the string.</p>
<h2><a class="anchor" id="patterns_regex"></a>
1.2 Patterns that constitute Regular Expressions</h2>
<p>The Regular Expression syntax recognized by the compiler is largely identical to PCRE with a few exceptions.</p>
<h3><a class="anchor" id="regex_metachars"></a>
1.2.1 Meta Characters</h3>
<p>Meta characters are interpreted as having a special meaning by the HFA compiler.</p>
<table  class="doxtable">
<tr>
<th>Character  </th><th>Description  </th><th>Example/Notes   </th></tr>
<tr>
<td>^  </td><td>In single-line mode: not supported In multi-line mode: match after any newline (\n) in the string which is not the final character in the string.  </td><td>HFA device supports only multi-line mode. The meta characters "^" and "$" are replaced with the character "\n". Hence, the pattern "^cavium" becomes "\ncavium" and the pattern "cavium$" becomes "cavium\n".   </td></tr>
<tr>
<td>$  </td><td>In single line mode: not supported. In multiline mode: match the newline in the string or at the end of the string.  </td><td>HFA device supports only multi-line mode. The meta characters "^" and "$" are replaced with the character "\n". Hence, the pattern "^cavium" becomes "\ncavium" and the pattern "cavium$" becomes "cavium\n".   </td></tr>
<tr>
<td>[  </td><td>Start of character class definition  </td><td>The pattern "[3-6]" matches numbers in the range from 3-6, inclusive (3,4,5,6).   </td></tr>
<tr>
<td>]  </td><td>End of character class definition   </td></tr>
<tr>
<td>(  </td><td>Start of sub pattern (grouping)  </td><td>See example below. Use {c} at beginning of the rule to use as a capture group.   </td></tr>
<tr>
<td>)  </td><td>End of sub pattern (grouping)  </td><td>See example below. Use {c} at beginning of the rule to use as a capture group.   </td></tr>
<tr>
<td>|  </td><td>Alternation: expr1|expr2|expr3 will match any of the expressions in the set (expr1 or expr2 or expr3).  </td><td>The pattern "(a|b)" matches either "a" or "b". eg. "t(h|i|o)e" will match "the", "tie", and "toe". It is permissible to not have an expression following the "|" operator. The pattern "cater(act|pillar|)" matches the three strings "cater", "cateract" and "caterpillar"   </td></tr>
<tr>
<td>\  </td><td>(Backslash) The "escape" character. This can be used to interpret the next character literally, rather than as a metacharacter. For example "." means the period character. The character immediately after the "\" must be non-alphanumeric.  </td><td>The pattern ".com" will match the string ".com"   </td></tr>
<tr>
<td>-  </td><td>(Hyphen) When used in a character class definition (within [ ]), it specifies a range as in a-z or 0-9 (In ASCII, characters a-z are represented by sequential numeric values. So a "range" has clear numeric meaning).  </td><td>The pattern "[a-z]" will match the lower case alphabet letters from "a" to "z". The pattern "[1-3]" will match "1", "2", or "3".   </td></tr>
<tr>
<td>,  </td><td>(Comma) When used in a character class definition (within [ ]), it means either/or.  </td><td>The pattern "[a,b]" means "a" and/or "b".   </td></tr>
<tr>
<td>#  </td><td>Comment (nestable) Note: A line is treated part of a comment only if it starts with a "#". If "#" is found within a pattern, it is treated as part of the pattern  </td><td></td></tr>
</table>
<h3><a class="anchor" id="regex_quantifiers"></a>
1.2.2 Quantifiers</h3>
<p>Quantifiers are characters which specify the repetitions of repetitive patterns. </p>
<table  class="doxtable">
<tr>
<th>Quantifier  </th><th>Description  </th><th>Example/Notes   </th></tr>
<tr>
<td>*  </td><td>(Asterisk) zero or more, greedy. Equivalent to {0, }  </td><td>An asterisk following a dot ".*" will match any number of characters except a newline (see <a class="el" href="octeon_hfa_syntax.html#note_2">Note 2</a>). The pattern "t.*r" will match all characters from a "t" until an "r". It will match "their" or "the red". The pattern "(hello)*" will match the pattern "hello" as many times as it occurs , as in "hellohellohello". (See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>)   </td></tr>
<tr>
<td>+  </td><td>One or more, greedy. Equivalent to {1, }  </td><td>(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>)   </td></tr>
<tr>
<td>?  </td><td>Zero or one, greedy. Equivalent to {0, 1}  </td><td>(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>)   </td></tr>
<tr>
<td>{n}  </td><td>Exactly n occurrences  </td><td>Unlike PCRE, "{0}" is not permitted.   </td></tr>
<tr>
<td>{n,m}  </td><td>At least n, no more than m, greedy  </td><td>The pattern "(hello){0,8}" means the string "hello" repeated at least 0 and no more than 8 times, such as "hellohellohello". (See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>)   </td></tr>
<tr>
<td>{n,}  </td><td>n or more, greedy  </td><td>(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>)   </td></tr>
<tr>
<td>{,m}  </td><td>At most m, greedy  </td><td>(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>)   </td></tr>
</table>
<h3><a class="anchor" id="regex_quantifier_greediness"></a>
1.2.3 Greediness of Quantifiers</h3>
<p>Add the "?" or "+" character to the quantifier to change the matching behavior. "?" means lazy, "+" means possessive. See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Quantifier</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">*?</td><td id="MiddleColumn">Zero or more, lazy</td><td id="LastColumn">(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">+?</td><td id="MiddleColumn">One or more, lazy</td><td id="LastColumn">(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">??</td><td id="MiddleColumn">Zero or one, lazy</td><td id="LastColumn">(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">*+</td><td id="MiddleColumn">Zero or more, possessive</td><td id="LastColumn">(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">?+</td><td id="MiddleColumn">Zero or one, possessive</td><td id="LastColumn">(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>) </td></tr>
<tr id="LastRow">
<td id="FirstColumn">++</td><td id="MiddleColumn">One or more, possessive</td><td id="LastColumn">(See <a class="el" href="octeon_hfa_syntax.html#note_1">Note 1</a>) </td></tr>
</table>
<p><a class="anchor" id="note_1"></a></p>
<dl class="section note"><dt>Note</dt><dd>LAZY is currently defined (through CFLAGS) for the post-processor. This forces all patterns to be processed as lazy. Possessive quantifiers in the graph are ignored.</dd></dl>
<p><a class="anchor" id="note_2"></a></p>
<dl class="section note"><dt>Note</dt><dd>The HFA compiler allows the user to redefine the meaning of "." with a special syntax. Note that when a pattern starts with ".*", the compiler replaces "." with "any character including newline", even if "." has been redefined.</dd></dl>
<h3><a class="anchor" id="regex_special_chars"></a>
1.2.4 Special Characters</h3>
<p>These character sequences may be used within a pattern to represent characters that are non-printable or to escape the interpretation of metacharacters. The backslash character "\" signals the pattern compiler that the following character sequence has a special meaning.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Pattern</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\a</td><td id="MiddleColumn">Alarm. The BEL character (hex 07)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\cx</td><td id="MiddleColumn">Control-x, where x is any character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\e</td><td id="MiddleColumn">Escape (hex 1B)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\f</td><td id="MiddleColumn">Form feed (hex 0C)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\n</td><td id="MiddleColumn">Newline (hex 0A)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\r</td><td id="MiddleColumn">Carriage return (hex 0D)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\t</td><td id="MiddleColumn">Tab (hex 09)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\ddd</td><td id="MiddleColumn">Character with octal code ddd</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\xhh</td><td id="MiddleColumn">Character with hex code hh</td><td id="LastColumn">"\x0a\x0d\x12" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">Note: two hexadecimal digits must</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">always follow the "\x"</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\x{hhh…}</td><td id="MiddleColumn">Character with hex code hhh</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\x</td><td id="MiddleColumn">Treat x as a literal when x is not</td><td id="LastColumn">The pattern "\#" matches </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">alphanumeric</td><td id="LastColumn">the "#" in "a#b" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\Q</td><td id="MiddleColumn">Begin quote mode. Treat as literals</td><td id="LastColumn">The pattern "\Qa*b\E" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">all the characters that follow, until</td><td id="LastColumn">matches "a*b" in "a*b" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">a "\E" is encountered</td><td id="LastColumn"></td></tr>
<tr id="LastRow">
<td id="FirstColumn">\E</td><td id="MiddleColumn">End quote mode</td><td id="LastColumn"></td></tr>
</table>
<h3><a class="anchor" id="regex_char_class"></a>
1.2.5 Character Classes</h3>
<p>These patterns can be used to represent groups of characters.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Pattern</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">[…]</td><td id="MiddleColumn">Positive character class</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">[^…]</td><td id="MiddleColumn">Negative character class</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">[x-y]</td><td id="MiddleColumn">Range (can be used for hex/octal</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">characters or alphabets)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">[[:class:]]</td><td id="MiddleColumn">Positive POSIX named set</td><td id="LastColumn">"class" is one of the </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">(character class).</td><td id="LastColumn"><a class="el" href="octeon_hfa_syntax.html#regex_posix_cc">1.2.6 POSIX Character Classes</a>. </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">[[:^class:]]</td><td id="MiddleColumn">Negative POSIX named set</td><td id="LastColumn">"class" is one of the </td></tr>
<tr id="LastRow">
<td id="FirstColumn"></td><td id="MiddleColumn">(character class).</td><td id="LastColumn"><a class="el" href="octeon_hfa_syntax.html#regex_posix_cc">1.2.6 POSIX Character Classes</a>. </td></tr>
</table>
<h3><a class="anchor" id="regex_posix_cc"></a>
1.2.6 POSIX Character Classes</h3>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Class</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">alnum</td><td id="MiddleColumn">Alphanumeric (a-z, A-Z, 0-9)</td><td id="LastColumn">[[:alnum:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">alpha</td><td id="MiddleColumn">Alphabetic (a-z, A-Z)</td><td id="LastColumn">[[:alpha:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ascii</td><td id="MiddleColumn">0-127</td><td id="LastColumn">[[:ascii:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">blank</td><td id="MiddleColumn">SPACE or TAB</td><td id="LastColumn">[[:blank:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">cntrl</td><td id="MiddleColumn">Control character</td><td id="LastColumn">[[:cntrl:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">digit</td><td id="MiddleColumn">Decimal digit (0-9)</td><td id="LastColumn">[[:digit:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">graph</td><td id="MiddleColumn">Printing, excluding space</td><td id="LastColumn">[[:graph:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">lower</td><td id="MiddleColumn">Lower case letter (a-z)</td><td id="LastColumn">[[:lower:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">print</td><td id="MiddleColumn">Printable characters, including SPACE</td><td id="LastColumn">[[:print:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">punct</td><td id="MiddleColumn">Printable characters, except for</td><td id="LastColumn">[[:punct:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">alphanumeric characters</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">space</td><td id="MiddleColumn">Whitespace (SPACE or TAB)</td><td id="LastColumn">[[:space:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">upper</td><td id="MiddleColumn">Upper case letter (A-Z)</td><td id="LastColumn">[[:upper:]] </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">word</td><td id="MiddleColumn">Equivalent to \w</td><td id="LastColumn">[[:word:]] </td></tr>
<tr id="LastRow">
<td id="FirstColumn">xdigit</td><td id="MiddleColumn">Hexadecimal digit (0-9, A-F, a-f)</td><td id="LastColumn">[[:xdigit:]] </td></tr>
</table>
<h3><a class="anchor" id="regex_characters"></a>
1.2.7 Characters Classes in Short-form</h3>
<p>Some character classes or groups of characters can be represented using a shorter notation as detailed below.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Pattern</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">.</td><td id="MiddleColumn">(dot) This "wildcard character" will</td><td id="LastColumn">The pattern "t.e" will </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">match any character except newline</td><td id="LastColumn">match "the", "tie", "toe" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">will not match "thie". </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">The dot wildcard will </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">match only one character </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">except a newline). </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">Note: Can be redefined to </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">any character class as </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">specified in </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn"><a class="el" href="octeon_hfa_syntax.html#regex_options">1.2.8 Option settings</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\d</td><td id="MiddleColumn">A decimal digit (0-9)</td><td id="LastColumn">Will match 0, 1, 2, 3, 4, </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">5, 6, 7, 8, 9 </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\D</td><td id="MiddleColumn">A character that is not a decimal digit</td><td id="LastColumn">Will match, a,b,c, etc. </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\h</td><td id="MiddleColumn">A horizontal whitespace character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">(SPACE or TAB)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\H</td><td id="MiddleColumn">A character that is not a horizontal</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">whitespace character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\s</td><td id="MiddleColumn">A whitespace character (SPACE, TAB, or</td><td id="LastColumn">"\v" is not included </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">CRLF)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\S</td><td id="MiddleColumn">A character that is not a whitespace</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\v</td><td id="MiddleColumn">A vertical whitespace character (CRLF)</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\V</td><td id="MiddleColumn">A character that is not a vertical</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">whitespace character</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\w</td><td id="MiddleColumn">A "word" character ( _,a-z, A-Z, 0-9)</td><td id="LastColumn"></td></tr>
<tr id="LastRow">
<td id="FirstColumn">\W</td><td id="MiddleColumn">A "non-word" character</td><td id="LastColumn"></td></tr>
</table>
<h3><a class="anchor" id="regex_options"></a>
1.2.8 Option settings</h3>
<p>The options for a pattern can be specified between braces "{" and "}" at the beginning of a pattern. These options apply to the complete pattern. If more than one option needs to be specified, they can be separated with commas. The possible options are:</p>
<table  class="doxtable">
<tr>
<th>Option  </th><th>Description  </th><th>Example/Notes   </th></tr>
<tr>
<td>i  </td><td>Caseless: ignore whether character is in upper or lower case  </td><td>Note: both {i} and {&amp;} are supported but {i} is recommended as this is PCRE compatible   </td></tr>
<tr>
<td>s  </td><td>dot all. By default, a dot (".") represents the class including every character but a newline (equivalent to "[^\n]"). In dot all mode, it includes every character (equivalent to "[\x00-\xff]")  </td><td></td></tr>
<tr>
<td>m  </td><td>Multi-line mode  </td><td>HFA device supports only multi-line mode and hence it is enabled by default. The "m" modifier specified in the options list is ignored.   </td></tr>
<tr>
<td>x  </td><td>PCRE-extended mode In PCRE-extended mode, whitespaces inside a pattern are ignored. The "#" character is treated as the start of a comment and all characters following it till the end of line are ignored.  </td><td>Comments may be inserted in between a comment using the syntax "(?#…)"   </td></tr>
<tr>
<td>t  </td><td>Report start offset  </td><td>Note: enabling this option may require more buffer memory   </td></tr>
<tr>
<td>c  </td><td>Report captured sub-patterns Up to 5 (1…5) capturing parentheses are allowed. If a pattern includes more than 5 capturing parentheses, the additional ones are ignored and a warning is logged to hfa.warn file. By default, capturing is disabled. To enable capturing, the "{c}" option must be specified at the beginning of a pattern.  </td><td>If a pattern has at least one backreference, capturing is enabled regardless of whether "{c}" is specified or not   </td></tr>
<tr>
<td>@off  </td><td>Anchored. Match at byte offset "off" from start of input  </td><td></td></tr>
<tr>
<td>@-off  </td><td>Match at byte offset "off" from end of input  </td><td></td></tr>
<tr>
<td>!  </td><td>Terminal. HFA skips processing the rest of the buffer if a pattern with the terminal flag is found.  </td><td>This is supported only in -dfa mode. This flag is ignored otherwise.   </td></tr>
<tr>
<td>.=[…]  </td><td>Define the character class for the "." meta character  </td><td></td></tr>
</table>
<p>The options specified at the beginning of a pattern can be modified inside a pattern using the pcre option modifier syntax (?…) "hello(?i)world" is equivalent to "hello[wW][oO][rR][lL][dD]" "hello((?i)wor)ld" is equivalent to "hello[wW][oO][rR]ld"</p>
<p>To unset an option, "-" can be prefixed to the option modifier "{i}hello(?s-i)world" sets the "dot all" mode and unsets the "case in-sensitive" mode.</p>
<h3><a class="anchor" id="regex_assertion"></a>
1.2.9 Assertions</h3>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Pattern</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\A</td><td id="MiddleColumn">Ignored</td><td id="LastColumn">Not supported since the HFA </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">always operates in multiline </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">mode </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\b</td><td id="MiddleColumn">Word boundary assertion</td><td id="LastColumn">Match at word boundary </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\B</td><td id="MiddleColumn">Non-word boundary assertion</td><td id="LastColumn">Match at non-word boundary </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\G</td><td id="MiddleColumn">Ignored</td><td id="LastColumn">Not supported since the HFA </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">always operates in multiline </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">mode </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\z</td><td id="MiddleColumn">Ignored</td><td id="LastColumn">Not supported since the HFA </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">always operates in multiline </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">mode </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\Z</td><td id="MiddleColumn">Ignored</td><td id="LastColumn">Not supported since the HFA </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">always operates in multiline </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">mode </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(?=…)</td><td id="MiddleColumn">Positive look-ahead assertion</td><td id="LastColumn">Match if followed by pattern </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">The pattern "x(?=y)" matches </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">"x" in "xy" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(?!…)</td><td id="MiddleColumn">Negative look-ahead assertion</td><td id="LastColumn">Match if not followed by </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">pattern. The pattern "x(?!y)" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">matches "x" in "xz" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(?&lt;=…)</td><td id="MiddleColumn">Positive look-behind assertion</td><td id="LastColumn">Match if preceeded by </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">pattern. The pattern </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">"(?&lt;=x)y" matches "y" in "xy" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(?&lt;!…)</td><td id="MiddleColumn">Negative look-behind assertion</td><td id="LastColumn">Match if not preceeded by </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">pattern. The pattern </td></tr>
<tr id="LastRow">
<td id="FirstColumn"></td><td id="MiddleColumn"></td><td id="LastColumn">"(?&lt;!x)y" matches "y" in "zy" </td></tr>
</table>
<p>The "offset from start of input" and "offset from end of input" assertions are supported. These assertions can be enabled by adding "@off" or "@-off" to the <a class="el" href="octeon_hfa_syntax.html#regex_options">1.2.8 Option settings</a> at the start of the pattern.</p>
<p>The following contraints apply:</p>
<ul>
<li><a class="el" href="octeon_hfa_syntax.html#regex_caps_backrefs">1.2.10 Captures and back-references</a> are not permitted inside assertions</li>
<li>Recursive assertions are not supported</li>
</ul>
<h3><a class="anchor" id="regex_caps_backrefs"></a>
1.2.10 Captures and back-references</h3>
<p>Upto 5 capturing parentheses are permitted. If more than 5 capturing parentheses are present in a pattern, the additional ones are ignored and a warning is logged to hfa.warn file.</p>
<p>By default, capturing is disabled. To enable capturing, the "{c}" option must be specified at the beginning of the pattern. If the pattern contains any back-references, capturing is enabled regardless of whether "{c}" is specified or not.</p>
<p>Captured sub-patterns can be referred to with back-references.</p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">Pattern</td><td id="MiddleColumn">Description</td><td id="LastColumn">Example/Notes </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(…)</td><td id="MiddleColumn">numbered capture</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(?&lt;name&gt;…)</td><td id="MiddleColumn">named capture</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">(?'name'…)</td><td id="MiddleColumn">named capture</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\n</td><td id="MiddleColumn">numbered backreference</td><td id="LastColumn">The pattern "{c}(foo)bar\1" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">n must be an integer between 1 and</td><td id="LastColumn">matches "foobarfoo" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">and 5</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\gn</td><td id="MiddleColumn">numbered backreference</td><td id="LastColumn">The pattern "{c}(foo)bar\g1" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">n must be an integer between 1 and</td><td id="LastColumn">matches "foobarfoo" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">and 5</td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\g{n}</td><td id="MiddleColumn">numbered backreference</td><td id="LastColumn">The pattern </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">n must be an integer between 1 and</td><td id="LastColumn">"{c}(foo)bar\g{1}" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">and 5</td><td id="LastColumn">matches "foobarfoo" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\k&lt;name&gt;</td><td id="MiddleColumn">named backreference</td><td id="LastColumn">The pattern </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">where "name" refers to a preceding</td><td id="LastColumn">"{c}(?&lt;xxx&gt;foo)bar\k&lt;xxx&gt;" </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">named capture</td><td id="LastColumn">matches "foobarfoo", </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">\k'name'</td><td id="MiddleColumn">named backreference</td><td id="LastColumn">The pattern </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"></td><td id="MiddleColumn">where "name" refers to a preceding</td><td id="LastColumn">"{c}(?'xxx'foo)bar\k'xxx'" </td></tr>
<tr id="LastRow">
<td id="FirstColumn"></td><td id="MiddleColumn">named capture</td><td id="LastColumn">matches "foobarfoo", </td></tr>
</table>
<p>When capturing is enabled for a pattern, it can be disabled for a particular sub-pattern (to group the sub-pattern without capturing), if the pattern is placed within non-capturing parentheses "(?:…)". Empty parentheses "()" are not permitted.</p>
<h3><a class="anchor" id="regex_cond_match"></a>
1.2.11 Conditional matches</h3>
<p>Not supported</p>
<h3><a class="anchor" id="regex_callout"></a>
1.2.12 Callouts</h3>
<p>Not supported</p>
<h2><a class="anchor" id="patterns_sc"></a>
1.3 Patterns that constitute Strings composite (SC) mode</h2>
<p>SC mode is optimized for higher performance but requires that each rule contain a sequence of at least <b>minlen</b> (configurable via the <b>minlen</b> command-line option) literal bytes. The remaining portion of the pattern may incorporate PCRE compatible regular expressions with the same syntax as in RegEx mode.</p>
<p>SC mode is recommended for situations where majority of patterns are of the form <b>string1.*string2</b>. Using SC mode in such situations will improve the performance of graph-searches by moving relevant nodes to the DFA portion of the graph.</p>
<h2><a class="anchor" id="patterns_rc"></a>
1.4 Patterns that constitute RegEx composite (RC) mode</h2>
<p>Patterns have the same syntax as in RegEx mode but each rule must have a sub-expression whose length is (determinably) at least <b>minlen</b> (configurable via the <b>minlen</b> command-line option).</p>
<p>RC mode is recommended for situations where majority of patterns are of the form <b>regex1.*regex2</b>. Using RC mode in such situations will improve the performance of graph-searches by moving relevant nodes to the DFA portion of the graph. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>

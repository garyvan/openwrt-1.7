<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OCTEON HFA SDK 3.1.0: INTRODUCTION TO OCTEON HFA SDK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OCTEON HFA SDK 3.1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('overview.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">INTRODUCTION TO OCTEON HFA SDK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="hfasdk_targets"></a>
OCTEON HFA TARGETS</h1>
<p>This release supports the following HFA devices (or Targets).</p>
<ol type="1">
<li>cn60XX</li>
<li>cn61XX</li>
<li>cn62XX</li>
<li>cn63XX</li>
<li>cn66XX</li>
<li>cn68XX</li>
<li>cn70XX</li>
<li>cn71XX</li>
</ol>
<p>Depending on OCTEON targets, OCTEON HFA contains one or more HFA clusters. Each clusters contains 16 HFA Thread Engines (HTEs). Please refer <a class="el" href="hfa_targets.html#octeon_hfa_family">OCTEON II/III HFA DEVICES</a> for description of HFA hardware block on various OCTEON chips.</p>
<p>Depending upon the OCTEON HFA targets following are the HFA instructions types</p>
<ul>
<li>GRAPH MLOAD (only in CN63XX and CN66X)</li>
<li>GRAPH CLOAD</li>
<li>GRAPH WALK</li>
<li>GRAPH FREE</li>
</ul>
<h1><a class="anchor" id="hfasdk_operatingenv"></a>
OPERATING ENVIRONMENTS</h1>
<p>OCTEON HFA SDK provides support for <b>three</b> operating environments:</p>
<ul>
<li>Simple Executive (SE)</li>
<li>Simple Executive - User Mode over LINUX (SEUM)</li>
<li>LINUX Kernel (KERNEL)</li>
</ul>
<p><b>Note:</b> </p>
<ul>
<li>OCTEON HFA SDK supports only one application and only one operating environment at a time</li>
</ul>
<h1><a class="anchor" id="hfasdk_compile"></a>
COMPILATION</h1>
<p>HFA libraries and provided reference applications for each HFA operating environment can be created independently. Following steps to be executed for each HFA operating environment to get HFA library and reference application binaries.</p>
<pre class="fragment">        # cd $OCTEON_ROOT
        # . env-setup &lt;OCTEON_MODEL&gt;
        # cd components/hfa
        # make OCTEON_MODE=&lt;se|seum|kernel&gt;
</pre><p>Above steps will create library libcvmhfa.a(for SE/SEUM) OR the LINUX kernel module <a href="cvm-hfa-module_8c.html#define-members" class="el">HFA_LIB_MODULE</a> at $HFAROOT/lib/octeon/hfa/&lt;OCTEON_MODE&gt;</p>
<h1><a class="anchor" id="hfasdk_running_app"></a>
WHAT SDK OFFERS?</h1>
<p>OCTEON HFA SDK is fully featured SDK that comes with software libraries, tools and exhaustive list of reference applications. OCTEON HFA SDK provides efficient usage and management of OCTEON® II/III HFA engine. Following are the OCTEON HFA SDK offerings: </p>
<h2><a class="anchor" id="hfasdk_hfatools"></a>
a. HFA TOOLS</h2>
<ul>
<li><a class="el" href="octeon_hfa_tools.html#hfa_compiler">HFA RegEx Complier</a> – create OCTEON HFA graph file from input pattern file. The input file contains RegEx/Strings patterns. This output file is loadable on OCTEON HFA engine. GRAPH MLOAD instruction loads memory portion and GRAPH CLOAD instruction loads cache portion of OCTEON HFA graph on HFA hardware. The payload (either network or local file) is scanned against the loadable graph using GRAPH WALK instruction. Refer section <a class="el" href="overview.html#hfasdk_graph">a. GENERATE OCTEON HFA GRAPH</a></li>
<li><a class="el" href="octeon_hfa_tools.html#hfa_verifier">HFA Graph/Info Verifier</a> – Verifies compiled graph by displaying its attributes such as memory/cache region, compiled options etc.</li>
<li><a class="el" href="octeon_hfa_tools.html#hfa_walker">HFA Hardware Simulator (or HFA Walker)</a> – simulate OCTEON HFA engine on x86 /x86_64 host machine</li>
<li><a class="el" href="octeon_hfa_tools.html#hfa_linker">HFA Graph Linker</a> – Each HFA Cluster has maximum limit of 64 graphs that can be physically loaded. In case more graphs (&gt; 64) are required to be loaded on each HFA Cluster, the linker can be used to link multiple graph files into one. </li>
</ul>
<h2><a class="anchor" id="hfasdk_hfaapi"></a>
b. HFA SDK LIBRARIES AND APIs</h2>
<p>HFA APIs provide a flexible interface to interact with and control the HFA engine. The API provides access to the HFA engine at different levels allowing for varied schemes and complexities of application software to interface with HFA engine. The API allows software to work at the lower HFA instruction level or at a higher HFA object-oriented level.</p>
<ol type="1">
<li><a class="el" href="octeon_hfa_sdk_library.html#hfail_api">HFA Instruction-Level API</a> API expose the raw programmable interface to the HFA engine and are intended only for specialized applications, which cannot use the higher-level APIs efficiently. The application software can take complete control of the HFA engine using this interface and the complexity of ensuring proper use of HFA engine will become part of the application. This API provides ability to:<ul>
<li>Construct an HFA instruction</li>
<li>Submit an HFA instruction to the engine</li>
<li>Check for the status of an HFA instruction.</li>
<li>Extract fields from the result word.<br/>
</li>
</ul>
</li>
<li><a class="el" href="octeon_hfa_sdk_library.html#hfaoo_api">HFA Object-Oriented API</a> API provides an intuitive object-oriented view of the HFA engine. The API handles much of the complexity involved in interacting with the HFA engine without sacrificing flexibility in software design. The various sub-blocks of the HFA paradigm are exposed via this API for ease of configuration. The API also provides an abstraction over subtle differences in the OCTEON II/III HFA device family. Applications can be designed on top of this object-based interface. This API provides an interface to:<ul>
<li>Initialize/Shutdown the OCTEON-HFA hardware block</li>
<li>Set up the Memory resources needed to manage the interactions between the application and HFA engine.</li>
<li>Allocate memory/cache to HFA clusters</li>
<li>RAM Download/Cache Load compiled graphs using linear mode.</li>
<li>Create a Search Context with linear/gather support to track searches across buffers.</li>
<li>Retrieve the status and results from pending search operations.</li>
</ul>
</li>
</ol>
<p><b>Note</b> Refer section <a class="el" href="overview.html#hfasdk_design">DESIGN</a> for more details about HFA Object oriented APIs </p>
<h2><a class="anchor" id="hfasdk_refapp"></a>
c. APPLICATIONS</h2>
<p>The OCTEON HFA SDK comes with various illustrative applications which showcase the use of HFA APIs. The applications cover various scenarios and operate in different operating environments- SE, SE-UM and Linux Kernel. Reference applications are classified into two categories:</p>
<ol type="1">
<li>Functional</li>
<li>Performance</li>
</ol>
<p><a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_funcapps_list">Functional Applications</a> showcase the functional aspect of HFA engine and SDK. These applications generally describes how to use HFA SDK in various environments like singl/multi core environment, Single/Multiple Graph usage, multiple operating environments, Stateless and Stateful Context etc.</p>
<p><a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_perfapps_list">Performance Benchmarking Applications</a> are designed to showcase the maximum capabilities of HFA Engine.</p>
<h1><a class="anchor" id="hfasdk_memreq"></a>
MEMORY REQUIREMENTS</h1>
<p>HFA APIs (internally) and applications need memory resources to execute on OCTEON HFA hardware. Memory requirements depends on various factors such as - type of OCTEON chip, number of clusters supported, size/type of graph and underlying OS. Provided reference examples in HFA-SDK uses FPA pools to increase performance. Any application can override the default allocation behaviour - FPA/other memory pool with DMA'able/non-DMA'able memory. Please refer to os_dependent <a href="cvm-hfa-osapi_8h.html#define-members" class="el">hfa_os_xxxalloc() / hfa_os_xxxfree()</a> macros. During HFA device initialization, various memory resources are allocated and assigned to HFA block. These memory resources are configurable at compile time and allow flexibility to change their allocation pool either from FPA and/or from heap/DMA memory. The application then allocates or frees its memory requirement from the memory pool assigned to HFA API during device initialization.</p>
<p>Here are the memory requirements for <b> HFA SDK APIs </b>:</p>
<ol type="1">
<li><b>OCTEON_HFAPOOL</b> (pool with DMA'able Memory): This pool is used for HFA command buffer from where all OCTEON HFA hardware instructions are allocated.</li>
<li><b>OCTEON_PPBUFPOOL</b> (pool with non-DMA'able Memory): This FPA pool is used by preprocessor libraries to store match results.</li>
<li><b>OCTEON_TBUFPOOL</b> (pool with non-DMA'able Memory): This pool is used to allocate temporary buffers required internal book-keeping in the HFA APIs.</li>
<li><b>OCTEON_HFA_MEMORY:</b> HFA SDK requires memory and cache portion on HFA device to load OCTEON HFA graph. Cache portion of OCTEON HFA graph is loaded on HFA cluster cache. If <a class="el" href="overview.html#hfasdk_targets">OCTEON HFA TARGETS</a> has designated HFA memory (<b>cn63xx/</b> <b>cn66xx</b>), memory portion of OCTEON HFA graph is loaded on HFA designated memory otherwise, Application needs to reserve DMA'able memory (DRAM) on remaining OCTEON HFA TARGETS (<b>cn60xx</b>, <b>cn61xx</b>, <b>cn68xx</b>, <b>cn70xx</b> and <b>cn71xx</b>) for downloading memory portion of OCTEON HFA graph. This memory is referred as <b>OCTEON_HFA_MEMORY</b>. See <b>Note</b> to configure <b>OCTEON_HFA_MEMORY_SIZE</b>.</li>
<li><b>OCTEON_HFA_ARENA_SIZE</b> (pool with DMA'able Memory): This memory arena is required to get variable size memory buffers during graph memory/cache download. This memory is allocated in <b>non-kernel</b> environment only.</li>
</ol>
<p><b>Note:</b> </p>
<ul>
<li>It is required that all memory resources interacting with HFA hardware must be physical address(i.e. DMA'able addresses). Typically such memory resources must come from FPA pool.</li>
<li>Default configuration for various memory pools are:<ul>
<li><b>OCTEON_HFA_MEMORY_SIZE</b> is configured from bootmem memory. Default Size <b>128</b> MB</li>
<li><b>OCTEON_HFAPOOL</b> is configured as FPA <b>Pool-4</b> with <b>60000</b> buffers. Default size of each buffer <b>2*CVMX_CACHE_LINES</b> </li>
<li><b>OCTEON_PPBUFPOOL</b> <b>share</b> memory resources with OCTEON_HFAPOOL. The default behavior can be override by configuring separate memory pool. <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9" title="This function must be called by application to initialize HFA engine and setup resources for HFA hard...">hfa_dev_init()</a> will take care of allocating separate FPA pools for PPBUFFERS and HFA command buffers.</li>
<li><b>OCTEON_TBUFPOOL</b> is configured as FPA <b>Pool-5</b> having <b>60000</b> buffers. Default size of each buffer <b>3*CVMX_CACHE_LINES</b> </li>
<li><b>OCTEON_HFA_ARENA_SIZE</b> is allocated from bootmem. Default size <b>100</b> MB</li>
</ul>
</li>
<li>All above mentioned memory is configured by <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9">hfa_dev_init()</a> function</li>
<li>For non-kernel environments, default configuration can be overridden by changing config file $HFAROOT/drv/include/config/octeon-hfa-drv-config.h</li>
<li>For kernel environment, default configuration can be overridden by changing macro definitions at $HFAROOT/drv/include/cvm-hfa-module.h</li>
<li>Here are the source of memory for different allocators used in HFA SDK<ul>
<li><a class="el" href="cvm-hfa-osapi_8h.html#a0f781a4858026cf4f7500525fb12e51f">hfa_os_malloc</a> : OCTEON_TBUFPOOL FPA Pool</li>
<li><a class="el" href="cvm-hfa-osapi_8h.html#a27db40463ca737bb4cbaa44067d5696c">hfa_os_memoryalloc</a> : OCTEON_HFA_ARENA for non-kernel environment and __get_free_pages() for KERNEL mode</li>
<li><a class="el" href="cvm-hfa-osapi_8h.html#a1aaa240fc073c73a4848dd72ba579f72">hfa_os_infoalloc</a> : OCTEON_HFA_ARENA for non-kernel environment and vmalloc() in KERNEL environment</li>
</ul>
</li>
</ul>
<p>Here are the memory requirements of <b> HFA SDK Reference Applications </b>:</p>
<p>Following FPA pools are configured/allocated by HFA SDK applications as an when they are needed. These FPA pool allocations depends on the requirement of applications and in some cases may not be needed. These pools are:</p>
<ol type="1">
<li><b>CVMX_FPA_WQE_POOL</b> is configured in following cases:<ul>
<li>When input payload is WQE based packets</li>
<li>When HFA search submit instruction has WQE ptr set.</li>
</ul>
</li>
<li><b>OCTEON_IBUFPOOL</b> is configured in following cases:<ul>
<li>When input payload is WQE based packets</li>
</ul>
</li>
<li><b>OCTEON_SPARAM_FPA_POOL</b> is configured in following cases:<ul>
<li>When performance apps uses fpa pool for allocating search parameters</li>
</ul>
</li>
<li><b>OCTEON_RPTR_FPA_POOL</b> is configured in following cases:<ul>
<li>When performance apps uses fpa pool for allocating search result buffer</li>
</ul>
</li>
</ol>
<p><b>Note:</b> </p>
<ul>
<li><b>CVMX_FPA_WQE_POOL</b> is configured as <b>FPA</b> Pool -1 having <b>60000</b> buffers. Default size of each buffer is <b>1*</b> CVMX_CACHE_LINES. In case of LINUX with module inserted ethernet driver, the allocation is overriden by OCTEON ethernet driver</li>
<li><b>OCTEON_IBUFPOOL</b> is configured as <b>FPA</b> Pool -0 having <b>60000</b> buffers Default size of each buffer is <b>12*</b> CVMX_CACHE_LINES. In case of LINUX with module inserted ethernet driver, the allocation is <b>overriden</b> by OCTEON ethernet driver</li>
</ul>
<h1><a class="anchor" id="hfasdk_execution"></a>
EXECUTION</h1>
<p>Please go through this section to understand the sequence of running HFA reference applications in each operating environment </p>
<h2><a class="anchor" id="hfasdk_graph"></a>
a. GENERATE OCTEON HFA GRAPH</h2>
<p>OCTEON HFA hardware requires Cavium specific <b>HFA</b> <b>graph</b> to be loaded on OCTEON HFA cache and memory portion in order to search matches in the payload. HFA graph is generated by compiling user-specific pattern file using <a class="el" href="octeon_hfa_tools.html#hfa_compiler">HFA RegEx Complier</a>. A sample pattern and payload file is provided with HFA SDK at location HFAROOT/apps/ref-files. The following is a simple way of creating HFA graph. <b>hfa.out</b> is the default file name of the generated HFA graph </p>
<pre class="fragment">    $ hfac -input=&lt;patternfile&gt; -target=&lt;OCTEON HFA TARGET&gt; [-options]
</pre><p> <a class="el" href="octeon_hfa_tools.html#hfa_compiler">HFA RegEx Complier</a> is PCRE compatible with few exceptions. Refer to <a class="el" href="octeon_hfa_syntax.html">OCTEON HFA COMPILER PATTERN SYNTAX</a> for HFA RegEx compiler syntax. Typically HFA graph contains three portions: Cache portion (GIST), Memory portion and Info portion. In memonly graph, cache portion is absent hence such graph contains only two portions. Following is the mapping of Instruction types to graph portion and the responsible entity </p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">HFA Graph Portion</td><td id="MiddleColumn">Responsible Entity</td><td id="MiddleColumn">Where the portion is loaded</td><td id="LastColumn">HFA Instructions involved </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">Graph Cache</td><td id="MiddleColumn">OCTEON HFA Block</td><td id="MiddleColumn">HFA Cluster Cache</td><td id="LastColumn">GRAPH CLOAD, GRAPHFREE </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">Graph Memory</td><td id="MiddleColumn">OCTEON HFA Block</td><td id="MiddleColumn">HFA Cluster Memory or System DDR</td><td id="LastColumn">GRAPH MLOAD </td></tr>
<tr id="LastRow">
<td id="FirstColumn">Graph Info</td><td id="MiddleColumn">Post Processing Library (HFA SDK)</td><td id="MiddleColumn">System DDR</td><td id="LastColumn">NA </td></tr>
</table>
<p><b>Note:</b> </p>
<ul>
<li>Sample pattern and payload files are placed at location $HFAROOT/apps/ref-files/</li>
<li>Refer <a class="el" href="overview.html#hfasdk_targets">OCTEON HFA TARGETS</a> to know about valid arguments for -target options</li>
</ul>
<h2><a class="anchor" id="hfasdk_running_apps"></a>
b. RUN REFERENCE APPLICATIONS</h2>
<p>OCTEON HFA SDK provides several <a class="el" href="octeon_hfa_sdk_apps.html">REFERENCE APPLICATIONS</a> in each of the <a class="el" href="overview.html#hfasdk_operatingenv">OPERATING ENVIRONMENTS</a>. Depending upon the supported operating environmentsm choose appropriate link:</p>
<ol type="1">
<li><a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_apps_launch_se">Run SE Reference Applications</a></li>
<li><a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_apps_launch_seum">Run SEUM Reference Applications</a></li>
<li><a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_apps_launch_kernel">Run LINUX Kernel Reference Applications</a></li>
</ol>
<h1><a class="anchor" id="hfasdk_design"></a>
DESIGN</h1>
<p>OCTEON HFA SDK is designed to allow flexibility and modularity to applications both at low-level and at higher level. <a class="el" href="octeon_hfa_sdk_library.html#hfail_api">HFA Instruction-Level API</a> interacts at low-level with HFA hardware and <a class="el" href="octeon_hfa_sdk_library.html#hfaoo_api">HFA Object-Oriented API</a> works at higher level and uses <a class="el" href="octeon_hfa_sdk_library.html#hfail_api">HFA Instruction-Level API</a> to interact with HFA harsware. This section will majorly discuss about <a class="el" href="octeon_hfa_sdk_library.html#hfaoo_api">HFA Object-Oriented API</a>.</p>
<p><a class="el" href="octeon_hfa_sdk_library.html#hfaoo_api">HFA Object-Oriented API</a> allows application to visualize various entities like OCTEON HFA Block, OCTEON HFA Cluster, OCTEON HFA Graph etc as objects. Object oriented APIs interface revolves around these objects. Member function for each object provides clean interface to managet. Following are the major objects defined in this SDK.</p>
<h2><a class="anchor" id="hfasdk_design_dev"></a>
a. HFA Device Object</h2>
<p>This single global object (<a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a>) holds underlying HFA Device information and Cluster resources. <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9">hfa_dev_init()</a>/ <a class="el" href="cvm-hfa_8c.html#af14bebdd444bd0bf92faac9d5d88b492">hfa_dev_cleanup()</a> are used to initialize and cleanup the object. Following are the interface defined for <a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a> object.</p>
<ul>
<li>Device Initialization (<a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9">hfa_dev_init</a>)</li>
<li>Device Get DevInfo (<a class="el" href="cvm-hfa_8c.html#a27982497398da2118cd5287ed51732e7">hfa_dev_getdevinfo</a>)</li>
<li>Device Cleanup (<a class="el" href="cvm-hfa_8c.html#af14bebdd444bd0bf92faac9d5d88b492">hfa_dev_cleanup</a>)</li>
</ul>
<p><b>Things to remember</b></p>
<ul>
<li>Application needs to ensure that enough memory (FPA and bootmem) is available in the system befor calling <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9">hfa_dev_init</a></li>
<li>Application must use proper locking before accessing <a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a> single global object.</li>
<li>See <a class="el" href="overview.html#hfasdk_memreq">MEMORY REQUIREMENTS</a> section for more detailss</li>
</ul>
<h2><a class="anchor" id="hfasdk_design_cluster"></a>
b. HFA Cluster Object</h2>
<p>Depending upon the <a class="el" href="overview.html#hfasdk_targets">OCTEON HFA TARGETS</a> <a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a> may contain one or more cluster objects(<a class="el" href="cvm-hfa-cluster_8h.html#a5562d430baf405052248d5deb9aa8300">hfa_cluster_t</a>). This object is a part of <a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a> object and must be visualized as a single HFA cluster. So in case of cn68xx number of such object in system will be 3.</p>
<p>This object holds all HFA cache and HFA memory pool information. This memory and cache memory pool is the region where all HFA graphs are loaded on HFA cluster.</p>
<p>Following are the interface defined for <a class="el" href="cvm-hfa-cluster_8h.html#a5562d430baf405052248d5deb9aa8300">hfa_cluster_t</a> object</p>
<ul>
<li>Cluster Initialization (<a class="el" href="cvm-hfa-cluster_8c.html#aa0d1e40097e956ad06c9f7c454f77b80">hfa_cluster_init</a>)</li>
<li>Getting a pointer to this structure (using cluster no) (<a class="el" href="cvm-hfa-cluster_8c.html#ad8cad96579f5a310b62caaf8c166658f">hfa_get_cluster</a>)</li>
<li>Setting or Assigning pre-allocated memory pool to Cluster (<a class="el" href="cvm-hfa-cluster_8c.html#ad3dc54e450e08d6bf010a81b1eb11f15">hfa_cluster_setmem</a>)</li>
<li>Resetting or Cleanup the Cluster memory pool (<a class="el" href="cvm-hfa-cluster_8c.html#a5eb9ad880a56c9e7af7891cb994ae9db">hfa_cluster_cleanupmem</a>)</li>
<li>Setting or Assigning pre-allocated cache pool to Cluster (Implicitly done) (<a class="el" href="cvm-hfa-cluster_8c.html#ae7f77575030285c474e1ee2669171a3c">hfa_cluster_setcache</a>)</li>
<li>Resetting or Cleanup the Cluster cache pool (Implicitly done) (<a class="el" href="cvm-hfa-cluster_8c.html#a6c30dec281084f6e40bf9d98356418bd">hfa_cluster_cleanupcache</a>)</li>
<li>Sharing the memory resources with other clusters (<a class="el" href="cvm-hfa-cluster_8c.html#af2466b1e67058e962fac92ac1d93f716">hfa_cluster_share_mem</a>)</li>
</ul>
<p><b>Things to Remember </b></p>
<ul>
<li>Clusters initialization and Clusters cleanup are implicitly called by <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9" title="This function must be called by application to initialize HFA engine and setup resources for HFA hard...">hfa_dev_init()</a>/ <a class="el" href="cvm-hfa_8c.html#af14bebdd444bd0bf92faac9d5d88b492" title="This function is called by application to cleanup all resources configured for HFA device and then sh...">hfa_dev_cleanup()</a> functions respectively.</li>
<li>Default behaviour can be overrided and application can take over the responsibility of any cluster. In that case application will be responsible for cleaning up the cluster resources. See reference application <a class="el" href="hfa-se-async_8c.html">hfa-se-async.c</a></li>
<li>Application must use locking before accessing this objects.</li>
<li><a class="el" href="cvm-hfa-cluster_8h.html#a5562d430baf405052248d5deb9aa8300">hfa_cluster_t</a> is part of <a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a> hence application don't need to save these objects pointer. Use <a class="el" href="cvm-hfa-cluster_8c.html#ad8cad96579f5a310b62caaf8c166658f">hfa_get_cluster()</a> to get cluster pointer from <a class="el" href="cvm-hfa_8h.html#a6fdb03101e2e545c90ed4b769027b390">hfa_dev_t</a></li>
<li>Cluster can share resources among each other (<a class="el" href="cvm-hfa-cluster_8c.html#af2466b1e67058e962fac92ac1d93f716">hfa_cluster_share_mem()</a>) and can also setup their resources (<a class="el" href="cvm-hfa-cluster_8c.html#ad3dc54e450e08d6bf010a81b1eb11f15">hfa_cluster_setmem()</a>). In former case cluster memory resources are allocated once and shared by other clusters. However in later case cluster memory resources are independent.</li>
<li>For all OCTEON HFA TARGET (except cn63xx and cn66xx), <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9" title="This function must be called by application to initialize HFA engine and setup resources for HFA hard...">hfa_dev_init()</a> setup cluster memory resources as follows<ul>
<li>Find Named Block (<a class="el" href="cvm-hfa-module_8c.html#a75e8edebfd59fbf5d030548bc2737e11">hfa_mem_nb_name</a>)<ul>
<li>If found, set <b>OCTEON_HFA_MEMORY_SIZE</b> == Named block size</li>
<li>If not found, allocate and create <a class="el" href="cvm-hfa-module_8c.html#a75e8edebfd59fbf5d030548bc2737e11">hfa_mem_nb_name</a> of size <b>OCTEON_HFA_MEMORY_SIZE</b> </li>
</ul>
</li>
<li>Set up memory resources (<a class="el" href="cvm-hfa-cluster_8c.html#ad3dc54e450e08d6bf010a81b1eb11f15">hfa_cluster_setmem()</a>) of Cluster 0 with Named block ptr.</li>
<li>If more than 1 clusters present, share memory resources (<a class="el" href="cvm-hfa-cluster_8c.html#af2466b1e67058e962fac92ac1d93f716">hfa_cluster_share_mem()</a>) of Cluster 0 with all remaining clusters</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="hfasdk_design_graph"></a>
c. HFA Graph Object</h2>
<p>The Graph object (<a class="el" href="structhfa__graph__t.html">hfa_graph_t</a>) represents OCTEON HFA graph and holds all information that are needed to manage a graph.</p>
<p>Following are the interface defined for <a class="el" href="structhfa__graph__t.html">hfa_graph_t</a> object</p>
<ul>
<li>Graph Initialization (<a class="el" href="cvm-hfa-graph_8c.html#a80a6427d5a90c7bd1e4cbfd62a808524">hfa_dev_graph_init</a>)</li>
<li>Setting the Cluster Mask on which Graph has to be downloaded (<a class="el" href="cvm-hfa-graph_8c.html#a32df4a93ffcd7da232613b13204b2a80">hfa_graph_setcluster</a>)</li>
<li>Synchronous download of memory portion of Graph (GRAPH MLOAD) (<a class="el" href="cvm-hfa-graph_8c.html#a9e3f1a4bf2be683265108b5131541e89">hfa_graph_memload_data</a>)</li>
<li>Asynchronous download of memory portion of Graph (GRAPH MLOAD) (<a class="el" href="cvm-hfa-graph_8c.html#a647ccf649077cb5170221218ab2cdccf">hfa_graph_memload_data_async</a>)</li>
<li>Performing GRAPH CLOAD instruction after completion of GRAPH MLOAD instruction (<a class="el" href="cvm-hfa-graph_8c.html#a60861d15ed5f6bccc42bbde834aa2b32">hfa_graph_cacheload</a>)/ <a class="el" href="cvm-hfa-graph_8c.html#aa296e0c6b36b3d5b4f8e01c2fe765bed">hfa_graph_cacheload_async</a>)</li>
<li>Performing GRAPH FREE (cache_unload) instruction on already loaded graph (<a class="el" href="cvm-hfa-graph_8c.html#aa4ce7845277b4b3099159bbd7afd5c08">hfa_graph_cacheunload</a>/ <a class="el" href="cvm-hfa-graph_8c.html#afb63ce4f42afc7987e6222b1c1ea91a1">hfa_graph_cacheunload_async</a>)</li>
<li>Fetching the status for previously submitted Graph instruction (<a class="el" href="cvm-hfa-graph_8c.html#a0f2f13fb51e5d56dcf049ff3c7c6ad78">hfa_graph_getstatus</a>)</li>
<li>Processing recevied WQE from HFA hardware for GRAPH MLOAD, GRAPH CLOAD and GRAPH FREE instruction (<a class="el" href="cvm-hfa-graph_8c.html#afe0db52c8adafa604a265e0fc878a4f6">hfa_graph_processwork</a>)</li>
<li>Querying number of graphs present in Linked graph object (<a class="el" href="cvm-hfa-graph_8c.html#a1ae8787b6687f837ccfb7aebdab80f56">hfa_graph_getgraph_count</a>)(Linked graphs are created using <a class="el" href="octeon_hfa_tools.html#hfa_linker">HFA Graph Linker</a>)</li>
<li>Creating new sub-graph object from a Linked graph object (<a class="el" href="cvm-hfa-graph_8c.html#a44cb6a05b551fe7bc3090c1ba4ee9d8b">hfa_graph_getsubgraph</a>)</li>
</ul>
<p><b> Things to Remember </b></p>
<ul>
<li>Application needs to keep track or save <a class="el" href="structhfa__graph__t.html" title="Graph structure.">hfa_graph_t</a> objects.</li>
<li>Graph Download (GRAPH MLOAD) is allowed only after<ul>
<li><a class="el" href="cvm-hfa-graph_8c.html#a80a6427d5a90c7bd1e4cbfd62a808524">hfa_dev_graph_init()</a></li>
<li><a class="el" href="cvm-hfa-graph_8c.html#a32df4a93ffcd7da232613b13204b2a80">hfa_graph_setcluster</a></li>
</ul>
</li>
<li>Graph Cache Load (GRAPH CLOAD) is allowed only when<ul>
<li>Graph is completely downloaded (GRAPH MLOAD)</li>
</ul>
</li>
<li>Search on Graph (GRAPH WALK) is allowed only when<ul>
<li>Graph is completely cacheloaded on searched cluster (GRAPH CLOAD)</li>
</ul>
</li>
<li>Graph Cache Unload (GRAPH FREE)<ul>
<li>is allowed only when <a class="el" href="structhfa__graph__t.html">hfa_graph_t</a> is cache loaded i.e GRAPH CLOAD completed</li>
<li>should happen when there is no pending instruction: GRAPH MLOAD, GRAPH CLOAD, GRAPH FREE and GRAPH WALK on <a class="el" href="structhfa__graph__t.html">hfa_graph_t</a></li>
</ul>
</li>
<li>Application should not take locking as all graph APIs are lock safe.</li>
<li>Linked graph (generated by <a class="el" href="octeon_hfa_tools.html#hfa_linker">HFA Graph Linker</a>) and normal graph are represented by same data strucuture (<a class="el" href="structhfa__graph__t.html">hfa_graph_t</a>). See <a class="el" href="hfa-se-linkgraph_8c.html">hfa-se-linkgraph.c</a> application for Linked graph</li>
</ul>
<h2><a class="anchor" id="hfasdk_design_sctx"></a>
d. HFA Search Context Object</h2>
<p>Search Context (<a class="el" href="structhfa__searchctx.html">hfa_searchctx</a>) represents snapshot of hardware and software state of a search. It mainly holds the hardware and software (PP) structures (<a class="el" href="structhfa__savedsearchctx.html">hfa_savedsearchctx</a>) of a search. Both hardware and PP state (<a class="el" href="structppstate__t.html">ppstate_t</a>) are needed by respective entity to relate matches found in current payload buffer with previously submitted (if any) payload buffer.(See <a class="el" href="overview.html#hfasdk_pp_crosssearch">e. CROSSPACKET SEARCH</a> for more details).</p>
<p>Following are the interface defined for <a class="el" href="structhfa__graph__t.html">hfa_graph_t</a> object</p>
<ul>
<li>Search Context Initialization (<a class="el" href="cvm-hfa-search_8c.html#a64ba7a41c7d677da10e588a58789015b">hfa_dev_searchctx_init</a>)</li>
<li>Initializing <a class="el" href="structhfa__graph__t.html">hfa_graph_t</a> object to Search Context (<a class="el" href="cvm-hfa-search_8c.html#a954753c0e6f4a59599d05f1262a25b38">hfa_searchctx_setgraph</a>)</li>
<li>Overriding default seach flags (<a class="el" href="cvm-hfa-search_8c.html#a60c8025118f6a47f924733e47db8c77d">hfa_searchctx_setflags</a>)</li>
<li>Synchronous Search submit (GRAPH GWALK) (<a class="el" href="cvm-hfa-search_8c.html#a57d7540278164eb6b6c132be00db0de5">hfa_searchctx_search</a>)</li>
<li>Asynchronous Search submit (GRAPH GWALK) (<a class="el" href="cvm-hfa-search_8c.html#a0c36da280b39bd8afdf6081baea24472">hfa_searchctx_search_async</a>)</li>
<li>Querying the Search Instruction status from hardware (<a class="el" href="cvm-hfa-search_8c.html#a6a8e1d7e70e0a10520302df5651e5fc5">hfa_searchctx_get_searchstatus</a> )</li>
<li>Processing recevied WQE from HFA hardware for GRAPH GWALK instruction (<a class="el" href="cvm-hfa-search_8c.html#a4e3a1a826235d80899e23fb44c69eb0f">hfa_searchctx_processwork</a>)</li>
<li>Sending the Hardware result to Software (PP) and then getting matches from PP (<a class="el" href="cvm-hfa-search_8c.html#a6dbb15dc58155b2c94b19784ad42ef89">hfa_searchctx_getmatches</a>)</li>
</ul>
<p><b>Things to Remember</b></p>
<ul>
<li>Search on a <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a> is allowed only when<ul>
<li>Search Context is initialized</li>
<li>Successfully cacheloaded <a class="el" href="structhfa__graph__t.html">hfa_graph_t</a> is initialized to <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a></li>
<li><b>Optional</b> , Overridding Default Search flags (using <a class="el" href="cvm-hfa-search_8c.html#a60c8025118f6a47f924733e47db8c77d">hfa_searchctx_setflags()</a>).</li>
</ul>
</li>
</ul>
<ul>
<li>By default <a class="el" href="overview.html#hfasdk_pp_crosssearch">e. CROSSPACKET SEARCH</a> is enabled, <a class="el" href="overview.html#hfasdk_pp_singlematch">d. SINGLEMATCH SEARCH</a> is disabled and <a class="el" href="overview.html#hfasdk_pp_ctx_stats">g. PP STATISTICS</a> is disabled.</li>
<li>Number of <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a> in a system depends on its requirements. Application can create <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a> for each Layer 4 port or may create only one on each core. Reference application <a class="el" href="hfa-se-ctx_8c.html">hfa-se-ctx.c</a> creates only one Search Context per core however <a class="el" href="hfa-se-flow_8c.html">hfa-se-flow.c</a> and <a class="el" href="hfa-se-flow-wqe_8c.html">hfa-se-flow-wqe.c</a> creates Search Context for each WQE Tag Value (which depends on Five Tuple field of network packet)</li>
<li>Application needs to keep track or save all <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a> objects</li>
<li>If possibility of contention, application must use proper locking on each Search Context object</li>
<li>Design application such that minimal or no locking is required on <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a>. In multi-core environment, it is better to use separate <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a> on each core. (<a class="el" href="hfa-se-ctx_8c.html">hfa-se-ctx.c</a>)</li>
</ul>
<h2><a class="anchor" id="hfasdk_design_sparam"></a>
e. HFA Search Parameters Object</h2>
<p>Search parameter or <a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> object holds required fields that are needed for single search. This object should be allocated for each GRAPH GWALK or Search instruction submit. Main fields that this object holds are:</p>
<ul>
<li>WQE: Required if WQE mode supported for GRAPH WALK instruction. Polling mode does not require this field (<a class="el" href="cvm-hfa-search_8h.html#aedf4239a435fd4722c404dacccdef6b6">hfa_searchparam_set_wqe</a>)</li>
<li>Clusterno: Cluster on which current has to be submitted. (Pre-requisities: Graph (in <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a>) must be loaded on provided cluster)</li>
<li>Pointer to current Payload Buffer (<a class="el" href="cvm-hfa-search_8h.html#a3c407460808f038770473ffc6e4b5c38">hfa_searchparam_set_inputiovec</a>)</li>
<li>If required, <a class="el" href="overview.html#hfasdk_pp_fsavebuf">f. FSAVEBUF FLAG</a>, pointer to previously submitted payload buffer. (<a class="el" href="cvm-hfa-search_8h.html#ae9741e867075c9b8cc63a7d889d5bf20">hfa_searchparam_set_inputiovec_0_n</a>)</li>
<li>Pointer to Result buffer where HFA hardware should write results (<a class="el" href="cvm-hfa-search_8h.html#a12882fa53f8ec49b9b2950711161db42">hfa_searchparam_set_output</a>)</li>
<li>Application matchcb, if set, PP will call mathcb(cbarg) function instead of saving matches in a buffer. (<a class="el" href="cvm-hfa-search_8h.html#a0210e636ef06f718be0e67753bebaa04">hfa_searchparam_set_matchcb</a>)</li>
<li>Match Callback Argument, if matchcb mode set.</li>
</ul>
<p><b> Things to remember</b></p>
<ul>
<li><a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> and all its fields must be separately allocated for each search submit.</li>
<li>All allocations done for initializing <a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> like WQE, Result buffer, Payload buffer must be freed only after completion of GRAPH GWALK instruction i.e when reason code from <a class="el" href="cvm-hfa-search_8c.html#a6a8e1d7e70e0a10520302df5651e5fc5">hfa_searchctx_get_searchstatus</a> is not <a class="el" href="cvm-hfa-search_8h.html#a1f4c5713f53c1d524ac60e8fe6cceac6ad343dbfd86e3dc01695e9bb64e23e103">HFA_SEARCH_SEAGAIN</a>.</li>
<li>In case of multi-core environment, single core must be the owner of this object otherwise proper locking to be applied by application</li>
<li><a class="el" href="structhfa__search__hwpp__ofields__t.html">hfa_search_hwpp_ofields_t</a> in <a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> is for application to know following<ul>
<li><a class="el" href="cvm-hfa-common_8h.html#ace114785181b3c8008324487b6b38017">hfa_reason_t</a> : Reason set by hardware. Should be called after completing GRAPH GWALK instruction i.e when reason code from <a class="el" href="cvm-hfa-search_8c.html#a6a8e1d7e70e0a10520302df5651e5fc5">hfa_searchctx_get_searchstatus()</a> is not <a class="el" href="cvm-hfa-search_8h.html#a1f4c5713f53c1d524ac60e8fe6cceac6ad343dbfd86e3dc01695e9bb64e23e103">HFA_SEARCH_SEAGAIN</a></li>
<li><a class="el" href="cvm-hfa-common_8h.html#a12ea4dd0eca13bd21e0df0c501d76bd3">hfa_pdboff_t</a> : Set by hardware, which means how much packet data byte has been scanned before writing matches to result buffer. In case of <a class="el" href="cvm-hfa-instr_8h.html#a5b3f315b07062868d709bd76fab1947aa1d3e0ec86efc1d51a212f901fa70f54f">HFA_REASON_DDONE</a>, pdboffset should be equal to provided payload buffer for the search, but in some cases like <a class="el" href="cvm-hfa-instr_8h.html#a5b3f315b07062868d709bd76fab1947aa65e042fddc98054d59913d28d903c701">HFA_REASON_RFULL</a>, <a class="el" href="cvm-hfa-instr_8h.html#a5b3f315b07062868d709bd76fab1947aab6e49fc0e6ac324d9d06ef365e81c428">HFA_REASON_TERM</a> pdboffset can be lesser than payload buffer. Other reasons like <a class="el" href="cvm-hfa-instr_8h.html#a5b3f315b07062868d709bd76fab1947aa819575bdc4a82ba7b641f6b755b308b6">HFA_REASON_ERR</a>, <a class="el" href="cvm-hfa-instr_8h.html#a5b3f315b07062868d709bd76fab1947aa93164060b8f6da3e451e9089d8f219fb">HFA_REASON_NOGRAPH</a> and <a class="el" href="cvm-hfa-instr_8h.html#a5b3f315b07062868d709bd76fab1947aad17950ce864ad1f3847646acca478b74">HFA_REASON_GERR</a> means search failure from hardware hence last search submit should be aborted. This field should be checked after completion of GRAPH GWALK instruction (<a class="el" href="hfa-se_8c.html">hfa-se.c</a>)</li>
<li><a class="el" href="cvm-hfa-common_8h.html#a7817614b429a17fa0d6538b2c1a8caae">hfa_ppoflags_t</a> : Flags set by PP(). This field should be checked after calling after <a class="el" href="cvm-hfa-search_8c.html#a6dbb15dc58155b2c94b19784ad42ef89">hfa_searchctx_getmatches()</a>. See <a class="el" href="overview.html#hfasdk_pp_fsavebuf">f. FSAVEBUF FLAG</a> for more details. Reference application <a class="el" href="hfa-se_8c.html">hfa-se.c</a> calls <a class="el" href="cvm-hfa-search_8h.html#ac5bcfbfda7036d9aca28a3c5828847a5">hfa_searchparam_get_ppoflags()</a> to query this field and use it further.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="hfasdk_hfaop"></a>
THEORY OF OPERATION</h1>
<h2><a class="anchor" id="hfasdk_hfaop_init"></a>
a. OCTEON HFA Hardware Initialization</h2>
<p>OCTEON software needs to initialize HFA hardware block, HFA command queue and reserving HFA APIs memory requirement. HFA command queue is required to submit HFA instruction to HFA hardware. OCTEON software can perform these tasks by calling single API <a class="el" href="cvm-hfa_8c.html#a873768042b716d60996ec5d858fc8fd9">hfa_dev_init</a>. Please refer to OCTEON HFA HRM to understand Theory of HFA operation in detail.</p>
<h2><a class="anchor" id="hfasdk_hfaop_submitinstr"></a>
b. Submitting HFA Instruction</h2>
<p>Any cnMIPS core can write an HFA instruction to the HFA instruction queue in system memory. Whenever a HFA thread engine is ready to process the instruction, the instruction command is dispatched to HTE for further processing. In case of HFA GRAPH WALK instruction OCTEON HFA also supports <a class="el" href="overview.html#hfasdk_misc_loadbalance">a. CLUSTER LOAD BALANCING</a></p>
<h2><a class="anchor" id="hfasdk_hfaop_submitresponse"></a>
c. Response of Submitted HFA Instructions</h2>
<p>There are two modes in which OCTEON software can get the response of previously submitted HFA instructions: Polling mode and WQE mode.</p>
<p>OCTEON HFA SDK recommends usage of polling mode for HFA instructions: GRAPH MLOAD, GRAPH CLOAD and GRAPH FREE. All HFA-SDK reference application uses polling mode for these HFA instructions.</p>
<p>Depending upon the OCTEON software design one of the two mode can be used for GRAPH WALK instructions. Reference applications (<a class="el" href="hfa-se-ctx_8c.html">hfa-se-ctx.c</a>. <a class="el" href="hfa-se-flow_8c.html">hfa-se-flow.c</a>) uses polling mode and <a class="el" href="hfa-se-flow-wqe_8c.html">hfa-se-flow-wqe.c</a> uses WQE mode for GRAPH WALK instruction </p>
<table  id="DoxyEmbeddedTable">
<tr id="HeadRow">
<td id="FirstColumn">HFA Instruction Type</td><td id="MiddleColumn">Instruction Submit Asynchronous APIs</td><td id="MiddleColumn">Instruction Submit Synchronous APIs</td><td id="MiddleColumn">MODE</td><td id="LastColumn">APIs to get Instruction Submit Response </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH MLOAD</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#a647ccf649077cb5170221218ab2cdccf">hfa_graph_memload_data_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#a9e3f1a4bf2be683265108b5131541e89">hfa_graph_memload_data()</a></td><td id="MiddleColumn">POLLING</td><td id="LastColumn"><a class="el" href="cvm-hfa-graph_8c.html#a0f2f13fb51e5d56dcf049ff3c7c6ad78">hfa_graph_getstatus()</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH CLOAD</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#aa296e0c6b36b3d5b4f8e01c2fe765bed">hfa_graph_cacheload_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#a60861d15ed5f6bccc42bbde834aa2b32">hfa_graph_cacheload()</a></td><td id="MiddleColumn">POLLING</td><td id="LastColumn"><a class="el" href="cvm-hfa-graph_8c.html#a0f2f13fb51e5d56dcf049ff3c7c6ad78">hfa_graph_getstatus()</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH WALK</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-search_8c.html#a0c36da280b39bd8afdf6081baea24472">hfa_searchctx_search_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-search_8c.html#a57d7540278164eb6b6c132be00db0de5">hfa_searchctx_search()</a></td><td id="MiddleColumn">POLLING</td><td id="LastColumn"><a class="el" href="cvm-hfa-search_8c.html#a6a8e1d7e70e0a10520302df5651e5fc5">hfa_searchctx_get_searchstatus()</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH FREE</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#afb63ce4f42afc7987e6222b1c1ea91a1">hfa_graph_cacheunload_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#aa4ce7845277b4b3099159bbd7afd5c08">hfa_graph_cacheunload()</a></td><td id="MiddleColumn">POLLING</td><td id="LastColumn"><a class="el" href="cvm-hfa-graph_8c.html#a0f2f13fb51e5d56dcf049ff3c7c6ad78">hfa_graph_getstatus()</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH MLOAD</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#a647ccf649077cb5170221218ab2cdccf">hfa_graph_memload_data_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#a9e3f1a4bf2be683265108b5131541e89">hfa_graph_memload_data()</a></td><td id="MiddleColumn">WQE</td><td id="LastColumn"><a class="el" href="cvm-hfa-graph_8c.html#afe0db52c8adafa604a265e0fc878a4f6">hfa_graph_processwork()</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH CLOAD</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#aa296e0c6b36b3d5b4f8e01c2fe765bed">hfa_graph_cacheload_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#a60861d15ed5f6bccc42bbde834aa2b32">hfa_graph_cacheload()</a></td><td id="MiddleColumn">WQE</td><td id="LastColumn"><a class="el" href="cvm-hfa-graph_8c.html#afe0db52c8adafa604a265e0fc878a4f6">hfa_graph_processwork()</a> </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">GRAPH WALK</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-search_8c.html#a0c36da280b39bd8afdf6081baea24472">hfa_searchctx_search_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-search_8c.html#a57d7540278164eb6b6c132be00db0de5">hfa_searchctx_search()</a></td><td id="MiddleColumn">WQE</td><td id="LastColumn"><a class="el" href="cvm-hfa-search_8c.html#a4e3a1a826235d80899e23fb44c69eb0f">hfa_searchctx_processwork()</a> </td></tr>
<tr id="LastRow">
<td id="FirstColumn">GRAPH FREE</td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#afb63ce4f42afc7987e6222b1c1ea91a1">hfa_graph_cacheunload_async()</a></td><td id="MiddleColumn"><a class="el" href="cvm-hfa-graph_8c.html#aa4ce7845277b4b3099159bbd7afd5c08">hfa_graph_cacheunload()</a></td><td id="MiddleColumn">WQE</td><td id="LastColumn"><a class="el" href="cvm-hfa-graph_8c.html#afe0db52c8adafa604a265e0fc878a4f6">hfa_graph_processwork()</a> </td></tr>
</table>
<h1><a class="anchor" id="hfasdk_pp"></a>
POST PROCESSING LIBRARY</h1>
<p>Post processing Library is a software library that comes along with OCTEON HFA SDK. Each HFA application has to link with this library placed at location $HFAROOT/lib/octeon/pp/$HFAENV. This location contains pp library for each operating environment.</p>
<h2><a class="anchor" id="hfasdk_pp_matchreport"></a>
a. HOW MATCHES ARE REPORTED</h2>
<p>PP library is needed to process results reported by HFA hardware. After processing HFA hardware results PP library reports matches, if any, to application. PP library is called by <a class="el" href="cvm-hfa-search_8c.html#a6dbb15dc58155b2c94b19784ad42ef89">hfa_searchctx_getmatches()</a>. PP library supports two modes for reporting matches to application:</p>
<ul>
<li><b>Matches in Result buffer</b> -&gt; In this case PP library will allocate a buffer and saves all matches into that buffer. Application needs to scan through buffer to get matches. <a class="el" href="app-utils_8c.html#a633038357891aa5147b77fe939f300bf">hfautils_print_matches()</a> is application specific function that scans through match buffer. All <a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_funcapps_list">Functional Applications</a> uses this mode</li>
<li><b>Match Callback</b> -&gt; For each match, pp will call application specific <a class="el" href="hfa-se-xml-parser_8c.html#a7a1a023f618d2721b68175551e1c6fe0">matchcb()</a> function. All <a class="el" href="octeon_hfa_sdk_apps.html#octeon_hfa_sdk_perfapps_list">Performance Benchmarking Applications</a> uses this mode for getting matches</li>
</ul>
<h2><a class="anchor" id="hfasdk_pp_manage"></a>
b. MANAGING PP RESOURCES</h2>
<p>This SDK allows application to control PP Library <b>Memory Resources</b> per <b>Search Context</b>. Application needs to specify a user specific argument to each Search Context. Application should use the following API to set user specific argument in <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a></p>
<ul>
<li><a class="el" href="cvm-hfa-search_8c.html#a3200f5303f0611887f35dd500e7a8d00">hfa_searchctx_setppuarg()</a></li>
</ul>
<p>This API should be called after <a class="el" href="cvm-hfa-search_8c.html#a954753c0e6f4a59599d05f1262a25b38">hfa_searchctx_setgraph()</a> API and before <a class="el" href="cvm-hfa-search_8c.html#a0c36da280b39bd8afdf6081baea24472">hfa_searchctx_search_async()</a>/ <a class="el" href="cvm-hfa-search_8c.html#a57d7540278164eb6b6c132be00db0de5">hfa_searchctx_search()</a>. If this API is not called by the application, default behavior will be applied. The user- argument can be any 64-bit value(except 0) and it will be supplied as an argument to the various memory allocator as part of pp library execution.</p>
<h2><a class="anchor" id="hfasdk_pp_allocators"></a>
c. PP MEMORY ALLOCATORS</h2>
<p><a class="el" href="overview.html#hfasdk_pp">POST PROCESSING LIBRARY</a> needs memory resources for various purposes. Following are the the memory allocation description and their corresponding API to control memory alloc, free and size.</p>
<ol type="1">
<li><p class="startli"><b>Partial Match Memory</b>: Allocate partial match state per ctx. PP allocates such memory using following function pointers that are initialized, by default, by HFA SDK :</p>
<ol type="a">
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#a885b670e37a647b4bf22c0a05c270cfb">hfa_os_ppbuf_alloc</a>)(uarg)</li>
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#aeba46a8483f3aa66e4d6b8d437a2c95b">hfa_os_ppbuf_free</a>)(uarg)</li>
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#a7ba8b9fad43376f12b8462d47bacca06">hfa_os_ppbuf_size</a>)(uarg)</li>
</ol>
<p class="startli">Its possible to overload the default implementions using following API:</p>
<ul>
<li>int <a class="el" href="cvm-hfa_8c.html#a236e64ca73680ea6761204d5c44d4e96">hfa_dev_set_fnp_ppalloc</a> (<a class="el" href="cvm-hfa-osapi_8h.html#a0da07d1a41261e047183f683992758cb">hfa_fnp_ppalloc_cb_t</a> alloc)</li>
<li>int <a class="el" href="cvm-hfa_8c.html#a148abbfdeebb207ff46884af8eeb8fa4">hfa_dev_set_fnp_ppfree</a> (<a class="el" href="cvm-hfa-osapi_8h.html#af04aed5ca25d60de56fd8cb40f4fc35a">hfa_fnp_ppfree_cb_t</a> free)</li>
<li>int <a class="el" href="cvm-hfa_8c.html#a774451b83b300f862763d189c9758e1f">hfa_dev_set_fnp_ppsize</a> (<a class="el" href="cvm-hfa-osapi_8h.html#ab74769f64f7685658eb8e10d3cd78ffc">hfa_fnp_ppsize_cb_t</a> bufsize)</li>
</ul>
<p class="startli">The overloaded (*hfa_os_ppbufsize)() API should always return a constant value which is a multiple of CVMX_CACHE_LINE. Default value is (2 * CVMX_CACHE_LINE)</p>
</li>
<li><p class="startli"><b>PP Runtime Memory</b>: Tempory buffer allocations by pp. PP allocates such memory using following function pointers that are initialized, by default, by HFA SDK</p>
<p class="startli">Default routines:</p>
<ol type="a">
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#ac3ee7daed027629106e7d1f6cfcb01ef">hfa_os_ppbuf_talloc</a>)(uarg)</li>
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#acbf3ca5f767af3bc591e915ea000560f">hfa_os_ppbuf_tfree</a>)(uarg)</li>
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#a8956ce4e3c39d882f903ceb4fb160296">hfa_os_ppbuf_tsize</a>)(uarg)</li>
</ol>
<p class="startli">Its possible to overload the default implementions using following API:</p>
<ul>
<li>int <a class="el" href="cvm-hfa_8c.html#a9a0b038e0d29435cb91a21d9c62806cc">hfa_dev_set_fnp_pptalloc</a> (<a class="el" href="cvm-hfa-osapi_8h.html#a0da07d1a41261e047183f683992758cb">hfa_fnp_ppalloc_cb_t</a> alloc)</li>
<li>int <a class="el" href="cvm-hfa_8c.html#a2cbca63c413f08d3861f9b4c2855391f">hfa_dev_set_fnp_pptfree</a> (<a class="el" href="cvm-hfa-osapi_8h.html#af04aed5ca25d60de56fd8cb40f4fc35a">hfa_fnp_ppfree_cb_t</a> free)</li>
<li>int <a class="el" href="cvm-hfa_8c.html#af0b17e8a09b1f7a1dd438ddcb1e4cd14">hfa_dev_set_fnp_pptsize</a> (<a class="el" href="cvm-hfa-osapi_8h.html#ab74769f64f7685658eb8e10d3cd78ffc">hfa_fnp_ppsize_cb_t</a> bufsize)</li>
</ul>
<p class="startli">The overloaded <a class="el" href="cvm-hfa-osapi_8h.html#a8956ce4e3c39d882f903ceb4fb160296">hfa_os_ppbuf_tsize()</a> API should always return a constant value which is a multiple of CVMX_CACHE_LINE. Default value is (2 * CVMX_CACHE_LINE)</p>
</li>
<li><p class="startli"><b>Match Result Memory</b>: Stored match results (used only when matchcb not used). PP allocates such memory using following function pointers that are initialized, by default, by HFA SDK.</p>
<ol type="a">
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#ad77dc5c82013f3dcdb2cc96ceae8435c">hfa_os_ppbuf_matchalloc</a>)(uarg)</li>
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#ad7236a1c5d950ab7a70e05e8032f8685">hfa_os_ppbuf_matchfree</a>)(uarg)</li>
<li>(* <a class="el" href="cvm-hfa-osapi_8h.html#a3f0562ada66f68262361772ff34cd820">hfa_os_ppbuf_matchsize</a>)(uarg)</li>
</ol>
<p class="startli">Its possible to overload the default implementions using following API:</p>
<ul>
<li>int <a class="el" href="cvm-hfa_8c.html#aa2754afcdd94eb3dcd90c374f779dd24">hfa_dev_set_fnp_ppmatchalloc</a> (<a class="el" href="cvm-hfa-osapi_8h.html#a0da07d1a41261e047183f683992758cb">hfa_fnp_ppalloc_cb_t</a> alloc)</li>
<li>int <a class="el" href="cvm-hfa_8c.html#ad022f5aec72780af8b36533884693539">hfa_dev_set_fnp_ppmatchfree</a> (<a class="el" href="cvm-hfa-osapi_8h.html#af04aed5ca25d60de56fd8cb40f4fc35a">hfa_fnp_ppfree_cb_t</a> free)</li>
<li>int <a class="el" href="cvm-hfa_8c.html#a8b71887165c143e32600513d12f9274f">hfa_dev_set_fnp_ppmatchsize</a> (<a class="el" href="cvm-hfa-osapi_8h.html#ab74769f64f7685658eb8e10d3cd78ffc">hfa_fnp_ppsize_cb_t</a> bufsize)</li>
</ul>
<p class="startli">The overloaded hfa_os_ppmatchbufsize() API should always return a constant value which is a multiple of CVMX_CACHE_LINE. Default value is (2 * CVMX_CACHE_LINE)</p>
</li>
</ol>
<h2><a class="anchor" id="hfasdk_pp_singlematch"></a>
d. SINGLEMATCH SEARCH</h2>
<p><a class="el" href="overview.html#hfasdk_pp">POST PROCESSING LIBRARY</a> will report only single match to application (per GRAPH GWALK submit instruction) even if HFA hardware report matches more than one. In case there is no match from HFA hardware, pp will report zero matches to application. SINGLEMATCH search can be enabled/disabled by setting/clearing <a class="el" href="cvm-hfa-search_8h.html#add57b6b19433fd68310bc0b91baa6b97adf3a643afaa029ed58284c17cd1dc7d0">HFA_SEARCHCTX_FSINGLEMATCH</a> bit in <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a><b>: flags </b></p>
<h2><a class="anchor" id="hfasdk_pp_crosssearch"></a>
e. CROSSPACKET SEARCH</h2>
<p>When match in the payload buffer are across multiple packets, such matches will be reported by PP only when <a class="el" href="cvm-hfa-search_8h.html#add57b6b19433fd68310bc0b91baa6b97a11490c915864ff7c6f850ca5ac75adc4">HFA_SEARCHCTX_FNOCROSS</a> bit is disabled in <a class="el" href="structhfa__searchctx.html">hfa_searchctx</a><b>: flags </b></p>
<h2><a class="anchor" id="hfasdk_pp_fsavebuf"></a>
f. FSAVEBUF FLAG</h2>
<p>When <a class="el" href="overview.html#hfasdk_pp_crosssearch">e. CROSSPACKET SEARCH</a> is enabled and matches are across multiple packets then PP can hold buffers to a certain extent. Beyond a threshold limit PP library can't hold all buffers hence in that case PP requires from application to provide all past payload buffers in next search request (per Search Context). Post Processing Library indicate this need by setting a bit <a class="el" href="cvm-hfa-search_8h.html#a3dc6dd6b44dcb039e811796079110ee1ab9fd08f55957564504cb5e72ff7d70b0">HFA_PP_OFLAGS_FSAVEBUF</a> in <a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> <b>.ofields.oflags</b>. This flag , whenever set by pp, indicates that PP requires previously submitted payload buffers (<a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> <b></b>.iovec_0_n ) along with current payload buffer (<a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> <b></b>.iovec ) to report all matches. Application can ignore this flag if it is interested in matches from current payload buffer and not on previously submitted paload buffers. (See <a class="el" href="hfa-se_8c.html">hfa-se.c</a>)</p>
<h2><a class="anchor" id="hfasdk_pp_ctx_stats"></a>
g. PP STATISTICS</h2>
<p>Application can get Post processing statistics for a Search Context per search. These statistics will be helpful in determining PP progress for currently running search.</p>
<p>These statistics are not enabled by default for each Search Context. Application needs to explicitly enable these statistics per <b> Search Context </b> in PP by passing bit <a class="el" href="cvm-hfa-search_8h.html#add57b6b19433fd68310bc0b91baa6b97ac86c4933813275110f5ed18db7852b34">HFA_SEARCHCTX_FENABLE_PPSTATS</a> in <b>flag</b> argument of <a class="el" href="cvm-hfa-search_8c.html#a60c8025118f6a47f924733e47db8c77d">hfa_searchctx_setflags()</a>. (Pre-requisities: <a class="el" href="cvm-hfa-search_8c.html#a954753c0e6f4a59599d05f1262a25b38">hfa_searchctx_setgraph()</a> should be called before <a class="el" href="cvm-hfa-search_8c.html#a60c8025118f6a47f924733e47db8c77d">hfa_searchctx_setflags()</a>)</p>
<p>Once enabled, application can get PP stats during <b><a class="el" href="cvm-hfa-search_8c.html#a6dbb15dc58155b2c94b19784ad42ef89" title="This routine post-processes the search results from the HFA engine and reports the pattern matches fo...">hfa_searchctx_getmatches()</a></b> calling <a class="el" href="cvm-hfa-pp_8c.html#a02d24f276578f8a39a93968262a08f1d">pp()</a> function. Following is the interface provided for PP statistics:</p>
<ul>
<li><a class="el" href="cvm-hfa-search_8c.html#a26b545e4ea8602ce6b32dae8554de39a">hfa_searchctx_get_ppstats</a></li>
<li><a class="el" href="cvm-hfa-search_8c.html#a48920dcf6a80687b7f6c86056f29523a">hfa_searchctx_ppstats_print</a></li>
</ul>
<p><a class="el" href="cvm-hfa-search_8c.html#a26b545e4ea8602ce6b32dae8554de39a">hfa_searchctx_get_ppstats()</a> will return following parameters in <a class="el" href="cvm-hfa-common_8h.html#a689cedf2a0f9290abec19f84a20fe13a">hfa_ppstats_t</a> variable:</p>
<ol type="1">
<li>Total number of RWORD present in Hardware Result Buffer</li>
<li>Current RWORD that PP is processing</li>
<li>Start CPU cycle at which PP function is called [Will be reset in next call to <a class="el" href="cvm-hfa-pp_8c.html#a02d24f276578f8a39a93968262a08f1d">pp()</a> for current Search Context]</li>
<li>Current CPU cycle [ Will be reset in next call to <a class="el" href="cvm-hfa-pp_8c.html#a02d24f276578f8a39a93968262a08f1d">pp()</a> for current Search Context]</li>
</ol>
<h1><a class="anchor" id="hfasdk_stats"></a>
HFA STATISTICS</h1>
<p>HFA SDK allows application to get statistics for</p>
<ul>
<li>Core Statistics : Provide per core statistics for HFA Instruction (GRAPH MLOAD, GRAPH CLOAD, GRAPH WALK, GRAPH FREE) submit and Memory usage.</li>
<li>Search Context Statistics : Provide GRAPH WALK statistics, Partial matches, Total matches, HTE usage and Memory usage per Search Context</li>
</ul>
<p><b>Note</b> </p>
<ul>
<li>To enable various level of HFA Statistics replace "#undef HFA_XXX_STATS" statement in $HFAROOT/drv/include/cvm-hfa-stats.h to "#define HFA_XXX_STATS"</li>
</ul>
<h1><a class="anchor" id="hfasdk_misc"></a>
USEFUL DATA</h1>
<h2><a class="anchor" id="hfasdk_misc_loadbalance"></a>
a. CLUSTER LOAD BALANCING</h2>
<p>In case of GRAPH GWALK Instruction, application can not only specify single cluster on which GWALK instruction to be executed but also allow HFA hardware to decide at run time on which HFA cluster GRAPH GWALK instruction can proceed. When Cluster Load Balancing enabled, HFA Device finds least loaded HFA Cluster (among all clusters on which graph is loaded) at run time and submits instruction to that cluster. This feature is called HFA Cluster Load Balancing</p>
<p>Application can enable Cluster Load Balancing by setting -1 to <a class="el" href="structhfa__searchparams.html">hfa_searchparams</a> <b></b>:clusterno variable</p>
<h2><a class="anchor" id="hfasdk_misc_macros"></a>
b. COMPILE TIME MACROS</h2>
<p>Few compile time macros can be enabled or disabled as per application requirement</p>
<ul>
<li><a class="el" href="cvm-hfa-common_8h.html#aa10743a0ba3fc7c3533dfa0ea0079a25">HFA_STRICT_CHECK</a> This compile time macro is enabled by default. HFA SDK strictly checks each API parameters before executing the main task. Once the application code become stable, this flag can be disabled to improve the performance. Defined in $HFAROOT/drv/include/cvm-hfa-common.h</li>
<li><b>HFA_DEBUG</b> This compile time macro is used to enable debug logs. By default this macro is disabled. For enabling this macro replace following line from $HFAROOT/drv/include/cvm-hfa-osapi.h <pre class="fragment">        Replace "#undef HFA_DEBUG" with "#define HFA_DEBUG"
</pre> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
